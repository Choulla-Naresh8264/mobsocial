{"version":3,"sources":["webpack:///webpack/bootstrap 867d2b11042914830013","webpack:///./libraries/angular/angular.min.js","webpack:///./libraries/angular/angular-ui-router.js","webpack:///./libraries/angular/angular-local-storage.min.js","webpack:///./config.js","webpack:///./app/app.js","webpack:///./app/common/authProvider.js","webpack:///./app/common/webClientService.js","webpack:///./app/public/authentication/loginService.js","webpack:///./app/public/authentication/loginController.js"],"names":[],"mappings":"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tB,gBAAe,MAAM;AACrB;AACA,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;;AAEA,wBAAuB,iBAAiB;AACxC;AACA,4CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,MAAM;AACrB,gBAAe,OAAO;AACtB,iBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,gBAAgB;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,gBAAgB;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,gBAAgB;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB;AACxB;AACA;AACA,mDAAkD,yCAAyC;;;AAG3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA,4DAA2D;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAiD,6BAA6B,EAAE;AAChF,kBAAiB;AACjB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA,mCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sDAAqD;AACrD,uCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uEAAsE;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAiD,QAAQ;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B,0BAAyB;AACzB;AACA;AACA;AACA,sDAAqD;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA,oBAAmB,cAAc;AACjC,sBAAqB,4DAA4D;AACjF,oBAAmB,cAAc;AACjC,iCAAgC,sDAAsD;AACtF,oBAAmB,SAAS;AAC5B,aAAY,gEAAgE;AAC5E,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,oDAAmD,iBAAiB;AACpE;AACA,qBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,cAAc;AACjC;AACA,oBAAmB,OAAO;AAC1B;AACA,qBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA,oBAAmB,OAAO;AAC1B,qBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,kCAAkC,sBAAsB,EAAE;AACrF,4CAA2C,sBAAsB,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,cAAa,iBAAiB;AAC9B,qBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA,gEAA+D,iBAAiB;AAChF;AACA;;AAEA;;AAEA,gBAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,uDAAuD;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB,aAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,GAAG;AACrB,mBAAkB,SAAS;AAC3B,mBAAkB,eAAe,KAAK;AACtC;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA,uBAAsB,WAAW;AACjC;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,mBAAkB,OAAO;AACzB,gEAA+D,yDAAyD;AACxH;AACA;AACA,mBAAkB,OAAO;AACzB;AACA,mBAAkB,OAAO;AACzB;AACA,mBAAkB,OAAO;AACzB;AACA,mBAAkB,OAAO;AACzB;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA,0BAAyB,WAAW,EAAE,gCAAgC;;AAEtE;AACA;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,oBAAoB;AACnC;AACA;AACA;AACA,iBAAgB,8BAA8B;AAC9C;AACA,mBAAkB;AAClB;AACA,iBAAgB,OAAO,YAAY;AACnC,gDAA+C,2BAA2B,WAAW,OAAO,YAAY,OAAO;AAC/G,wDAAuD,6BAA6B,WAAW,OAAO,YAAY,OAAO;AACzH;AACA;AACA,qEAAoE;AACpE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yFAAwF;AACxF;AACA;AACA,kFAAiF;AACjF;AACA;AACA;AACA;AACA,uEAAsE;AACtE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;;AAEA;AACA,+EAA8E,wEAAwE;AACtJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,GAAG;AACjC,+BAA8B,GAAG;AACjC;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,kBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,GAAG;AACjC;AACA,SAAQ;AACR,oBAAmB;AACnB;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB;;AAErB;;AAEA;AACA,0CAAyC,yCAAyC;AAClF,0CAAyC,iCAAiC;;AAE1E;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,kBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,GAAG,aAAa,oBAAoB;AAClE;AACA;AACA;AACA,gBAAe,OAAO;AACtB,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qCAAoC;AACpC,wEAAuE,4DAA4D,EAAE;AACrI;;AAEA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAoD;AACpD;AACA;AACA,aAAY,iFAAiF;AAC7F;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,iCAAgC,0BAA0B,EAAE;AAC5D,iCAAgC,8BAA8B,EAAE;AAChE,kCAAiC,8BAA8B,EAAE;AACjE,6BAA4B,6DAA6D,EAAE;AAC3F;AACA;AACA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,EAAE;AACjB,gBAAe,OAAO;AACtB,gBAAe,kDAAkD;AACjE;AACA,kBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,EAAE;AACjB,gBAAe,OAAO;AACtB;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA,kBAAiB,EAAE;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,EAAE;AACjB,gBAAe,EAAE;AACjB,kBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,4CAA2C,UAAU,uBAAuB,EAAE;;AAE9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAqC,2DAA2D;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,aAAa;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,qBAAoB,kDAAkD;AACtE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oCAAmC,qFAAqF;AACxH,sCAAqC,oFAAoF;;AAEzH,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,qCAAoC,kEAAkE,EAAE;AACxG;AACA,cAAa;AACb;AACA;AACA,yCAAwC,0BAA0B,EAAE;AACpE,qCAAoC,8DAA8D,EAAE;AACpG;AACA,cAAa;AACb;AACA,yCAAwC,oBAAoB,EAAE;AAC9D,yCAAwC,gCAAgC,EAAE;AAC1E,qCAAoC,sCAAsC,EAAE;AAC5E;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB,qCAAoC,qDAAqD,EAAE;AAC3F,0CAAyC,wEAAwE,EAAE;AACnH,iCAAgC,EAAE;AAClC,kCAAiC,EAAE;AACnC,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,QAAQ,uDAAuD;AAClF,sBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B,sBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,kDAAkD;AACxE;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B,sBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,sBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,sCAAsC;AACrE;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,gBAAgB;AACnC,oBAAmB,sCAAsC;AACzD,oBAAmB,gBAAgB;AACnC;AACA,wBAAuB,sCAAsC;AAC7D;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA,2BAA0B,cAAc;AACxC;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA,+BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ,sBAAqB,cAAc;AACnC;AACA;AACA;AACA,eAAc;AACd;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,6CAA4C,aAAa;AACzD;AACA,iCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAqD,iCAAiC,aAAa,SAAS,EAAE;AAC9G,oCAAmC;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,cAAc;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C,wFAAuF,qBAAqB;AAC5G;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAqC;AACrC,mEAAkE,cAAc;AAChF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,2DAA2D;AAC9E,oBAAmB;AACnB;AACA;AACA;AACA,mCAAkC,8BAA8B;AAChE,gEAA+D,kBAAkB,EAAE;AACnF,+DAA8D,kDAAkD,EAAE;AAClH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA6C,wBAAwB,yBAAyB,GAAG;AACjG;AACA,uGAAsG,eAAe,EAAE;AACvH;AACA;AACA;AACA;AACA;;AAEA,kCAAiC,UAAU,oFAAoF,EAAE;;AAEjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA,8DAA6D,iBAAiB;AAC9E,cAAa;AACb;AACA;AACA;AACA,iCAAgC,oBAAoB,0BAA0B;AAC9E;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB;AACA,cAAa;AACb;AACA,gCAA+B;AAC/B;AACA;AACA,kBAAiB;AACjB;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,cAAa;AACb;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA,sCAAqC;AACrC;AACA;AACA,sCAAqC;AACrC;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gGAA+F,EAAE;;AAEjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qEAAoE;AACpE;AACA;;AAEA;AACA;AACA,8CAA6C,IAAI;AACjD;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd,aAAY;AACZ;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd,aAAY;AACZ;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,qCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,8DAA6D,gBAAgB;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd,aAAY;AACZ;AACA;AACA,oBAAmB,cAAc;AACjC,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAgE,gCAAgC,EAAE;AAClG;AACA;AACA;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA,iEAAgE,sCAAsC,EAAE;AACxG;AACA;AACA;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA;;AAEA,0BAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB,eAAc;AACd;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB,qBAAoB;AACpB;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;;AAEjB;AACA,6DAA4D;;AAE5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,kDAAkD;AACtE;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA,4BAA2B,WAAW;AACtC,4BAA2B,QAAQ;AACnC,4BAA2B,QAAQ;AACnC;AACA,wCAAuC,cAAc;AACrD;AACA,8BAA6B,OAAO;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA6B,oBAAoB;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA,gDAA+C,2BAA2B;;AAE1E;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA,2CAA0C;AAC1C;AACA,kBAAiB;AACjB;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAgE,YAAY;AAC5E;AACA;AACA,kBAAiB;AACjB;AACA,cAAa;;AAEb;AACA;AACA,4EAA2E;AAC3E,cAAa;;AAEb;AACA;AACA,wDAAuD;AACvD;AACA;AACA,cAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C,wCAAuC,kBAAkB;AACzD,cAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6DAA4D,iCAAiC;AAC7F;AACA,kBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qDAAoD,OAAO;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,OAAO;AACjC,yBAAwB,OAAO;AAC/B;AACA,wBAAuB,OAAO,eAAe;AAC7C;AACA,8BAA6B,OAAO;AACpC;AACA,2BAA0B,OAAO;AACjC;AACA,0BAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA,8BAA6B,OAAO;AACpC;AACA,yBAAwB,OAAO;AAC/B;AACA,6BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA,aAAY;AACZ;AACA;AACA;AACA,iCAAgC,+BAA+B;AAC/D,iCAAgC;AAChC;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,OAAO;AAC1B;AACA;AACA,kBAAiB,OAAO;AACxB,kBAAiB,OAAO;AACxB;AACA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA,oBAAmB,OAAO;AAC1B,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,UAAU,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD,EAAE;AACxD;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,UAAU,WAAW;AACrC;AACA;AACA;AACA;AACA,kDAAiD,EAAE;AACnD;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA,kDAAiD,EAAE;AACnD;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA,+BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,OAAO;AAC7B,2BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,gDAAgD,cAAc;AACjF;AACA;AACA;AACA;AACA;AACA,0BAAyB,kBAAkB;AAC3C,0BAAyB,eAAe;AACxC,0BAAyB,qBAAqB,EAAE,eAAe;AAC/D;AACA,6BAA4B,YAAY,EAAE,WAAW;AACrD,wCAAuC,YAAY,EAAE,WAAW;AAChE;AACA;AACA,oBAAmB,QAAQ;AAC3B;AACA,+BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,eAAc;AACd;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA,+BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,yBAAyB;AACxE;AACA,+BAA8B,WAAW;AACzC;AACA;AACA,yBAAwB;AACxB,aAAY;AACZ;AACA,gCAA+B,aAAa;AAC5C;AACA;AACA,sBAAqB,4FAA4F;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA,kDAAiD;AACjD;AACA;AACA,oEAAmE;AACnE;AACA;AACA;AACA,+BAA8B;AAC9B,gCAA+B;AAC/B,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,OAAO,8BAA8B,uBAAuB;AAClF;AACA,uBAAsB,OAAO;AAC7B;AACA,uBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC,4BAA2B,OAAO;AAClC,4BAA2B,MAAM;AACjC,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,6CAA4C,SAAS,GAAG,cAAc;AACtE;AACA;AACA;AACA;AACA,qDAAoD;AACpD,2DAA0D,KAAK;AAC/D,0DAAyD,KAAK,cAAc;AAC5E,qBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;;AAEA;AACA;;AAEA,4BAA2B,0BAA0B,iBAAiB,EAAE;;AAExE;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA,mE;AACA;AACA,iBAAgB;AAChB;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA,mE;AACA;AACA,iBAAgB;AAChB;;AAEA,0BAAyB,QAAQ;AACjC,iBAAgB,kDAAkD;AAClE;AACA;AACA,2EAA0E,sDAAsD;AAChI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,yEAAyE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA,oCAAmC,qBAAqB;AACxD;AACA,mCAAkC,aAAa;AAC/C,oCAAmC,uBAAuB;AAC1D;AACA,kCAAiC,aAAa;AAC9C,2CAA0C,4BAA4B;AACtE;AACA,yHAAwH;AACxH;AACA;AACA,0BAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D,2CAA2C;AAC1G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA,wBAAuB,OAAO;AAC9B,wBAAuB,QAAQ;AAC/B;AACA,wBAAuB,QAAQ;AAC/B;AACA,oCAAmC,qBAAqB;AACxD;AACA,mCAAkC,cAAc;AAChD,oCAAmC,QAAQ;AAC3C;AACA,kCAAiC,aAAa;AAC9C,2CAA0C,8BAA8B;AACxE;AACA;AACA;AACA;AACA;AACA,0BAAyB,QAAQ;AACjC,iBAAgB,kDAAkD;AAClE;AACA;AACA;AACA;AACA;AACA,kBAAiB,eAAe;;AAEhC;AACA;;AAEA;AACA;;AAEA;AACA,qCAAoC;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA0F;AAC1F;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,2EAA0E;;AAE1E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,OAAO;AACtC,gCAA+B,MAAM;AACrC,gCAA+B,OAAO;AACtC,gCAA+B,MAAM;AACrC,gCAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAkC,mBAAmB;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,OAAO;AAC1C,oCAAmC,MAAM;AACzC,oCAAmC,OAAO;AAC1C,oCAAmC,MAAM;AACzC,oCAAmC,OAAO;AAC1C;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,OAAO;AACtC,gCAA+B,MAAM;AACrC,gCAA+B,OAAO;AACtC,gCAA+B,MAAM;AACrC,gCAA+B,OAAO;AACtC,gCAA+B,MAAM;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,8DAA8D;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD;AACjD,wDAAuD;AACvD;AACA;AACA;AACA,gCAA+B,gCAAgC;AAC/D;AACA;AACA,wBAAuB,cAAc;AACrC,wBAAuB,QAAQ,+BAA+B,sBAAsB;AACpF;AACA,wBAAuB,QAAQ;AAC/B;AACA,oCAAmC,cAAc;AACjD;AACA;AACA,0BAAyB,QAAQ;AACjC;AACA;AACA,mCAAkC,4BAA4B,eAAe;AAC7E;;AAEA,yCAAwC,kBAAkB;AAC1D,iDAAgD,cAAc;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C,oDAAmD;AACnD,yDAAwD;AACxD,iDAAgD;AAChD,yCAAwC;AACxC;AACA;AACA;AACA,gCAA+B,sCAAsC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD;AAChD,gDAA+C;AAC/C,8CAA6C;AAC7C,sDAAqD;AACrD,mDAAkD;AAClD,+CAA8C;AAC9C,2CAA0C;AAC1C;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA,wBAAuB,QAAQ,+BAA+B,sBAAsB;AACpF;AACA,wBAAuB,QAAQ;AAC/B;AACA,oCAAmC,eAAe;AAClD;AACA;AACA,0BAAyB,QAAQ;AACjC;AACA;AACA,mCAAkC,4BAA4B,eAAe;AAC7E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAwC,kBAAkB;AAC1D,wEAAuE,cAAc;AACrF;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,gBAAgB;AACnE;AACA;AACA,wBAAuB,cAAc;AACrC,wBAAuB,QAAQ;AAC/B,wBAAuB,QAAQ;AAC/B;AACA,iCAAgC,aAAa;AAC7C;AACA;AACA,mCAAkC,aAAa;AAC/C,oCAAmC,uBAAuB;AAC1D;AACA,oCAAmC,cAAc;AACjD;AACA,0BAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,eAAe;;AAEhC;;AAEA;AACA,uFAAsF;;AAEtF;;AAEA;AACA;AACA;AACA,6GAA4G;AAC5G;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,eAAe;AACtC;AACA,wBAAuB,eAAe;AACtC,0BAAyB,aAAa;AACtC;AACA;AACA,6FAA4F,0BAA0B,EAAE;AACxH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;;AAE9B;AACA,8DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA,8GAA6G;AAC7G;AACA,sDAAqD,gFAAgF;AACrI,0BAAyB;;AAEzB;AACA;AACA;AACA,qEAAoE;AACpE;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB,sBAAqB;;AAErB;AACA;AACA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA4C,WAAW,EAAE;AACzD;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,0EAA0E;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAkC,oCAAoC;AACtE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,8GAA8G;AACzJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,UAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA,gBAAe,QAAQ;AACvB;AACA,kBAAiB,oCAAoC;AACrD;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA,mGAAkG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,W;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,W;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA,W;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAuD,uBAAuB,MAAM,EAAE;AACtF,gDAA+C,kBAAkB,MAAM;AACvE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,0BAAyB;AACzB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,0BAAyB;AACzB;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4DAA2D,sCAAsC,MAAM,EAAE;AACzG,oDAAmD,wBAAwB,MAAM;AACjF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB;;AAErB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA6B;;AAE7B;AACA,0BAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6GAA4G;AAC5G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,OAAO;AAC1C,oCAAmC,OAAO;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,OAAO;AAC1C,oCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA8C,oCAAoC;AAClF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0CAAyC,GAAG,GAAG;AAC/C;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,wDAAwD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAgF,QAAQ;AACxF;AACA;AACA;AACA,6CAA4C,iBAAiB,KAAK,gBAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,uIAAsI,QAAQ;AAC9I;AACA;AACA;AACA,iEAAgE,iBAAiB;AACjF;AACA;AACA,iEAAgE,iBAAiB;AACjF;AACA;AACA,iEAAgE,iBAAiB;AACjF;AACA;AACA;AACA,yCAAwC,aAAa;AACrD;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO,kCAAkC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;;AAEA,yHAAwH;;AAExH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iEAAgE,qCAAqC,EAAE;AACvG;AACA;AACA;;AAEA;AACA,+FAA8F,YAAY,EAAE;AAC5G;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO,oCAAoC;AAC1D,gBAAe,OAAO,mCAAmC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA4D,sBAAsB,EAAE;AACpF,4BAA2B;;AAE3B;AACA,0CAAyC,uBAAuB;AAChE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+FAA8F,YAAY,EAAE;AAC5G;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,8DAA8D;AAClF,oEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;;AAEnD;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,0CAAyC,kBAAkB;AAC3D;AACA;AACA,sBAAqB;;AAErB;AACA;;AAEA;AACA,4BAA2B,OAAO;AAClC,4BAA2B,cAAc;AACzC,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAmC,mBAAmB;AACtD;AACA;AACA,0BAAyB;AACzB;AACA;;AAEA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;;AAEA,mDAAkD,uBAAuB,wBAAwB,EAAE,EAAE;AACrG,sDAAqD,2BAA2B;AAChF,mDAAkD,4CAA4C;AAC9F,qDAAoD,sCAAsC;;AAE1F;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,+DAA+D;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,wFAAwF;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC,0B;;;;;;;;;AC17ID;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,8FAA8F,4EAA4E,8DAA8D,mBAAmB,sCAAsC,yBAAyB,4BAA4B,0BAA0B,iCAAiC,+BAA+B,qCAAqC,qCAAqC,qCAAqC,oDAAoD,yCAAyC,iCAAiC,8BAA8B,oBAAoB,uBAAuB,MAAM,uFAAuF,cAAc,uCAAuC,eAAe,aAAa,wDAAwD,oDAAoD,EAAE,GAAG,8DAA8D,+DAA+D,kBAAkB,WAAW,eAAe,2CAA2C,eAAe,wBAAwB,cAAc,IAAI,kEAAkE,qDAAqD,SAAS,2GAA2G,yBAAyB,4OAA4O,sCAAsC,SAAS,IAAI,wFAAwF,2CAA2C,EAAE,SAAS,8EAA8E,SAAS,iBAAiB,6JAA6J,6BAA6B,8BAA8B,IAAI,qBAAqB,SAAS,UAAU,cAAc,QAAQ,gKAAgK,QAAQ,QAAQ,qBAAqB,wOAAwO,2BAA2B,OAAO,SAAS,4FAA4F,gCAAgC,EAAE,SAAS,sEAAsE,eAAe,2GAA2G,oBAAoB,wCAAwC,oBAAoB,SAAS,8EAA8E,SAAS,iBAAiB,KAAK,kEAAkE,uJAAuJ,mCAAmC,eAAe,qDAAqD,eAAe,SAAS,2EAA2E,SAAS,cAAc,IAAI,wHAAwH,SAAS,2EAA2E,qBAAqB,iBAAiB,qHAAqH,IAAI,yBAAyB,+CAA+C,wFAAwF,4FAA4F,+BAA+B,QAAQ,eAAe,eAAe,mEAAmE,SAAS,0EAA0E,SAAS,eAAe,8FAA8F,qCAAqC,WAAW,WAAW,KAAK,eAAe,kBAAkB,2BAA2B,4BAA4B,oEAAoE,IAAI,qBAAqB,SAAS,WAAW,YAAY,eAAe,UAAU,cAAc,6CAA6C,OAAO,WAAW,KAAK,WAAW,kBAAkB,2BAA2B,oCAAoC,MAAM,cAAc,SAAS,eAAe,+BAA+B,uBAAuB,OAAO,aAAa,yFAAyF,SAAS,WAAW,uGAAuG,kBAAkB,KAAK,uBAAuB,WAAW,iCAAiC,UAAU,OAAO,oLAAoL,sDAAsD,EAAE,EAAE;AAC9yL,sD;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;;;AAGb;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,EAAC,G;;;;;;;;;ACrBD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC,G;;;;;;;;;AC1CD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,I;;;;;;;;;ACPA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA,kBAAiB;AACjB;AACA;AACA,I","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 867d2b11042914830013\n **/","/*\r\n AngularJS v1.2.25\r\n (c) 2010-2014 Google, Inc. http://angularjs.org\r\n License: MIT\r\n*/\r\n(function (W, X, t) {\r\n    'use strict'; function D(b) { return function () { var a = arguments[0], c, a = \"[\" + (b ? b + \":\" : \"\") + a + \"] http://errors.angularjs.org/1.2.25/\" + (b ? b + \"/\" : \"\") + a; for (c = 1; c < arguments.length; c++) a = a + (1 == c ? \"?\" : \"&\") + \"p\" + (c - 1) + \"=\" + encodeURIComponent(\"function\" == typeof arguments[c] ? arguments[c].toString().replace(/ \\{[\\s\\S]*$/, \"\") : \"undefined\" == typeof arguments[c] ? \"undefined\" : \"string\" != typeof arguments[c] ? JSON.stringify(arguments[c]) : arguments[c]); return Error(a) } } function Pa(b) {\r\n        if (null == b || Ga(b)) return !1;\r\n        var a = b.length; return 1 === b.nodeType && a ? !0 : A(b) || I(b) || 0 === a || \"number\" === typeof a && 0 < a && a - 1 in b\r\n    } function r(b, a, c) { var d; if (b) if (P(b)) for (d in b) \"prototype\" == d || (\"length\" == d || \"name\" == d || b.hasOwnProperty && !b.hasOwnProperty(d)) || a.call(c, b[d], d); else if (I(b) || Pa(b)) for (d = 0; d < b.length; d++) a.call(c, b[d], d); else if (b.forEach && b.forEach !== r) b.forEach(a, c); else for (d in b) b.hasOwnProperty(d) && a.call(c, b[d], d); return b } function Zb(b) { var a = [], c; for (c in b) b.hasOwnProperty(c) && a.push(c); return a.sort() } function Tc(b,\r\n    a, c) { for (var d = Zb(b), e = 0; e < d.length; e++) a.call(c, b[d[e]], d[e]); return d } function $b(b) { return function (a, c) { b(c, a) } } function hb() { for (var b = ma.length, a; b;) { b--; a = ma[b].charCodeAt(0); if (57 == a) return ma[b] = \"A\", ma.join(\"\"); if (90 == a) ma[b] = \"0\"; else return ma[b] = String.fromCharCode(a + 1), ma.join(\"\") } ma.unshift(\"0\"); return ma.join(\"\") } function ac(b, a) { a ? b.$$hashKey = a : delete b.$$hashKey } function J(b) { var a = b.$$hashKey; r(arguments, function (a) { a !== b && r(a, function (a, c) { b[c] = a }) }); ac(b, a); return b } function U(b) {\r\n        return parseInt(b,\r\n        10)\r\n    } function bc(b, a) { return J(new (J(function () { }, { prototype: b })), a) } function F() { } function Qa(b) { return b } function ba(b) { return function () { return b } } function y(b) { return \"undefined\" === typeof b } function z(b) { return \"undefined\" !== typeof b } function T(b) { return null != b && \"object\" === typeof b } function A(b) { return \"string\" === typeof b } function ib(b) { return \"number\" === typeof b } function ta(b) { return \"[object Date]\" === za.call(b) } function P(b) { return \"function\" === typeof b } function jb(b) { return \"[object RegExp]\" === za.call(b) }\r\n    function Ga(b) { return b && b.document && b.location && b.alert && b.setInterval } function Uc(b) { return !(!b || !(b.nodeName || b.prop && b.attr && b.find)) } function Vc(b, a, c) { var d = []; r(b, function (b, f, g) { d.push(a.call(c, b, f, g)) }); return d } function Ra(b, a) { if (b.indexOf) return b.indexOf(a); for (var c = 0; c < b.length; c++) if (a === b[c]) return c; return -1 } function Sa(b, a) { var c = Ra(b, a); 0 <= c && b.splice(c, 1); return a } function Ha(b, a, c, d) {\r\n        if (Ga(b) || b && b.$evalAsync && b.$watch) throw Ta(\"cpws\"); if (a) {\r\n            if (b === a) throw Ta(\"cpi\"); c = c || [];\r\n            d = d || []; if (T(b)) { var e = Ra(c, b); if (-1 !== e) return d[e]; c.push(b); d.push(a) } if (I(b)) for (var f = a.length = 0; f < b.length; f++) e = Ha(b[f], null, c, d), T(b[f]) && (c.push(b[f]), d.push(e)), a.push(e); else { var g = a.$$hashKey; I(a) ? a.length = 0 : r(a, function (b, c) { delete a[c] }); for (f in b) e = Ha(b[f], null, c, d), T(b[f]) && (c.push(b[f]), d.push(e)), a[f] = e; ac(a, g) }\r\n        } else if (a = b) I(b) ? a = Ha(b, [], c, d) : ta(b) ? a = new Date(b.getTime()) : jb(b) ? (a = RegExp(b.source, b.toString().match(/[^\\/]*$/)[0]), a.lastIndex = b.lastIndex) : T(b) && (a = Ha(b, {}, c, d));\r\n        return a\r\n    } function ha(b, a) { if (I(b)) { a = a || []; for (var c = 0; c < b.length; c++) a[c] = b[c] } else if (T(b)) for (c in a = a || {}, b) !kb.call(b, c) || \"$\" === c.charAt(0) && \"$\" === c.charAt(1) || (a[c] = b[c]); return a || b } function Aa(b, a) {\r\n        if (b === a) return !0; if (null === b || null === a) return !1; if (b !== b && a !== a) return !0; var c = typeof b, d; if (c == typeof a && \"object\" == c) if (I(b)) { if (!I(a)) return !1; if ((c = b.length) == a.length) { for (d = 0; d < c; d++) if (!Aa(b[d], a[d])) return !1; return !0 } } else {\r\n            if (ta(b)) return ta(a) ? isNaN(b.getTime()) && isNaN(a.getTime()) || b.getTime() ===\r\n            a.getTime() : !1; if (jb(b) && jb(a)) return b.toString() == a.toString(); if (b && b.$evalAsync && b.$watch || a && a.$evalAsync && a.$watch || Ga(b) || Ga(a) || I(a)) return !1; c = {}; for (d in b) if (\"$\" !== d.charAt(0) && !P(b[d])) { if (!Aa(b[d], a[d])) return !1; c[d] = !0 } for (d in a) if (!c.hasOwnProperty(d) && \"$\" !== d.charAt(0) && a[d] !== t && !P(a[d])) return !1; return !0\r\n        } return !1\r\n    } function Bb(b, a) {\r\n        var c = 2 < arguments.length ? Ba.call(arguments, 2) : []; return !P(a) || a instanceof RegExp ? a : c.length ? function () {\r\n            return arguments.length ? a.apply(b, c.concat(Ba.call(arguments,\r\n            0))) : a.apply(b, c)\r\n        } : function () { return arguments.length ? a.apply(b, arguments) : a.call(b) }\r\n    } function Wc(b, a) { var c = a; \"string\" === typeof b && \"$\" === b.charAt(0) ? c = t : Ga(a) ? c = \"$WINDOW\" : a && X === a ? c = \"$DOCUMENT\" : a && (a.$evalAsync && a.$watch) && (c = \"$SCOPE\"); return c } function na(b, a) { return \"undefined\" === typeof b ? t : JSON.stringify(b, Wc, a ? \"  \" : null) } function cc(b) { return A(b) ? JSON.parse(b) : b } function Ua(b) {\r\n        \"function\" === typeof b ? b = !0 : b && 0 !== b.length ? (b = M(\"\" + b), b = !(\"f\" == b || \"0\" == b || \"false\" == b || \"no\" == b || \"n\" == b || \"[]\" == b)) : b = !1;\r\n        return b\r\n    } function ia(b) { b = v(b).clone(); try { b.empty() } catch (a) { } var c = v(\"<div>\").append(b).html(); try { return 3 === b[0].nodeType ? M(c) : c.match(/^(<[^>]+>)/)[1].replace(/^<([\\w\\-]+)/, function (a, b) { return \"<\" + M(b) }) } catch (d) { return M(c) } } function dc(b) { try { return decodeURIComponent(b) } catch (a) { } } function ec(b) { var a = {}, c, d; r((b || \"\").split(\"&\"), function (b) { b && (c = b.replace(/\\+/g, \"%20\").split(\"=\"), d = dc(c[0]), z(d) && (b = z(c[1]) ? dc(c[1]) : !0, kb.call(a, d) ? I(a[d]) ? a[d].push(b) : a[d] = [a[d], b] : a[d] = b)) }); return a } function Cb(b) {\r\n        var a =\r\n        []; r(b, function (b, d) { I(b) ? r(b, function (b) { a.push(Ca(d, !0) + (!0 === b ? \"\" : \"=\" + Ca(b, !0))) }) : a.push(Ca(d, !0) + (!0 === b ? \"\" : \"=\" + Ca(b, !0))) }); return a.length ? a.join(\"&\") : \"\"\r\n    } function lb(b) { return Ca(b, !0).replace(/%26/gi, \"&\").replace(/%3D/gi, \"=\").replace(/%2B/gi, \"+\") } function Ca(b, a) { return encodeURIComponent(b).replace(/%40/gi, \"@\").replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, a ? \"%20\" : \"+\") } function Xc(b, a) {\r\n        function c(a) { a && d.push(a) } var d = [b], e, f, g = [\"ng:app\", \"ng-app\", \"x-ng-app\",\r\n        \"data-ng-app\"], k = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/; r(g, function (a) { g[a] = !0; c(X.getElementById(a)); a = a.replace(\":\", \"\\\\:\"); b.querySelectorAll && (r(b.querySelectorAll(\".\" + a), c), r(b.querySelectorAll(\".\" + a + \"\\\\:\"), c), r(b.querySelectorAll(\"[\" + a + \"]\"), c)) }); r(d, function (a) { if (!e) { var b = k.exec(\" \" + a.className + \" \"); b ? (e = a, f = (b[2] || \"\").replace(/\\s+/g, \",\")) : r(a.attributes, function (b) { !e && g[b.name] && (e = a, f = b.value) }) } }); e && a(e, f ? [f] : [])\r\n    } function fc(b, a) {\r\n        var c = function () {\r\n            b = v(b); if (b.injector()) {\r\n                var c = b[0] === X ?\r\n                \"document\" : ia(b); throw Ta(\"btstrpd\", c.replace(/</, \"&lt;\").replace(/>/, \"&gt;\"));\r\n            } a = a || []; a.unshift([\"$provide\", function (a) { a.value(\"$rootElement\", b) }]); a.unshift(\"ng\"); c = gc(a); c.invoke([\"$rootScope\", \"$rootElement\", \"$compile\", \"$injector\", \"$animate\", function (a, b, c, d, e) { a.$apply(function () { b.data(\"$injector\", d); c(b)(a) }) }]); return c\r\n        }, d = /^NG_DEFER_BOOTSTRAP!/; if (W && !d.test(W.name)) return c(); W.name = W.name.replace(d, \"\"); Va.resumeBootstrap = function (b) { r(b, function (b) { a.push(b) }); c() }\r\n    } function mb(b, a) {\r\n        a =\r\n        a || \"_\"; return b.replace(Yc, function (b, d) { return (d ? a : \"\") + b.toLowerCase() })\r\n    } function Db(b, a, c) { if (!b) throw Ta(\"areq\", a || \"?\", c || \"required\"); return b } function Wa(b, a, c) { c && I(b) && (b = b[b.length - 1]); Db(P(b), a, \"not a function, got \" + (b && \"object\" === typeof b ? b.constructor.name || \"Object\" : typeof b)); return b } function Da(b, a) { if (\"hasOwnProperty\" === b) throw Ta(\"badname\", a); } function hc(b, a, c) { if (!a) return b; a = a.split(\".\"); for (var d, e = b, f = a.length, g = 0; g < f; g++) d = a[g], b && (b = (e = b)[d]); return !c && P(b) ? Bb(e, b) : b } function Eb(b) {\r\n        var a =\r\n        b[0]; b = b[b.length - 1]; if (a === b) return v(a); var c = [a]; do { a = a.nextSibling; if (!a) break; c.push(a) } while (a !== b); return v(c)\r\n    } function Zc(b) {\r\n        var a = D(\"$injector\"), c = D(\"ng\"); b = b.angular || (b.angular = {}); b.$$minErr = b.$$minErr || D; return b.module || (b.module = function () {\r\n            var b = {}; return function (e, f, g) {\r\n                if (\"hasOwnProperty\" === e) throw c(\"badname\", \"module\"); f && b.hasOwnProperty(e) && (b[e] = null); return b[e] || (b[e] = function () {\r\n                    function b(a, d, e) { return function () { c[e || \"push\"]([a, d, arguments]); return n } } if (!f) throw a(\"nomod\",\r\n                    e); var c = [], d = [], l = b(\"$injector\", \"invoke\"), n = { _invokeQueue: c, _runBlocks: d, requires: f, name: e, provider: b(\"$provide\", \"provider\"), factory: b(\"$provide\", \"factory\"), service: b(\"$provide\", \"service\"), value: b(\"$provide\", \"value\"), constant: b(\"$provide\", \"constant\", \"unshift\"), animation: b(\"$animateProvider\", \"register\"), filter: b(\"$filterProvider\", \"register\"), controller: b(\"$controllerProvider\", \"register\"), directive: b(\"$compileProvider\", \"directive\"), config: l, run: function (a) { d.push(a); return this } }; g && l(g); return n\r\n                }())\r\n            }\r\n        }())\r\n    }\r\n    function $c(b) {\r\n        J(b, { bootstrap: fc, copy: Ha, extend: J, equals: Aa, element: v, forEach: r, injector: gc, noop: F, bind: Bb, toJson: na, fromJson: cc, identity: Qa, isUndefined: y, isDefined: z, isString: A, isFunction: P, isObject: T, isNumber: ib, isElement: Uc, isArray: I, version: ad, isDate: ta, lowercase: M, uppercase: Ia, callbacks: { counter: 0 }, $$minErr: D, $$csp: Xa }); Ya = Zc(W); try { Ya(\"ngLocale\") } catch (a) { Ya(\"ngLocale\", []).provider(\"$locale\", bd) } Ya(\"ng\", [\"ngLocale\"], [\"$provide\", function (a) {\r\n            a.provider({ $$sanitizeUri: cd }); a.provider(\"$compile\",\r\n            ic).directive({ a: dd, input: jc, textarea: jc, form: ed, script: fd, select: gd, style: hd, option: id, ngBind: jd, ngBindHtml: kd, ngBindTemplate: ld, ngClass: md, ngClassEven: nd, ngClassOdd: od, ngCloak: pd, ngController: qd, ngForm: rd, ngHide: sd, ngIf: td, ngInclude: ud, ngInit: vd, ngNonBindable: wd, ngPluralize: xd, ngRepeat: yd, ngShow: zd, ngStyle: Ad, ngSwitch: Bd, ngSwitchWhen: Cd, ngSwitchDefault: Dd, ngOptions: Ed, ngTransclude: Fd, ngModel: Gd, ngList: Hd, ngChange: Id, required: kc, ngRequired: kc, ngValue: Jd }).directive({ ngInclude: Kd }).directive(Fb).directive(lc);\r\n            a.provider({ $anchorScroll: Ld, $animate: Md, $browser: Nd, $cacheFactory: Od, $controller: Pd, $document: Qd, $exceptionHandler: Rd, $filter: mc, $interpolate: Sd, $interval: Td, $http: Ud, $httpBackend: Vd, $location: Wd, $log: Xd, $parse: Yd, $rootScope: Zd, $q: $d, $sce: ae, $sceDelegate: be, $sniffer: ce, $templateCache: de, $timeout: ee, $window: fe, $$rAF: ge, $$asyncCallback: he })\r\n        }])\r\n    } function Za(b) { return b.replace(ie, function (a, b, d, e) { return e ? d.toUpperCase() : d }).replace(je, \"Moz$1\") } function Gb(b, a, c, d) {\r\n        function e(b) {\r\n            var e = c && b ? [this.filter(b)] :\r\n            [this], m = a, h, l, n, p, q, s; if (!d || null != b) for (; e.length;) for (h = e.shift(), l = 0, n = h.length; l < n; l++) for (p = v(h[l]), m ? p.triggerHandler(\"$destroy\") : m = !m, q = 0, p = (s = p.children()).length; q < p; q++) e.push(Ea(s[q])); return f.apply(this, arguments)\r\n        } var f = Ea.fn[b], f = f.$original || f; e.$original = f; Ea.fn[b] = e\r\n    } function S(b) {\r\n        if (b instanceof S) return b; A(b) && (b = aa(b)); if (!(this instanceof S)) { if (A(b) && \"<\" != b.charAt(0)) throw Hb(\"nosel\"); return new S(b) } if (A(b)) {\r\n            var a = b; b = X; var c; if (c = ke.exec(a)) b = [b.createElement(c[1])]; else {\r\n                var d =\r\n                b, e; b = d.createDocumentFragment(); c = []; if (Ib.test(a)) { d = b.appendChild(d.createElement(\"div\")); e = (le.exec(a) || [\"\", \"\"])[1].toLowerCase(); e = ea[e] || ea._default; d.innerHTML = \"<div>&#160;</div>\" + e[1] + a.replace(me, \"<$1></$2>\") + e[2]; d.removeChild(d.firstChild); for (a = e[0]; a--;) d = d.lastChild; a = 0; for (e = d.childNodes.length; a < e; ++a) c.push(d.childNodes[a]); d = b.firstChild; d.textContent = \"\" } else c.push(d.createTextNode(a)); b.textContent = \"\"; b.innerHTML = \"\"; b = c\r\n            } Jb(this, b); v(X.createDocumentFragment()).append(this)\r\n        } else Jb(this,\r\n        b)\r\n    } function Kb(b) { return b.cloneNode(!0) } function Ja(b) { Lb(b); var a = 0; for (b = b.childNodes || []; a < b.length; a++) Ja(b[a]) } function nc(b, a, c, d) { if (z(d)) throw Hb(\"offargs\"); var e = oa(b, \"events\"); oa(b, \"handle\") && (y(a) ? r(e, function (a, c) { $a(b, c, a); delete e[c] }) : r(a.split(\" \"), function (a) { y(c) ? ($a(b, a, e[a]), delete e[a]) : Sa(e[a] || [], c) })) } function Lb(b, a) { var c = b.ng339, d = ab[c]; d && (a ? delete ab[c].data[a] : (d.handle && (d.events.$destroy && d.handle({}, \"$destroy\"), nc(b)), delete ab[c], b.ng339 = t)) } function oa(b, a, c) {\r\n        var d =\r\n        b.ng339, d = ab[d || -1]; if (z(c)) d || (b.ng339 = d = ++ne, d = ab[d] = {}), d[a] = c; else return d && d[a]\r\n    } function Mb(b, a, c) { var d = oa(b, \"data\"), e = z(c), f = !e && z(a), g = f && !T(a); d || g || oa(b, \"data\", d = {}); if (e) d[a] = c; else if (f) { if (g) return d && d[a]; J(d, a) } else return d } function Nb(b, a) { return b.getAttribute ? -1 < (\" \" + (b.getAttribute(\"class\") || \"\") + \" \").replace(/[\\n\\t]/g, \" \").indexOf(\" \" + a + \" \") : !1 } function nb(b, a) {\r\n        a && b.setAttribute && r(a.split(\" \"), function (a) {\r\n            b.setAttribute(\"class\", aa((\" \" + (b.getAttribute(\"class\") || \"\") + \" \").replace(/[\\n\\t]/g,\r\n            \" \").replace(\" \" + aa(a) + \" \", \" \")))\r\n        })\r\n    } function ob(b, a) { if (a && b.setAttribute) { var c = (\" \" + (b.getAttribute(\"class\") || \"\") + \" \").replace(/[\\n\\t]/g, \" \"); r(a.split(\" \"), function (a) { a = aa(a); -1 === c.indexOf(\" \" + a + \" \") && (c += a + \" \") }); b.setAttribute(\"class\", aa(c)) } } function Jb(b, a) { if (a) { a = a.nodeName || !z(a.length) || Ga(a) ? [a] : a; for (var c = 0; c < a.length; c++) b.push(a[c]) } } function oc(b, a) { return pb(b, \"$\" + (a || \"ngController\") + \"Controller\") } function pb(b, a, c) {\r\n        9 == b.nodeType && (b = b.documentElement); for (a = I(a) ? a : [a]; b;) {\r\n            for (var d =\r\n            0, e = a.length; d < e; d++) if ((c = v.data(b, a[d])) !== t) return c; b = b.parentNode || 11 === b.nodeType && b.host\r\n        }\r\n    } function pc(b) { for (var a = 0, c = b.childNodes; a < c.length; a++) Ja(c[a]); for (; b.firstChild;) b.removeChild(b.firstChild) } function qc(b, a) { var c = qb[a.toLowerCase()]; return c && rc[b.nodeName] && c } function oe(b, a) {\r\n        var c = function (c, e) {\r\n            c.preventDefault || (c.preventDefault = function () { c.returnValue = !1 }); c.stopPropagation || (c.stopPropagation = function () { c.cancelBubble = !0 }); c.target || (c.target = c.srcElement || X); if (y(c.defaultPrevented)) {\r\n                var f =\r\n                c.preventDefault; c.preventDefault = function () { c.defaultPrevented = !0; f.call(c) }; c.defaultPrevented = !1\r\n            } c.isDefaultPrevented = function () { return c.defaultPrevented || !1 === c.returnValue }; var g = ha(a[e || c.type] || []); r(g, function (a) { a.call(b, c) }); 8 >= Q ? (c.preventDefault = null, c.stopPropagation = null, c.isDefaultPrevented = null) : (delete c.preventDefault, delete c.stopPropagation, delete c.isDefaultPrevented)\r\n        }; c.elem = b; return c\r\n    } function Ka(b, a) {\r\n        var c = typeof b, d; \"function\" == c || \"object\" == c && null !== b ? \"function\" == typeof (d =\r\n        b.$$hashKey) ? d = b.$$hashKey() : d === t && (d = b.$$hashKey = (a || hb)()) : d = b; return c + \":\" + d\r\n    } function bb(b, a) { if (a) { var c = 0; this.nextUid = function () { return ++c } } r(b, this.put, this) } function sc(b) { var a, c; \"function\" === typeof b ? (a = b.$inject) || (a = [], b.length && (c = b.toString().replace(pe, \"\"), c = c.match(qe), r(c[1].split(re), function (b) { b.replace(se, function (b, c, d) { a.push(d) }) })), b.$inject = a) : I(b) ? (c = b.length - 1, Wa(b[c], \"fn\"), a = b.slice(0, c)) : Wa(b, \"fn\", !0); return a } function gc(b) {\r\n        function a(a) {\r\n            return function (b, c) {\r\n                if (T(b)) r(b,\r\n                $b(a)); else return a(b, c)\r\n            }\r\n        } function c(a, b) { Da(a, \"service\"); if (P(b) || I(b)) b = n.instantiate(b); if (!b.$get) throw cb(\"pget\", a); return l[a + k] = b } function d(a, b) { return c(a, { $get: b }) } function e(a) {\r\n            var b = [], c, d, f, k; r(a, function (a) {\r\n                if (!h.get(a)) {\r\n                    h.put(a, !0); try { if (A(a)) for (c = Ya(a), b = b.concat(e(c.requires)).concat(c._runBlocks), d = c._invokeQueue, f = 0, k = d.length; f < k; f++) { var g = d[f], m = n.get(g[0]); m[g[1]].apply(m, g[2]) } else P(a) ? b.push(n.invoke(a)) : I(a) ? b.push(n.invoke(a)) : Wa(a, \"module\") } catch (l) {\r\n                        throw I(a) && (a =\r\n                        a[a.length - 1]), l.message && (l.stack && -1 == l.stack.indexOf(l.message)) && (l = l.message + \"\\n\" + l.stack), cb(\"modulerr\", a, l.stack || l.message || l);\r\n                    }\r\n                }\r\n            }); return b\r\n        } function f(a, b) {\r\n            function c(d) { if (a.hasOwnProperty(d)) { if (a[d] === g) throw cb(\"cdep\", d + \" <- \" + m.join(\" <- \")); return a[d] } try { return m.unshift(d), a[d] = g, a[d] = b(d) } catch (e) { throw a[d] === g && delete a[d], e; } finally { m.shift() } } function d(a, b, e) {\r\n                var f = [], k = sc(a), g, m, h; m = 0; for (g = k.length; m < g; m++) {\r\n                    h = k[m]; if (\"string\" !== typeof h) throw cb(\"itkn\", h); f.push(e && e.hasOwnProperty(h) ?\r\n                    e[h] : c(h))\r\n                } I(a) && (a = a[g]); return a.apply(b, f)\r\n            } return { invoke: d, instantiate: function (a, b) { var c = function () { }, e; c.prototype = (I(a) ? a[a.length - 1] : a).prototype; c = new c; e = d(a, c, b); return T(e) || P(e) ? e : c }, get: c, annotate: sc, has: function (b) { return l.hasOwnProperty(b + k) || a.hasOwnProperty(b) } }\r\n        } var g = {}, k = \"Provider\", m = [], h = new bb([], !0), l = {\r\n            $provide: {\r\n                provider: a(c), factory: a(d), service: a(function (a, b) { return d(a, [\"$injector\", function (a) { return a.instantiate(b) }]) }), value: a(function (a, b) { return d(a, ba(b)) }), constant: a(function (a,\r\n                b) { Da(a, \"constant\"); l[a] = b; p[a] = b }), decorator: function (a, b) { var c = n.get(a + k), d = c.$get; c.$get = function () { var a = q.invoke(d, c); return q.invoke(b, null, { $delegate: a }) } }\r\n            }\r\n        }, n = l.$injector = f(l, function () { throw cb(\"unpr\", m.join(\" <- \")); }), p = {}, q = p.$injector = f(p, function (a) { a = n.get(a + k); return q.invoke(a.$get, a) }); r(e(b), function (a) { q.invoke(a || F) }); return q\r\n    } function Ld() {\r\n        var b = !0; this.disableAutoScrolling = function () { b = !1 }; this.$get = [\"$window\", \"$location\", \"$rootScope\", function (a, c, d) {\r\n            function e(a) {\r\n                var b = null;\r\n                r(a, function (a) { b || \"a\" !== M(a.nodeName) || (b = a) }); return b\r\n            } function f() { var b = c.hash(), d; b ? (d = g.getElementById(b)) ? d.scrollIntoView() : (d = e(g.getElementsByName(b))) ? d.scrollIntoView() : \"top\" === b && a.scrollTo(0, 0) : a.scrollTo(0, 0) } var g = a.document; b && d.$watch(function () { return c.hash() }, function () { d.$evalAsync(f) }); return f\r\n        }]\r\n    } function he() { this.$get = [\"$$rAF\", \"$timeout\", function (b, a) { return b.supported ? function (a) { return b(a) } : function (b) { return a(b, 0, !1) } }] } function te(b, a, c, d) {\r\n        function e(a) {\r\n            try {\r\n                a.apply(null,\r\n                Ba.call(arguments, 1))\r\n            } finally { if (s--, 0 === s) for (; E.length;) try { E.pop()() } catch (b) { c.error(b) } }\r\n        } function f(a, b) { (function fa() { r(u, function (a) { a() }); B = b(fa, a) })() } function g() { w = null; N != k.url() && (N = k.url(), r(ca, function (a) { a(k.url()) })) } var k = this, m = a[0], h = b.location, l = b.history, n = b.setTimeout, p = b.clearTimeout, q = {}; k.isMock = !1; var s = 0, E = []; k.$$completeOutstandingRequest = e; k.$$incOutstandingRequestCount = function () { s++ }; k.notifyWhenNoOutstandingRequests = function (a) { r(u, function (a) { a() }); 0 === s ? a() : E.push(a) };\r\n        var u = [], B; k.addPollFn = function (a) { y(B) && f(100, n); u.push(a); return a }; var N = h.href, R = a.find(\"base\"), w = null; k.url = function (a, c) { h !== b.location && (h = b.location); l !== b.history && (l = b.history); if (a) { if (N != a) return N = a, d.history ? c ? l.replaceState(null, \"\", a) : (l.pushState(null, \"\", a), R.attr(\"href\", R.attr(\"href\"))) : (w = a, c ? h.replace(a) : h.href = a), k } else return w || h.href.replace(/%27/g, \"'\") }; var ca = [], K = !1; k.onUrlChange = function (a) {\r\n            if (!K) {\r\n                if (d.history) v(b).on(\"popstate\", g); if (d.hashchange) v(b).on(\"hashchange\", g);\r\n                else k.addPollFn(g); K = !0\r\n            } ca.push(a); return a\r\n        }; k.$$checkUrlChange = g; k.baseHref = function () { var a = R.attr(\"href\"); return a ? a.replace(/^(https?\\:)?\\/\\/[^\\/]*/, \"\") : \"\" }; var O = {}, da = \"\", C = k.baseHref(); k.cookies = function (a, b) {\r\n            var d, e, f, k; if (a) b === t ? m.cookie = escape(a) + \"=;path=\" + C + \";expires=Thu, 01 Jan 1970 00:00:00 GMT\" : A(b) && (d = (m.cookie = escape(a) + \"=\" + escape(b) + \";path=\" + C).length + 1, 4096 < d && c.warn(\"Cookie '\" + a + \"' possibly not set or overflowed because it was too large (\" + d + \" > 4096 bytes)!\")); else {\r\n                if (m.cookie !==\r\n                da) for (da = m.cookie, d = da.split(\"; \"), O = {}, f = 0; f < d.length; f++) e = d[f], k = e.indexOf(\"=\"), 0 < k && (a = unescape(e.substring(0, k)), O[a] === t && (O[a] = unescape(e.substring(k + 1)))); return O\r\n            }\r\n        }; k.defer = function (a, b) { var c; s++; c = n(function () { delete q[c]; e(a) }, b || 0); q[c] = !0; return c }; k.defer.cancel = function (a) { return q[a] ? (delete q[a], p(a), e(F), !0) : !1 }\r\n    } function Nd() { this.$get = [\"$window\", \"$log\", \"$sniffer\", \"$document\", function (b, a, c, d) { return new te(b, d, a, c) }] } function Od() {\r\n        this.$get = function () {\r\n            function b(b, d) {\r\n                function e(a) {\r\n                    a !=\r\n                    n && (p ? p == a && (p = a.n) : p = a, f(a.n, a.p), f(a, n), n = a, n.n = null)\r\n                } function f(a, b) { a != b && (a && (a.p = b), b && (b.n = a)) } if (b in a) throw D(\"$cacheFactory\")(\"iid\", b); var g = 0, k = J({}, d, { id: b }), m = {}, h = d && d.capacity || Number.MAX_VALUE, l = {}, n = null, p = null; return a[b] = {\r\n                    put: function (a, b) { if (h < Number.MAX_VALUE) { var c = l[a] || (l[a] = { key: a }); e(c) } if (!y(b)) return a in m || g++, m[a] = b, g > h && this.remove(p.key), b }, get: function (a) { if (h < Number.MAX_VALUE) { var b = l[a]; if (!b) return; e(b) } return m[a] }, remove: function (a) {\r\n                        if (h < Number.MAX_VALUE) {\r\n                            var b =\r\n                            l[a]; if (!b) return; b == n && (n = b.p); b == p && (p = b.n); f(b.n, b.p); delete l[a]\r\n                        } delete m[a]; g--\r\n                    }, removeAll: function () { m = {}; g = 0; l = {}; n = p = null }, destroy: function () { l = k = m = null; delete a[b] }, info: function () { return J({}, k, { size: g }) }\r\n                }\r\n            } var a = {}; b.info = function () { var b = {}; r(a, function (a, e) { b[e] = a.info() }); return b }; b.get = function (b) { return a[b] }; return b\r\n        }\r\n    } function de() { this.$get = [\"$cacheFactory\", function (b) { return b(\"templates\") }] } function ic(b, a) {\r\n        var c = {}, d = \"Directive\", e = /^\\s*directive\\:\\s*([\\d\\w_\\-]+)\\s+(.*)$/, f = /(([\\d\\w_\\-]+)(?:\\:([^;]+))?;?)/,\r\n        g = /^(on[a-z]+|formaction)$/; this.directive = function m(a, e) {\r\n            Da(a, \"directive\"); A(a) ? (Db(e, \"directiveFactory\"), c.hasOwnProperty(a) || (c[a] = [], b.factory(a + d, [\"$injector\", \"$exceptionHandler\", function (b, d) { var e = []; r(c[a], function (c, f) { try { var g = b.invoke(c); P(g) ? g = { compile: ba(g) } : !g.compile && g.link && (g.compile = ba(g.link)); g.priority = g.priority || 0; g.index = f; g.name = g.name || a; g.require = g.require || g.controller && g.name; g.restrict = g.restrict || \"A\"; e.push(g) } catch (m) { d(m) } }); return e }])), c[a].push(e)) : r(a, $b(m));\r\n            return this\r\n        }; this.aHrefSanitizationWhitelist = function (b) { return z(b) ? (a.aHrefSanitizationWhitelist(b), this) : a.aHrefSanitizationWhitelist() }; this.imgSrcSanitizationWhitelist = function (b) { return z(b) ? (a.imgSrcSanitizationWhitelist(b), this) : a.imgSrcSanitizationWhitelist() }; this.$get = [\"$injector\", \"$interpolate\", \"$exceptionHandler\", \"$http\", \"$templateCache\", \"$parse\", \"$controller\", \"$rootScope\", \"$document\", \"$sce\", \"$animate\", \"$$sanitizeUri\", function (a, b, l, n, p, q, s, E, u, B, N, R) {\r\n            function w(a, b, c, d, e) {\r\n                a instanceof\r\n                v || (a = v(a)); r(a, function (b, c) { 3 == b.nodeType && b.nodeValue.match(/\\S+/) && (a[c] = v(b).wrap(\"<span></span>\").parent()[0]) }); var f = K(a, b, a, c, d, e); ca(a, \"ng-scope\"); return function (b, c, d, e) { Db(b, \"scope\"); var g = c ? La.clone.call(a) : a; r(d, function (a, b) { g.data(\"$\" + b + \"Controller\", a) }); d = 0; for (var m = g.length; d < m; d++) { var h = g[d].nodeType; 1 !== h && 9 !== h || g.eq(d).data(\"$scope\", b) } c && c(g, b); f && f(b, g, g, e); return g }\r\n            } function ca(a, b) { try { a.addClass(b) } catch (c) { } } function K(a, b, c, d, e, f) {\r\n                function g(a, c, d, e) {\r\n                    var f, h, l, q, n,\r\n                    p, s; f = c.length; var L = Array(f); for (q = 0; q < f; q++) L[q] = c[q]; p = q = 0; for (n = m.length; q < n; p++) h = L[p], c = m[q++], f = m[q++], c ? (c.scope ? (l = a.$new(), v.data(h, \"$scope\", l)) : l = a, s = c.transcludeOnThisElement ? O(a, c.transclude, e) : !c.templateOnThisElement && e ? e : !e && b ? O(a, b) : null, c(f, l, h, d, s)) : f && f(a, h.childNodes, t, e)\r\n                } for (var m = [], h, l, q, n, p = 0; p < a.length; p++) h = new Ob, l = da(a[p], [], h, 0 === p ? d : t, e), (f = l.length ? H(l, a[p], h, b, c, null, [], [], f) : null) && f.scope && ca(h.$$element, \"ng-scope\"), h = f && f.terminal || !(q = a[p].childNodes) || !q.length ?\r\n                null : K(q, f ? (f.transcludeOnThisElement || !f.templateOnThisElement) && f.transclude : b), m.push(f, h), n = n || f || h, f = null; return n ? g : null\r\n            } function O(a, b, c) { return function (d, e, f) { var g = !1; d || (d = a.$new(), g = d.$$transcluded = !0); e = b(d, e, f, c); if (g) e.on(\"$destroy\", function () { d.$destroy() }); return e } } function da(a, b, c, d, g) {\r\n                var m = c.$attr, h; switch (a.nodeType) {\r\n                    case 1: fa(b, pa(Ma(a).toLowerCase()), \"E\", d, g); for (var l, q, n, p = a.attributes, s = 0, E = p && p.length; s < E; s++) {\r\n                        var B = !1, N = !1; l = p[s]; if (!Q || 8 <= Q || l.specified) {\r\n                            h = l.name; q =\r\n                            aa(l.value); l = pa(h); if (n = U.test(l)) h = mb(l.substr(6), \"-\"); var u = l.replace(/(Start|End)$/, \"\"); l === u + \"Start\" && (B = h, N = h.substr(0, h.length - 5) + \"end\", h = h.substr(0, h.length - 6)); l = pa(h.toLowerCase()); m[l] = h; if (n || !c.hasOwnProperty(l)) c[l] = q, qc(a, l) && (c[l] = !0); S(a, b, q, l); fa(b, l, \"A\", d, g, B, N)\r\n                        }\r\n                    } a = a.className; if (A(a) && \"\" !== a) for (; h = f.exec(a) ;) l = pa(h[2]), fa(b, l, \"C\", d, g) && (c[l] = aa(h[3])), a = a.substr(h.index + h[0].length); break; case 3: M(b, a.nodeValue); break; case 8: try {\r\n                        if (h = e.exec(a.nodeValue)) l = pa(h[1]), fa(b, l, \"M\",\r\n                        d, g) && (c[l] = aa(h[2]))\r\n                    } catch (w) { }\r\n                } b.sort(y); return b\r\n            } function C(a, b, c) { var d = [], e = 0; if (b && a.hasAttribute && a.hasAttribute(b)) { do { if (!a) throw ja(\"uterdir\", b, c); 1 == a.nodeType && (a.hasAttribute(b) && e++, a.hasAttribute(c) && e--); d.push(a); a = a.nextSibling } while (0 < e) } else d.push(a); return v(d) } function x(a, b, c) { return function (d, e, f, g, h) { e = C(e[0], b, c); return a(d, e, f, g, h) } } function H(a, c, d, e, f, g, m, n, p) {\r\n                function E(a, b, c, d) {\r\n                    if (a) {\r\n                        c && (a = x(a, c, d)); a.require = G.require; a.directiveName = D; if (K === G || G.$$isolateScope) a =\r\n                        tc(a, { isolateScope: !0 }); m.push(a)\r\n                    } if (b) { c && (b = x(b, c, d)); b.require = G.require; b.directiveName = D; if (K === G || G.$$isolateScope) b = tc(b, { isolateScope: !0 }); n.push(b) }\r\n                } function B(a, b, c, d) { var e, f = \"data\", g = !1; if (A(b)) { for (; \"^\" == (e = b.charAt(0)) || \"?\" == e;) b = b.substr(1), \"^\" == e && (f = \"inheritedData\"), g = g || \"?\" == e; e = null; d && \"data\" === f && (e = d[b]); e = e || c[f](\"$\" + b + \"Controller\"); if (!e && !g) throw ja(\"ctreq\", b, a); } else I(b) && (e = [], r(b, function (b) { e.push(B(a, b, c, d)) })); return e } function N(a, e, f, g, p) {\r\n                    function E(a, b) {\r\n                        var c; 2 > arguments.length &&\r\n                        (b = a, a = t); M && (c = da); return p(a, b, c)\r\n                    } var u, L, w, O, x, C, da = {}, rb; u = c === f ? d : ha(d, new Ob(v(f), d.$attr)); L = u.$$element; if (K) {\r\n                        var Na = /^\\s*([@=&])(\\??)\\s*(\\w*)\\s*$/; C = e.$new(!0); !H || H !== K && H !== K.$$originalDirective ? L.data(\"$isolateScopeNoTemplate\", C) : L.data(\"$isolateScope\", C); ca(L, \"ng-isolate-scope\"); r(K.scope, function (a, c) {\r\n                            var d = a.match(Na) || [], f = d[3] || c, g = \"?\" == d[2], d = d[1], m, l, n, p; C.$$isolateBindings[c] = d + f; switch (d) {\r\n                                case \"@\": u.$observe(f, function (a) { C[c] = a }); u.$$observers[f].$$scope = e; u[f] && (C[c] = b(u[f])(e));\r\n                                    break; case \"=\": if (g && !u[f]) break; l = q(u[f]); p = l.literal ? Aa : function (a, b) { return a === b || a !== a && b !== b }; n = l.assign || function () { m = C[c] = l(e); throw ja(\"nonassign\", u[f], K.name); }; m = C[c] = l(e); C.$watch(function () { var a = l(e); p(a, C[c]) || (p(a, m) ? n(e, a = C[c]) : C[c] = a); return m = a }, null, l.literal); break; case \"&\": l = q(u[f]); C[c] = function (a) { return l(e, a) }; break; default: throw ja(\"iscp\", K.name, c, a);\r\n                            }\r\n                        })\r\n                    } rb = p && E; R && r(R, function (a) {\r\n                        var b = { $scope: a === K || a.$$isolateScope ? C : e, $element: L, $attrs: u, $transclude: rb }, c; x = a.controller;\r\n                        \"@\" == x && (x = u[a.name]); c = s(x, b); da[a.name] = c; M || L.data(\"$\" + a.name + \"Controller\", c); a.controllerAs && (b.$scope[a.controllerAs] = c)\r\n                    }); g = 0; for (w = m.length; g < w; g++) try { O = m[g], O(O.isolateScope ? C : e, L, u, O.require && B(O.directiveName, O.require, L, da), rb) } catch (G) { l(G, ia(L)) } g = e; K && (K.template || null === K.templateUrl) && (g = C); a && a(g, f.childNodes, t, p); for (g = n.length - 1; 0 <= g; g--) try { O = n[g], O(O.isolateScope ? C : e, L, u, O.require && B(O.directiveName, O.require, L, da), rb) } catch (z) { l(z, ia(L)) }\r\n                } p = p || {}; for (var u = -Number.MAX_VALUE,\r\n                O, R = p.controllerDirectives, K = p.newIsolateScopeDirective, H = p.templateDirective, fa = p.nonTlbTranscludeDirective, y = !1, J = !1, M = p.hasElementTranscludeDirective, Z = d.$$element = v(c), G, D, V, S = e, Q, Fa = 0, qa = a.length; Fa < qa; Fa++) {\r\n                    G = a[Fa]; var U = G.$$start, Y = G.$$end; U && (Z = C(c, U, Y)); V = t; if (u > G.priority) break; if (V = G.scope) O = O || G, G.templateUrl || (db(\"new/isolated scope\", K, G, Z), T(V) && (K = G)); D = G.name; !G.templateUrl && G.controller && (V = G.controller, R = R || {}, db(\"'\" + D + \"' controller\", R[D], G, Z), R[D] = G); if (V = G.transclude) y = !0, G.$$tlb ||\r\n                    (db(\"transclusion\", fa, G, Z), fa = G), \"element\" == V ? (M = !0, u = G.priority, V = Z, Z = d.$$element = v(X.createComment(\" \" + D + \": \" + d[D] + \" \")), c = Z[0], Na(f, Ba.call(V, 0), c), S = w(V, e, u, g && g.name, { nonTlbTranscludeDirective: fa })) : (V = v(Kb(c)).contents(), Z.empty(), S = w(V, e)); if (G.template) if (J = !0, db(\"template\", H, G, Z), H = G, V = P(G.template) ? G.template(Z, d) : G.template, V = W(V), G.replace) {\r\n                        g = G; V = Ib.test(V) ? v(aa(V)) : []; c = V[0]; if (1 != V.length || 1 !== c.nodeType) throw ja(\"tplrt\", D, \"\"); Na(f, Z, c); qa = { $attr: {} }; V = da(c, [], qa); var $ = a.splice(Fa +\r\n                        1, a.length - (Fa + 1)); K && z(V); a = a.concat(V).concat($); F(d, qa); qa = a.length\r\n                    } else Z.html(V); if (G.templateUrl) J = !0, db(\"template\", H, G, Z), H = G, G.replace && (g = G), N = ue(a.splice(Fa, a.length - Fa), Z, d, f, y && S, m, n, { controllerDirectives: R, newIsolateScopeDirective: K, templateDirective: H, nonTlbTranscludeDirective: fa }), qa = a.length; else if (G.compile) try { Q = G.compile(Z, d, S), P(Q) ? E(null, Q, U, Y) : Q && E(Q.pre, Q.post, U, Y) } catch (ve) { l(ve, ia(Z)) } G.terminal && (N.terminal = !0, u = Math.max(u, G.priority))\r\n                } N.scope = O && !0 === O.scope; N.transcludeOnThisElement =\r\n                y; N.templateOnThisElement = J; N.transclude = S; p.hasElementTranscludeDirective = M; return N\r\n            } function z(a) { for (var b = 0, c = a.length; b < c; b++) a[b] = bc(a[b], { $$isolateScope: !0 }) } function fa(b, e, f, g, h, q, n) { if (e === h) return null; h = null; if (c.hasOwnProperty(e)) { var p; e = a.get(e + d); for (var s = 0, u = e.length; s < u; s++) try { p = e[s], (g === t || g > p.priority) && -1 != p.restrict.indexOf(f) && (q && (p = bc(p, { $$start: q, $$end: n })), b.push(p), h = p) } catch (E) { l(E) } } return h } function F(a, b) {\r\n                var c = b.$attr, d = a.$attr, e = a.$$element; r(a, function (d, e) {\r\n                    \"$\" !=\r\n                    e.charAt(0) && (b[e] && b[e] !== d && (d += (\"style\" === e ? \";\" : \" \") + b[e]), a.$set(e, d, !0, c[e]))\r\n                }); r(b, function (b, f) { \"class\" == f ? (ca(e, b), a[\"class\"] = (a[\"class\"] ? a[\"class\"] + \" \" : \"\") + b) : \"style\" == f ? (e.attr(\"style\", e.attr(\"style\") + \";\" + b), a.style = (a.style ? a.style + \";\" : \"\") + b) : \"$\" == f.charAt(0) || a.hasOwnProperty(f) || (a[f] = b, d[f] = c[f]) })\r\n            } function ue(a, b, c, d, e, f, g, h) {\r\n                var m = [], l, q, s = b[0], u = a.shift(), E = J({}, u, { templateUrl: null, transclude: null, replace: null, $$originalDirective: u }), N = P(u.templateUrl) ? u.templateUrl(b, c) : u.templateUrl;\r\n                b.empty(); n.get(B.getTrustedResourceUrl(N), { cache: p }).success(function (n) {\r\n                    var p, B; n = W(n); if (u.replace) { n = Ib.test(n) ? v(aa(n)) : []; p = n[0]; if (1 != n.length || 1 !== p.nodeType) throw ja(\"tplrt\", u.name, N); n = { $attr: {} }; Na(d, b, p); var w = da(p, [], n); T(u.scope) && z(w); a = w.concat(a); F(c, n) } else p = s, b.html(n); a.unshift(E); l = H(a, p, c, e, b, u, f, g, h); r(d, function (a, c) { a == p && (d[c] = b[0]) }); for (q = K(b[0].childNodes, e) ; m.length;) {\r\n                        n = m.shift(); B = m.shift(); var R = m.shift(), x = m.shift(), w = b[0]; if (B !== s) {\r\n                            var C = B.className; h.hasElementTranscludeDirective &&\r\n                            u.replace || (w = Kb(p)); Na(R, v(B), w); ca(v(w), C)\r\n                        } B = l.transcludeOnThisElement ? O(n, l.transclude, x) : x; l(q, n, w, d, B)\r\n                    } m = null\r\n                }).error(function (a, b, c, d) { throw ja(\"tpload\", d.url); }); return function (a, b, c, d, e) { a = e; m ? (m.push(b), m.push(c), m.push(d), m.push(a)) : (l.transcludeOnThisElement && (a = O(b, l.transclude, e)), l(q, b, c, d, a)) }\r\n            } function y(a, b) { var c = b.priority - a.priority; return 0 !== c ? c : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index } function db(a, b, c, d) { if (b) throw ja(\"multidir\", b.name, c.name, a, ia(d)); } function M(a,\r\n            c) { var d = b(c, !0); d && a.push({ priority: 0, compile: function (a) { var b = a.parent().length; b && ca(a.parent(), \"ng-binding\"); return function (a, c) { var e = c.parent(), f = e.data(\"$binding\") || []; f.push(d); e.data(\"$binding\", f); b || ca(e, \"ng-binding\"); a.$watch(d, function (a) { c[0].nodeValue = a }) } } }) } function D(a, b) { if (\"srcdoc\" == b) return B.HTML; var c = Ma(a); if (\"xlinkHref\" == b || \"FORM\" == c && \"action\" == b || \"IMG\" != c && (\"src\" == b || \"ngSrc\" == b)) return B.RESOURCE_URL } function S(a, c, d, e) {\r\n                var f = b(d, !0); if (f) {\r\n                    if (\"multiple\" === e && \"SELECT\" ===\r\n                    Ma(a)) throw ja(\"selmulti\", ia(a)); c.push({ priority: 100, compile: function () { return { pre: function (c, d, m) { d = m.$$observers || (m.$$observers = {}); if (g.test(e)) throw ja(\"nodomevents\"); if (f = b(m[e], !0, D(a, e))) m[e] = f(c), (d[e] || (d[e] = [])).$$inter = !0, (m.$$observers && m.$$observers[e].$$scope || c).$watch(f, function (a, b) { \"class\" === e && a != b ? m.$updateClass(a, b) : m.$set(e, a) }) } } } })\r\n                }\r\n            } function Na(a, b, c) {\r\n                var d = b[0], e = b.length, f = d.parentNode, g, m; if (a) for (g = 0, m = a.length; g < m; g++) if (a[g] == d) {\r\n                    a[g++] = c; m = g + e - 1; for (var h = a.length; g <\r\n                    h; g++, m++) m < h ? a[g] = a[m] : delete a[g]; a.length -= e - 1; break\r\n                } f && f.replaceChild(c, d); a = X.createDocumentFragment(); a.appendChild(d); c[v.expando] = d[v.expando]; d = 1; for (e = b.length; d < e; d++) f = b[d], v(f).remove(), a.appendChild(f), delete b[d]; b[0] = c; b.length = 1\r\n            } function tc(a, b) { return J(function () { return a.apply(null, arguments) }, a, b) } var Ob = function (a, b) { this.$$element = a; this.$attr = b || {} }; Ob.prototype = {\r\n                $normalize: pa, $addClass: function (a) { a && 0 < a.length && N.addClass(this.$$element, a) }, $removeClass: function (a) {\r\n                    a && 0 <\r\n                    a.length && N.removeClass(this.$$element, a)\r\n                }, $updateClass: function (a, b) { var c = uc(a, b), d = uc(b, a); 0 === c.length ? N.removeClass(this.$$element, d) : 0 === d.length ? N.addClass(this.$$element, c) : N.setClass(this.$$element, c, d) }, $set: function (a, b, c, d) {\r\n                    var e = qc(this.$$element[0], a); e && (this.$$element.prop(a, b), d = e); this[a] = b; d ? this.$attr[a] = d : (d = this.$attr[a]) || (this.$attr[a] = d = mb(a, \"-\")); e = Ma(this.$$element); if (\"A\" === e && \"href\" === a || \"IMG\" === e && \"src\" === a) this[a] = b = R(b, \"src\" === a); !1 !== c && (null === b || b === t ? this.$$element.removeAttr(d) :\r\n                    this.$$element.attr(d, b)); (c = this.$$observers) && r(c[a], function (a) { try { a(b) } catch (c) { l(c) } })\r\n                }, $observe: function (a, b) { var c = this, d = c.$$observers || (c.$$observers = {}), e = d[a] || (d[a] = []); e.push(b); E.$evalAsync(function () { e.$$inter || b(c[a]) }); return b }\r\n            }; var qa = b.startSymbol(), Z = b.endSymbol(), W = \"{{\" == qa || \"}}\" == Z ? Qa : function (a) { return a.replace(/\\{\\{/g, qa).replace(/}}/g, Z) }, U = /^ngAttr[A-Z]/; return w\r\n        }]\r\n    } function pa(b) { return Za(b.replace(we, \"\")) } function uc(b, a) {\r\n        var c = \"\", d = b.split(/\\s+/), e = a.split(/\\s+/), f =\r\n        0; a: for (; f < d.length; f++) { for (var g = d[f], k = 0; k < e.length; k++) if (g == e[k]) continue a; c += (0 < c.length ? \" \" : \"\") + g } return c\r\n    } function Pd() {\r\n        var b = {}, a = /^(\\S+)(\\s+as\\s+(\\w+))?$/; this.register = function (a, d) { Da(a, \"controller\"); T(a) ? J(b, a) : b[a] = d }; this.$get = [\"$injector\", \"$window\", function (c, d) {\r\n            return function (e, f) {\r\n                var g, k, m; A(e) && (g = e.match(a), k = g[1], m = g[3], e = b.hasOwnProperty(k) ? b[k] : hc(f.$scope, k, !0) || hc(d, k, !0), Wa(e, k, !0)); g = c.instantiate(e, f); if (m) {\r\n                    if (!f || \"object\" !== typeof f.$scope) throw D(\"$controller\")(\"noscp\",\r\n                    k || e.name, m); f.$scope[m] = g\r\n                } return g\r\n            }\r\n        }]\r\n    } function Qd() { this.$get = [\"$window\", function (b) { return v(b.document) }] } function Rd() { this.$get = [\"$log\", function (b) { return function (a, c) { b.error.apply(b, arguments) } }] } function vc(b) { var a = {}, c, d, e; if (!b) return a; r(b.split(\"\\n\"), function (b) { e = b.indexOf(\":\"); c = M(aa(b.substr(0, e))); d = aa(b.substr(e + 1)); c && (a[c] = a[c] ? a[c] + \", \" + d : d) }); return a } function wc(b) { var a = T(b) ? b : t; return function (c) { a || (a = vc(b)); return c ? a[M(c)] || null : a } } function xc(b, a, c) {\r\n        if (P(c)) return c(b,\r\n        a); r(c, function (c) { b = c(b, a) }); return b\r\n    } function Ud() {\r\n        var b = /^\\s*(\\[|\\{[^\\{])/, a = /[\\}\\]]\\s*$/, c = /^\\)\\]\\}',?\\n/, d = { \"Content-Type\": \"application/json;charset=utf-8\" }, e = this.defaults = {\r\n            transformResponse: [function (d) { A(d) && (d = d.replace(c, \"\"), b.test(d) && a.test(d) && (d = cc(d))); return d }], transformRequest: [function (a) { return T(a) && \"[object File]\" !== za.call(a) && \"[object Blob]\" !== za.call(a) ? na(a) : a }], headers: { common: { Accept: \"application/json, text/plain, */*\" }, post: ha(d), put: ha(d), patch: ha(d) }, xsrfCookieName: \"XSRF-TOKEN\",\r\n            xsrfHeaderName: \"X-XSRF-TOKEN\"\r\n        }, f = this.interceptors = [], g = this.responseInterceptors = []; this.$get = [\"$httpBackend\", \"$browser\", \"$cacheFactory\", \"$rootScope\", \"$q\", \"$injector\", function (a, b, c, d, n, p) {\r\n            function q(a) {\r\n                function b(a) { var d = J({}, a, { data: xc(a.data, a.headers, c.transformResponse) }); return 200 <= a.status && 300 > a.status ? d : n.reject(d) } var c = { method: \"get\", transformRequest: e.transformRequest, transformResponse: e.transformResponse }, d = function (a) {\r\n                    var b = e.headers, c = J({}, a.headers), d, f, b = J({}, b.common, b[M(a.method)]);\r\n                    a: for (d in b) { a = M(d); for (f in c) if (M(f) === a) continue a; c[d] = b[d] } (function (a) { var b; r(a, function (c, d) { P(c) && (b = c(), null != b ? a[d] = b : delete a[d]) }) })(c); return c\r\n                }(a); J(c, a); c.headers = d; c.method = Ia(c.method); var f = [function (a) { d = a.headers; var c = xc(a.data, wc(d), a.transformRequest); y(c) && r(d, function (a, b) { \"content-type\" === M(b) && delete d[b] }); y(a.withCredentials) && !y(e.withCredentials) && (a.withCredentials = e.withCredentials); return s(a, c, d).then(b, b) }, t], g = n.when(c); for (r(B, function (a) {\r\n                (a.request || a.requestError) &&\r\n                f.unshift(a.request, a.requestError); (a.response || a.responseError) && f.push(a.response, a.responseError)\r\n                }) ; f.length;) { a = f.shift(); var m = f.shift(), g = g.then(a, m) } g.success = function (a) { g.then(function (b) { a(b.data, b.status, b.headers, c) }); return g }; g.error = function (a) { g.then(null, function (b) { a(b.data, b.status, b.headers, c) }); return g }; return g\r\n            } function s(c, f, g) {\r\n                function h(a, b, c, e) { x && (200 <= a && 300 > a ? x.put(v, [a, b, vc(c), e]) : x.remove(v)); p(b, a, c, e); d.$$phase || d.$apply() } function p(a, b, d, e) {\r\n                    b = Math.max(b, 0); (200 <=\r\n                    b && 300 > b ? B.resolve : B.reject)({ data: a, status: b, headers: wc(d), config: c, statusText: e })\r\n                } function s() { var a = Ra(q.pendingRequests, c); -1 !== a && q.pendingRequests.splice(a, 1) } var B = n.defer(), r = B.promise, x, H, v = E(c.url, c.params); q.pendingRequests.push(c); r.then(s, s); !c.cache && !e.cache || (!1 === c.cache || \"GET\" !== c.method && \"JSONP\" !== c.method) || (x = T(c.cache) ? c.cache : T(e.cache) ? e.cache : u); if (x) if (H = x.get(v), z(H)) { if (H && P(H.then)) return H.then(s, s), H; I(H) ? p(H[1], H[0], ha(H[2]), H[3]) : p(H, 200, {}, \"OK\") } else x.put(v, r); y(H) &&\r\n                ((H = Pb(c.url) ? b.cookies()[c.xsrfCookieName || e.xsrfCookieName] : t) && (g[c.xsrfHeaderName || e.xsrfHeaderName] = H), a(c.method, v, f, h, g, c.timeout, c.withCredentials, c.responseType)); return r\r\n            } function E(a, b) { if (!b) return a; var c = []; Tc(b, function (a, b) { null === a || y(a) || (I(a) || (a = [a]), r(a, function (a) { T(a) && (a = ta(a) ? a.toISOString() : na(a)); c.push(Ca(b) + \"=\" + Ca(a)) })) }); 0 < c.length && (a += (-1 == a.indexOf(\"?\") ? \"?\" : \"&\") + c.join(\"&\")); return a } var u = c(\"$http\"), B = []; r(f, function (a) { B.unshift(A(a) ? p.get(a) : p.invoke(a)) }); r(g,\r\n            function (a, b) { var c = A(a) ? p.get(a) : p.invoke(a); B.splice(b, 0, { response: function (a) { return c(n.when(a)) }, responseError: function (a) { return c(n.reject(a)) } }) }); q.pendingRequests = []; (function (a) { r(arguments, function (a) { q[a] = function (b, c) { return q(J(c || {}, { method: a, url: b })) } }) })(\"get\", \"delete\", \"head\", \"jsonp\"); (function (a) { r(arguments, function (a) { q[a] = function (b, c, d) { return q(J(d || {}, { method: a, url: b, data: c })) } }) })(\"post\", \"put\"); q.defaults = e; return q\r\n        }]\r\n    } function xe(b) {\r\n        if (8 >= Q && (!b.match(/^(get|post|head|put|delete|options)$/i) ||\r\n        !W.XMLHttpRequest)) return new W.ActiveXObject(\"Microsoft.XMLHTTP\"); if (W.XMLHttpRequest) return new W.XMLHttpRequest; throw D(\"$httpBackend\")(\"noxhr\");\r\n    } function Vd() { this.$get = [\"$browser\", \"$window\", \"$document\", function (b, a, c) { return ye(b, xe, b.defer, a.angular.callbacks, c[0]) }] } function ye(b, a, c, d, e) {\r\n        function f(a, b, c) {\r\n            var f = e.createElement(\"script\"), g = null; f.type = \"text/javascript\"; f.src = a; f.async = !0; g = function (a) {\r\n                $a(f, \"load\", g); $a(f, \"error\", g); e.body.removeChild(f); f = null; var k = -1, s = \"unknown\"; a && (\"load\" !==\r\n                a.type || d[b].called || (a = { type: \"error\" }), s = a.type, k = \"error\" === a.type ? 404 : 200); c && c(k, s)\r\n            }; sb(f, \"load\", g); sb(f, \"error\", g); 8 >= Q && (f.onreadystatechange = function () { A(f.readyState) && /loaded|complete/.test(f.readyState) && (f.onreadystatechange = null, g({ type: \"load\" })) }); e.body.appendChild(f); return g\r\n        } var g = -1; return function (e, m, h, l, n, p, q, s) {\r\n            function E() { B = g; R && R(); w && w.abort() } function u(a, d, e, f, g) { K && c.cancel(K); R = w = null; 0 === d && (d = e ? 200 : \"file\" == ua(m).protocol ? 404 : 0); a(1223 === d ? 204 : d, e, f, g || \"\"); b.$$completeOutstandingRequest(F) }\r\n            var B; b.$$incOutstandingRequestCount(); m = m || b.url(); if (\"jsonp\" == M(e)) { var N = \"_\" + (d.counter++).toString(36); d[N] = function (a) { d[N].data = a; d[N].called = !0 }; var R = f(m.replace(\"JSON_CALLBACK\", \"angular.callbacks.\" + N), N, function (a, b) { u(l, a, d[N].data, \"\", b); d[N] = F }) } else {\r\n                var w = a(e); w.open(e, m, !0); r(n, function (a, b) { z(a) && w.setRequestHeader(b, a) }); w.onreadystatechange = function () {\r\n                    if (w && 4 == w.readyState) {\r\n                        var a = null, b = null, c = \"\"; B !== g && (a = w.getAllResponseHeaders(), b = \"response\" in w ? w.response : w.responseText); B === g &&\r\n                        10 > Q || (c = w.statusText); u(l, B || w.status, b, a, c)\r\n                    }\r\n                }; q && (w.withCredentials = !0); if (s) try { w.responseType = s } catch (ca) { if (\"json\" !== s) throw ca; } w.send(h || null)\r\n            } if (0 < p) var K = c(E, p); else p && P(p.then) && p.then(E)\r\n        }\r\n    } function Sd() {\r\n        var b = \"{{\", a = \"}}\"; this.startSymbol = function (a) { return a ? (b = a, this) : b }; this.endSymbol = function (b) { return b ? (a = b, this) : a }; this.$get = [\"$parse\", \"$exceptionHandler\", \"$sce\", function (c, d, e) {\r\n            function f(f, h, l) {\r\n                for (var n, p, q = 0, s = [], E = f.length, u = !1, B = []; q < E;) -1 != (n = f.indexOf(b, q)) && -1 != (p = f.indexOf(a,\r\n                n + g)) ? (q != n && s.push(f.substring(q, n)), s.push(q = c(u = f.substring(n + g, p))), q.exp = u, q = p + k, u = !0) : (q != E && s.push(f.substring(q)), q = E); (E = s.length) || (s.push(\"\"), E = 1); if (l && 1 < s.length) throw yc(\"noconcat\", f); if (!h || u) return B.length = E, q = function (a) {\r\n                    try { for (var b = 0, c = E, g; b < c; b++) { if (\"function\" == typeof (g = s[b])) if (g = g(a), g = l ? e.getTrusted(l, g) : e.valueOf(g), null == g) g = \"\"; else switch (typeof g) { case \"string\": break; case \"number\": g = \"\" + g; break; default: g = na(g) } B[b] = g } return B.join(\"\") } catch (k) {\r\n                        a = yc(\"interr\", f, k.toString()),\r\n                        d(a)\r\n                    }\r\n                }, q.exp = f, q.parts = s, q\r\n            } var g = b.length, k = a.length; f.startSymbol = function () { return b }; f.endSymbol = function () { return a }; return f\r\n        }]\r\n    } function Td() {\r\n        this.$get = [\"$rootScope\", \"$window\", \"$q\", function (b, a, c) {\r\n            function d(d, g, k, m) { var h = a.setInterval, l = a.clearInterval, n = c.defer(), p = n.promise, q = 0, s = z(m) && !m; k = z(k) ? k : 0; p.then(null, null, d); p.$$intervalId = h(function () { n.notify(q++); 0 < k && q >= k && (n.resolve(q), l(p.$$intervalId), delete e[p.$$intervalId]); s || b.$apply() }, g); e[p.$$intervalId] = n; return p } var e = {}; d.cancel =\r\n            function (b) { return b && b.$$intervalId in e ? (e[b.$$intervalId].reject(\"canceled\"), a.clearInterval(b.$$intervalId), delete e[b.$$intervalId], !0) : !1 }; return d\r\n        }]\r\n    } function bd() {\r\n        this.$get = function () {\r\n            return {\r\n                id: \"en-us\", NUMBER_FORMATS: { DECIMAL_SEP: \".\", GROUP_SEP: \",\", PATTERNS: [{ minInt: 1, minFrac: 0, maxFrac: 3, posPre: \"\", posSuf: \"\", negPre: \"-\", negSuf: \"\", gSize: 3, lgSize: 3 }, { minInt: 1, minFrac: 2, maxFrac: 2, posPre: \"\\u00a4\", posSuf: \"\", negPre: \"(\\u00a4\", negSuf: \")\", gSize: 3, lgSize: 3 }], CURRENCY_SYM: \"$\" }, DATETIME_FORMATS: {\r\n                    MONTH: \"January February March April May June July August September October November December\".split(\" \"),\r\n                    SHORTMONTH: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"), DAY: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), SHORTDAY: \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"), AMPMS: [\"AM\", \"PM\"], medium: \"MMM d, y h:mm:ss a\", \"short\": \"M/d/yy h:mm a\", fullDate: \"EEEE, MMMM d, y\", longDate: \"MMMM d, y\", mediumDate: \"MMM d, y\", shortDate: \"M/d/yy\", mediumTime: \"h:mm:ss a\", shortTime: \"h:mm a\"\r\n                }, pluralCat: function (b) { return 1 === b ? \"one\" : \"other\" }\r\n            }\r\n        }\r\n    } function Qb(b) {\r\n        b = b.split(\"/\"); for (var a = b.length; a--;) b[a] =\r\n        lb(b[a]); return b.join(\"/\")\r\n    } function zc(b, a, c) { b = ua(b, c); a.$$protocol = b.protocol; a.$$host = b.hostname; a.$$port = U(b.port) || ze[b.protocol] || null } function Ac(b, a, c) { var d = \"/\" !== b.charAt(0); d && (b = \"/\" + b); b = ua(b, c); a.$$path = decodeURIComponent(d && \"/\" === b.pathname.charAt(0) ? b.pathname.substring(1) : b.pathname); a.$$search = ec(b.search); a.$$hash = decodeURIComponent(b.hash); a.$$path && \"/\" != a.$$path.charAt(0) && (a.$$path = \"/\" + a.$$path) } function ra(b, a) { if (0 === a.indexOf(b)) return a.substr(b.length) } function eb(b) {\r\n        var a =\r\n        b.indexOf(\"#\"); return -1 == a ? b : b.substr(0, a)\r\n    } function Rb(b) { return b.substr(0, eb(b).lastIndexOf(\"/\") + 1) } function Bc(b, a) {\r\n        this.$$html5 = !0; a = a || \"\"; var c = Rb(b); zc(b, this, b); this.$$parse = function (a) { var e = ra(c, a); if (!A(e)) throw Sb(\"ipthprfx\", a, c); Ac(e, this, b); this.$$path || (this.$$path = \"/\"); this.$$compose() }; this.$$compose = function () { var a = Cb(this.$$search), b = this.$$hash ? \"#\" + lb(this.$$hash) : \"\"; this.$$url = Qb(this.$$path) + (a ? \"?\" + a : \"\") + b; this.$$absUrl = c + this.$$url.substr(1) }; this.$$rewrite = function (d) {\r\n            var e;\r\n            if ((e = ra(b, d)) !== t) return d = e, (e = ra(a, e)) !== t ? c + (ra(\"/\", e) || e) : b + d; if ((e = ra(c, d)) !== t) return c + e; if (c == d + \"/\") return c\r\n        }\r\n    } function Tb(b, a) {\r\n        var c = Rb(b); zc(b, this, b); this.$$parse = function (d) { var e = ra(b, d) || ra(c, d), e = \"#\" == e.charAt(0) ? ra(a, e) : this.$$html5 ? e : \"\"; if (!A(e)) throw Sb(\"ihshprfx\", d, a); Ac(e, this, b); d = this.$$path; var f = /^\\/[A-Z]:(\\/.*)/; 0 === e.indexOf(b) && (e = e.replace(b, \"\")); f.exec(e) || (d = (e = f.exec(d)) ? e[1] : d); this.$$path = d; this.$$compose() }; this.$$compose = function () {\r\n            var c = Cb(this.$$search), e = this.$$hash ?\r\n            \"#\" + lb(this.$$hash) : \"\"; this.$$url = Qb(this.$$path) + (c ? \"?\" + c : \"\") + e; this.$$absUrl = b + (this.$$url ? a + this.$$url : \"\")\r\n        }; this.$$rewrite = function (a) { if (eb(b) == eb(a)) return a }\r\n    } function Ub(b, a) { this.$$html5 = !0; Tb.apply(this, arguments); var c = Rb(b); this.$$rewrite = function (d) { var e; if (b == eb(d)) return d; if (e = ra(c, d)) return b + a + e; if (c === d + \"/\") return c }; this.$$compose = function () { var c = Cb(this.$$search), e = this.$$hash ? \"#\" + lb(this.$$hash) : \"\"; this.$$url = Qb(this.$$path) + (c ? \"?\" + c : \"\") + e; this.$$absUrl = b + a + this.$$url } } function tb(b) { return function () { return this[b] } }\r\n    function Cc(b, a) { return function (c) { if (y(c)) return this[b]; this[b] = a(c); this.$$compose(); return this } } function Wd() {\r\n        var b = \"\", a = !1; this.hashPrefix = function (a) { return z(a) ? (b = a, this) : b }; this.html5Mode = function (b) { return z(b) ? (a = b, this) : a }; this.$get = [\"$rootScope\", \"$browser\", \"$sniffer\", \"$rootElement\", function (c, d, e, f) {\r\n            function g(a) { c.$broadcast(\"$locationChangeSuccess\", k.absUrl(), a) } var k, m, h = d.baseHref(), l = d.url(), n; a ? (n = l.substring(0, l.indexOf(\"/\", l.indexOf(\"//\") + 2)) + (h || \"/\"), m = e.history ? Bc : Ub) : (n =\r\n            eb(l), m = Tb); k = new m(n, \"#\" + b); k.$$parse(k.$$rewrite(l)); var p = /^\\s*(javascript|mailto):/i; f.on(\"click\", function (a) {\r\n                if (!a.ctrlKey && !a.metaKey && 2 != a.which) {\r\n                    for (var e = v(a.target) ; \"a\" !== M(e[0].nodeName) ;) if (e[0] === f[0] || !(e = e.parent())[0]) return; var g = e.prop(\"href\"); T(g) && \"[object SVGAnimatedString]\" === g.toString() && (g = ua(g.animVal).href); if (!p.test(g)) {\r\n                        if (m === Ub) {\r\n                            var h = e.attr(\"href\") || e.attr(\"xlink:href\"); if (h && 0 > h.indexOf(\"://\")) if (g = \"#\" + b, \"/\" == h[0]) g = n + g + h; else if (\"#\" == h[0]) g = n + g + (k.path() || \"/\") + h;\r\n                            else { var l = k.path().split(\"/\"), h = h.split(\"/\"); 2 !== l.length || l[1] || (l.length = 1); for (var q = 0; q < h.length; q++) \".\" != h[q] && (\"..\" == h[q] ? l.pop() : h[q].length && l.push(h[q])); g = n + g + l.join(\"/\") }\r\n                        } l = k.$$rewrite(g); g && (!e.attr(\"target\") && l && !a.isDefaultPrevented()) && (a.preventDefault(), l != d.url() && (k.$$parse(l), c.$apply(), W.angular[\"ff-684208-preventDefault\"] = !0))\r\n                    }\r\n                }\r\n            }); k.absUrl() != l && d.url(k.absUrl(), !0); d.onUrlChange(function (a) {\r\n                k.absUrl() != a && (c.$evalAsync(function () {\r\n                    var b = k.absUrl(); k.$$parse(a); c.$broadcast(\"$locationChangeStart\",\r\n                    a, b).defaultPrevented ? (k.$$parse(b), d.url(b)) : g(b)\r\n                }), c.$$phase || c.$digest())\r\n            }); var q = 0; c.$watch(function () { var a = d.url(), b = k.$$replace; q && a == k.absUrl() || (q++, c.$evalAsync(function () { c.$broadcast(\"$locationChangeStart\", k.absUrl(), a).defaultPrevented ? k.$$parse(a) : (d.url(k.absUrl(), b), g(a)) })); k.$$replace = !1; return q }); return k\r\n        }]\r\n    } function Xd() {\r\n        var b = !0, a = this; this.debugEnabled = function (a) { return z(a) ? (b = a, this) : b }; this.$get = [\"$window\", function (c) {\r\n            function d(a) {\r\n                a instanceof Error && (a.stack ? a = a.message &&\r\n                -1 === a.stack.indexOf(a.message) ? \"Error: \" + a.message + \"\\n\" + a.stack : a.stack : a.sourceURL && (a = a.message + \"\\n\" + a.sourceURL + \":\" + a.line)); return a\r\n            } function e(a) { var b = c.console || {}, e = b[a] || b.log || F; a = !1; try { a = !!e.apply } catch (m) { } return a ? function () { var a = []; r(arguments, function (b) { a.push(d(b)) }); return e.apply(b, a) } : function (a, b) { e(a, null == b ? \"\" : b) } } return { log: e(\"log\"), info: e(\"info\"), warn: e(\"warn\"), error: e(\"error\"), debug: function () { var c = e(\"debug\"); return function () { b && c.apply(a, arguments) } }() }\r\n        }]\r\n    } function ka(b,\r\n    a) { if (\"__defineGetter__\" === b || \"__defineSetter__\" === b || \"__lookupGetter__\" === b || \"__lookupSetter__\" === b || \"__proto__\" === b) throw la(\"isecfld\", a); return b } function va(b, a) { if (b) { if (b.constructor === b) throw la(\"isecfn\", a); if (b.document && b.location && b.alert && b.setInterval) throw la(\"isecwindow\", a); if (b.children && (b.nodeName || b.prop && b.attr && b.find)) throw la(\"isecdom\", a); if (b === Object) throw la(\"isecobj\", a); } return b } function ub(b, a, c, d, e) {\r\n        va(b, d); e = e || {}; a = a.split(\".\"); for (var f, g = 0; 1 < a.length; g++) {\r\n            f = ka(a.shift(),\r\n            d); var k = va(b[f], d); k || (k = {}, b[f] = k); b = k; b.then && e.unwrapPromises && (wa(d), \"$$v\" in b || function (a) { a.then(function (b) { a.$$v = b }) }(b), b.$$v === t && (b.$$v = {}), b = b.$$v)\r\n        } f = ka(a.shift(), d); va(b[f], d); return b[f] = c\r\n    } function Dc(b, a, c, d, e, f, g) {\r\n        ka(b, f); ka(a, f); ka(c, f); ka(d, f); ka(e, f); return g.unwrapPromises ? function (g, m) {\r\n            var h = m && m.hasOwnProperty(b) ? m : g, l; if (null == h) return h; (h = h[b]) && h.then && (wa(f), \"$$v\" in h || (l = h, l.$$v = t, l.then(function (a) { l.$$v = a })), h = h.$$v); if (!a) return h; if (null == h) return t; (h = h[a]) && h.then &&\r\n            (wa(f), \"$$v\" in h || (l = h, l.$$v = t, l.then(function (a) { l.$$v = a })), h = h.$$v); if (!c) return h; if (null == h) return t; (h = h[c]) && h.then && (wa(f), \"$$v\" in h || (l = h, l.$$v = t, l.then(function (a) { l.$$v = a })), h = h.$$v); if (!d) return h; if (null == h) return t; (h = h[d]) && h.then && (wa(f), \"$$v\" in h || (l = h, l.$$v = t, l.then(function (a) { l.$$v = a })), h = h.$$v); if (!e) return h; if (null == h) return t; (h = h[e]) && h.then && (wa(f), \"$$v\" in h || (l = h, l.$$v = t, l.then(function (a) { l.$$v = a })), h = h.$$v); return h\r\n        } : function (f, g) {\r\n            var h = g && g.hasOwnProperty(b) ? g : f; if (null ==\r\n            h) return h; h = h[b]; if (!a) return h; if (null == h) return t; h = h[a]; if (!c) return h; if (null == h) return t; h = h[c]; if (!d) return h; if (null == h) return t; h = h[d]; return e ? null == h ? t : h = h[e] : h\r\n        }\r\n    } function Ec(b, a, c) {\r\n        if (Vb.hasOwnProperty(b)) return Vb[b]; var d = b.split(\".\"), e = d.length, f; if (a.csp) f = 6 > e ? Dc(d[0], d[1], d[2], d[3], d[4], c, a) : function (b, f) { var g = 0, k; do k = Dc(d[g++], d[g++], d[g++], d[g++], d[g++], c, a)(b, f), f = t, b = k; while (g < e); return k }; else {\r\n            var g = \"var p;\\n\"; r(d, function (b, d) {\r\n                ka(b, c); g += \"if(s == null) return undefined;\\ns=\" +\r\n                (d ? \"s\" : '((k&&k.hasOwnProperty(\"' + b + '\"))?k:s)') + '[\"' + b + '\"];\\n' + (a.unwrapPromises ? 'if (s && s.then) {\\n pw(\"' + c.replace(/([\"\\r\\n])/g, \"\\\\$1\") + '\");\\n if (!(\"$$v\" in s)) {\\n p=s;\\n p.$$v = undefined;\\n p.then(function(v) {p.$$v=v;});\\n}\\n s=s.$$v\\n}\\n' : \"\")\r\n            }); var g = g + \"return s;\", k = new Function(\"s\", \"k\", \"pw\", g); k.toString = ba(g); f = a.unwrapPromises ? function (a, b) { return k(a, b, wa) } : k\r\n        } \"hasOwnProperty\" !== b && (Vb[b] = f); return f\r\n    } function Yd() {\r\n        var b = {}, a = { csp: !1, unwrapPromises: !1, logPromiseWarnings: !0 }; this.unwrapPromises =\r\n        function (b) { return z(b) ? (a.unwrapPromises = !!b, this) : a.unwrapPromises }; this.logPromiseWarnings = function (b) { return z(b) ? (a.logPromiseWarnings = b, this) : a.logPromiseWarnings }; this.$get = [\"$filter\", \"$sniffer\", \"$log\", function (c, d, e) {\r\n            a.csp = d.csp; wa = function (b) { a.logPromiseWarnings && !Fc.hasOwnProperty(b) && (Fc[b] = !0, e.warn(\"[$parse] Promise found in the expression `\" + b + \"`. Automatic unwrapping of promises in Angular expressions is deprecated.\")) }; return function (d) {\r\n                var e; switch (typeof d) {\r\n                    case \"string\": if (b.hasOwnProperty(d)) return b[d];\r\n                        e = new Wb(a); e = (new fb(e, c, a)).parse(d); \"hasOwnProperty\" !== d && (b[d] = e); return e; case \"function\": return d; default: return F\r\n                }\r\n            }\r\n        }]\r\n    } function $d() { this.$get = [\"$rootScope\", \"$exceptionHandler\", function (b, a) { return Ae(function (a) { b.$evalAsync(a) }, a) }] } function Ae(b, a) {\r\n        function c(a) { return a } function d(a) { return g(a) } var e = function () {\r\n            var g = [], h, l; return l = {\r\n                resolve: function (a) { if (g) { var c = g; g = t; h = f(a); c.length && b(function () { for (var a, b = 0, d = c.length; b < d; b++) a = c[b], h.then(a[0], a[1], a[2]) }) } }, reject: function (a) { l.resolve(k(a)) },\r\n                notify: function (a) { if (g) { var c = g; g.length && b(function () { for (var b, d = 0, e = c.length; d < e; d++) b = c[d], b[2](a) }) } }, promise: {\r\n                    then: function (b, f, k) { var l = e(), E = function (d) { try { l.resolve((P(b) ? b : c)(d)) } catch (e) { l.reject(e), a(e) } }, u = function (b) { try { l.resolve((P(f) ? f : d)(b)) } catch (c) { l.reject(c), a(c) } }, B = function (b) { try { l.notify((P(k) ? k : c)(b)) } catch (d) { a(d) } }; g ? g.push([E, u, B]) : h.then(E, u, B); return l.promise }, \"catch\": function (a) { return this.then(null, a) }, \"finally\": function (a) {\r\n                        function b(a, c) {\r\n                            var d = e(); c ? d.resolve(a) :\r\n                            d.reject(a); return d.promise\r\n                        } function d(e, f) { var g = null; try { g = (a || c)() } catch (k) { return b(k, !1) } return g && P(g.then) ? g.then(function () { return b(e, f) }, function (a) { return b(a, !1) }) : b(e, f) } return this.then(function (a) { return d(a, !0) }, function (a) { return d(a, !1) })\r\n                    }\r\n                }\r\n            }\r\n        }, f = function (a) { return a && P(a.then) ? a : { then: function (c) { var d = e(); b(function () { d.resolve(c(a)) }); return d.promise } } }, g = function (a) { var b = e(); b.reject(a); return b.promise }, k = function (c) {\r\n            return {\r\n                then: function (f, g) {\r\n                    var k = e(); b(function () {\r\n                        try {\r\n                            k.resolve((P(g) ?\r\n                                g : d)(c))\r\n                        } catch (b) { k.reject(b), a(b) }\r\n                    }); return k.promise\r\n                }\r\n            }\r\n        }; return {\r\n            defer: e, reject: g, when: function (k, h, l, n) { var p = e(), q, s = function (b) { try { return (P(h) ? h : c)(b) } catch (d) { return a(d), g(d) } }, E = function (b) { try { return (P(l) ? l : d)(b) } catch (c) { return a(c), g(c) } }, u = function (b) { try { return (P(n) ? n : c)(b) } catch (d) { a(d) } }; b(function () { f(k).then(function (a) { q || (q = !0, p.resolve(f(a).then(s, E, u))) }, function (a) { q || (q = !0, p.resolve(E(a))) }, function (a) { q || p.notify(u(a)) }) }); return p.promise }, all: function (a) {\r\n                var b = e(), c = 0, d = I(a) ?\r\n                [] : {}; r(a, function (a, e) { c++; f(a).then(function (a) { d.hasOwnProperty(e) || (d[e] = a, --c || b.resolve(d)) }, function (a) { d.hasOwnProperty(e) || b.reject(a) }) }); 0 === c && b.resolve(d); return b.promise\r\n            }\r\n        }\r\n    } function ge() {\r\n        this.$get = [\"$window\", \"$timeout\", function (b, a) {\r\n            var c = b.requestAnimationFrame || b.webkitRequestAnimationFrame || b.mozRequestAnimationFrame, d = b.cancelAnimationFrame || b.webkitCancelAnimationFrame || b.mozCancelAnimationFrame || b.webkitCancelRequestAnimationFrame, e = !!c, f = e ? function (a) { var b = c(a); return function () { d(b) } } :\r\n            function (b) { var c = a(b, 16.66, !1); return function () { a.cancel(c) } }; f.supported = e; return f\r\n        }]\r\n    } function Zd() {\r\n        var b = 10, a = D(\"$rootScope\"), c = null; this.digestTtl = function (a) { arguments.length && (b = a); return b }; this.$get = [\"$injector\", \"$exceptionHandler\", \"$parse\", \"$browser\", function (d, e, f, g) {\r\n            function k() {\r\n                this.$id = hb(); this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null; this[\"this\"] = this.$root = this; this.$$destroyed = !1; this.$$asyncQueue = []; this.$$postDigestQueue =\r\n                []; this.$$listeners = {}; this.$$listenerCount = {}; this.$$isolateBindings = {}\r\n            } function m(b) { if (p.$$phase) throw a(\"inprog\", p.$$phase); p.$$phase = b } function h(a, b) { var c = f(a); Wa(c, b); return c } function l(a, b, c) { do a.$$listenerCount[c] -= b, 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c]; while (a = a.$parent) } function n() { } k.prototype = {\r\n                constructor: k, $new: function (a) {\r\n                    a ? (a = new k, a.$root = this.$root, a.$$asyncQueue = this.$$asyncQueue, a.$$postDigestQueue = this.$$postDigestQueue) : (this.$$childScopeClass || (this.$$childScopeClass =\r\n                    function () { this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null; this.$$listeners = {}; this.$$listenerCount = {}; this.$id = hb(); this.$$childScopeClass = null }, this.$$childScopeClass.prototype = this), a = new this.$$childScopeClass); a[\"this\"] = a; a.$parent = this; a.$$prevSibling = this.$$childTail; this.$$childHead ? this.$$childTail = this.$$childTail.$$nextSibling = a : this.$$childHead = this.$$childTail = a; return a\r\n                }, $watch: function (a, b, d) {\r\n                    var e = h(a, \"watch\"), f = this.$$watchers, g = {\r\n                        fn: b, last: n, get: e, exp: a,\r\n                        eq: !!d\r\n                    }; c = null; if (!P(b)) { var k = h(b || F, \"listener\"); g.fn = function (a, b, c) { k(c) } } if (\"string\" == typeof a && e.constant) { var l = g.fn; g.fn = function (a, b, c) { l.call(this, a, b, c); Sa(f, g) } } f || (f = this.$$watchers = []); f.unshift(g); return function () { Sa(f, g); c = null }\r\n                }, $watchCollection: function (a, b) {\r\n                    var c = this, d, e, g, k = 1 < b.length, h = 0, l = f(a), m = [], p = {}, n = !0, r = 0; return this.$watch(function () {\r\n                        d = l(c); var a, b, f; if (T(d)) if (Pa(d)) for (e !== m && (e = m, r = e.length = 0, h++), a = d.length, r !== a && (h++, e.length = r = a), b = 0; b < a; b++) f = e[b] !== e[b] && d[b] !==\r\n                        d[b], f || e[b] === d[b] || (h++, e[b] = d[b]); else { e !== p && (e = p = {}, r = 0, h++); a = 0; for (b in d) d.hasOwnProperty(b) && (a++, e.hasOwnProperty(b) ? (f = e[b] !== e[b] && d[b] !== d[b], f || e[b] === d[b] || (h++, e[b] = d[b])) : (r++, e[b] = d[b], h++)); if (r > a) for (b in h++, e) e.hasOwnProperty(b) && !d.hasOwnProperty(b) && (r--, delete e[b]) } else e !== d && (e = d, h++); return h\r\n                    }, function () { n ? (n = !1, b(d, d, c)) : b(d, g, c); if (k) if (T(d)) if (Pa(d)) { g = Array(d.length); for (var a = 0; a < d.length; a++) g[a] = d[a] } else for (a in g = {}, d) kb.call(d, a) && (g[a] = d[a]); else g = d })\r\n                }, $digest: function () {\r\n                    var d,\r\n                    f, k, h, l = this.$$asyncQueue, r = this.$$postDigestQueue, R, w, t = b, K, O = [], v, C, x; m(\"$digest\"); g.$$checkUrlChange(); c = null; do {\r\n                        w = !1; for (K = this; l.length;) { try { x = l.shift(), x.scope.$eval(x.expression) } catch (H) { p.$$phase = null, e(H) } c = null }a: do {\r\n                            if (h = K.$$watchers) for (R = h.length; R--;) try {\r\n                                if (d = h[R]) if ((f = d.get(K)) !== (k = d.last) && !(d.eq ? Aa(f, k) : \"number\" === typeof f && \"number\" === typeof k && isNaN(f) && isNaN(k))) w = !0, c = d, d.last = d.eq ? Ha(f, null) : f, d.fn(f, k === n ? f : k, K), 5 > t && (v = 4 - t, O[v] || (O[v] = []), C = P(d.exp) ? \"fn: \" + (d.exp.name || d.exp.toString()) :\r\n                                d.exp, C += \"; newVal: \" + na(f) + \"; oldVal: \" + na(k), O[v].push(C)); else if (d === c) { w = !1; break a }\r\n                            } catch (z) { p.$$phase = null, e(z) } if (!(h = K.$$childHead || K !== this && K.$$nextSibling)) for (; K !== this && !(h = K.$$nextSibling) ;) K = K.$parent\r\n                        } while (K = h); if ((w || l.length) && !t--) throw p.$$phase = null, a(\"infdig\", b, na(O));\r\n                    } while (w || l.length); for (p.$$phase = null; r.length;) try { r.shift()() } catch (A) { e(A) }\r\n                }, $destroy: function () {\r\n                    if (!this.$$destroyed) {\r\n                        var a = this.$parent; this.$broadcast(\"$destroy\"); this.$$destroyed = !0; this !== p && (r(this.$$listenerCount,\r\n                        Bb(null, l, this)), a.$$childHead == this && (a.$$childHead = this.$$nextSibling), a.$$childTail == this && (a.$$childTail = this.$$prevSibling), this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = null, this.$$listeners = {}, this.$$watchers = this.$$asyncQueue = this.$$postDigestQueue = [], this.$destroy = this.$digest = this.$apply = F, this.$on =\r\n                        this.$watch = function () { return F })\r\n                    }\r\n                }, $eval: function (a, b) { return f(a)(this, b) }, $evalAsync: function (a) { p.$$phase || p.$$asyncQueue.length || g.defer(function () { p.$$asyncQueue.length && p.$digest() }); this.$$asyncQueue.push({ scope: this, expression: a }) }, $$postDigest: function (a) { this.$$postDigestQueue.push(a) }, $apply: function (a) { try { return m(\"$apply\"), this.$eval(a) } catch (b) { e(b) } finally { p.$$phase = null; try { p.$digest() } catch (c) { throw e(c), c; } } }, $on: function (a, b) {\r\n                    var c = this.$$listeners[a]; c || (this.$$listeners[a] =\r\n                    c = []); c.push(b); var d = this; do d.$$listenerCount[a] || (d.$$listenerCount[a] = 0), d.$$listenerCount[a]++; while (d = d.$parent); var e = this; return function () { c[Ra(c, b)] = null; l(e, 1, a) }\r\n                }, $emit: function (a, b) {\r\n                    var c = [], d, f = this, g = !1, k = { name: a, targetScope: f, stopPropagation: function () { g = !0 }, preventDefault: function () { k.defaultPrevented = !0 }, defaultPrevented: !1 }, h = [k].concat(Ba.call(arguments, 1)), l, m; do {\r\n                        d = f.$$listeners[a] || c; k.currentScope = f; l = 0; for (m = d.length; l < m; l++) if (d[l]) try { d[l].apply(null, h) } catch (p) { e(p) } else d.splice(l,\r\n                        1), l--, m--; if (g) break; f = f.$parent\r\n                    } while (f); return k\r\n                }, $broadcast: function (a, b) { for (var c = this, d = this, f = { name: a, targetScope: this, preventDefault: function () { f.defaultPrevented = !0 }, defaultPrevented: !1 }, g = [f].concat(Ba.call(arguments, 1)), k, h; c = d;) { f.currentScope = c; d = c.$$listeners[a] || []; k = 0; for (h = d.length; k < h; k++) if (d[k]) try { d[k].apply(null, g) } catch (l) { e(l) } else d.splice(k, 1), k--, h--; if (!(d = c.$$listenerCount[a] && c.$$childHead || c !== this && c.$$nextSibling)) for (; c !== this && !(d = c.$$nextSibling) ;) c = c.$parent } return f }\r\n            };\r\n            var p = new k; return p\r\n        }]\r\n    } function cd() { var b = /^\\s*(https?|ftp|mailto|tel|file):/, a = /^\\s*((https?|ftp|file):|data:image\\/)/; this.aHrefSanitizationWhitelist = function (a) { return z(a) ? (b = a, this) : b }; this.imgSrcSanitizationWhitelist = function (b) { return z(b) ? (a = b, this) : a }; this.$get = function () { return function (c, d) { var e = d ? a : b, f; if (!Q || 8 <= Q) if (f = ua(c).href, \"\" !== f && !f.match(e)) return \"unsafe:\" + f; return c } } } function Be(b) {\r\n        if (\"self\" === b) return b; if (A(b)) {\r\n            if (-1 < b.indexOf(\"***\")) throw xa(\"iwcard\", b); b = b.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g,\r\n            \"\\\\$1\").replace(/\\x08/g, \"\\\\x08\").replace(\"\\\\*\\\\*\", \".*\").replace(\"\\\\*\", \"[^:/.?&;]*\"); return RegExp(\"^\" + b + \"$\")\r\n        } if (jb(b)) return RegExp(\"^\" + b.source + \"$\"); throw xa(\"imatcher\");\r\n    } function Gc(b) { var a = []; z(b) && r(b, function (b) { a.push(Be(b)) }); return a } function be() {\r\n        this.SCE_CONTEXTS = ga; var b = [\"self\"], a = []; this.resourceUrlWhitelist = function (a) { arguments.length && (b = Gc(a)); return b }; this.resourceUrlBlacklist = function (b) { arguments.length && (a = Gc(b)); return a }; this.$get = [\"$injector\", function (c) {\r\n            function d(a) {\r\n                var b =\r\n                function (a) { this.$$unwrapTrustedValue = function () { return a } }; a && (b.prototype = new a); b.prototype.valueOf = function () { return this.$$unwrapTrustedValue() }; b.prototype.toString = function () { return this.$$unwrapTrustedValue().toString() }; return b\r\n            } var e = function (a) { throw xa(\"unsafe\"); }; c.has(\"$sanitize\") && (e = c.get(\"$sanitize\")); var f = d(), g = {}; g[ga.HTML] = d(f); g[ga.CSS] = d(f); g[ga.URL] = d(f); g[ga.JS] = d(f); g[ga.RESOURCE_URL] = d(g[ga.URL]); return {\r\n                trustAs: function (a, b) {\r\n                    var c = g.hasOwnProperty(a) ? g[a] : null; if (!c) throw xa(\"icontext\",\r\n                    a, b); if (null === b || b === t || \"\" === b) return b; if (\"string\" !== typeof b) throw xa(\"itype\", a); return new c(b)\r\n                }, getTrusted: function (c, d) {\r\n                    if (null === d || d === t || \"\" === d) return d; var f = g.hasOwnProperty(c) ? g[c] : null; if (f && d instanceof f) return d.$$unwrapTrustedValue(); if (c === ga.RESOURCE_URL) {\r\n                        var f = ua(d.toString()), l, n, p = !1; l = 0; for (n = b.length; l < n; l++) if (\"self\" === b[l] ? Pb(f) : b[l].exec(f.href)) { p = !0; break } if (p) for (l = 0, n = a.length; l < n; l++) if (\"self\" === a[l] ? Pb(f) : a[l].exec(f.href)) { p = !1; break } if (p) return d; throw xa(\"insecurl\",\r\n                        d.toString());\r\n                    } if (c === ga.HTML) return e(d); throw xa(\"unsafe\");\r\n                }, valueOf: function (a) { return a instanceof f ? a.$$unwrapTrustedValue() : a }\r\n            }\r\n        }]\r\n    } function ae() {\r\n        var b = !0; this.enabled = function (a) { arguments.length && (b = !!a); return b }; this.$get = [\"$parse\", \"$sniffer\", \"$sceDelegate\", function (a, c, d) {\r\n            if (b && c.msie && 8 > c.msieDocumentMode) throw xa(\"iequirks\"); var e = ha(ga); e.isEnabled = function () { return b }; e.trustAs = d.trustAs; e.getTrusted = d.getTrusted; e.valueOf = d.valueOf; b || (e.trustAs = e.getTrusted = function (a, b) { return b },\r\n            e.valueOf = Qa); e.parseAs = function (b, c) { var d = a(c); return d.literal && d.constant ? d : function (a, c) { return e.getTrusted(b, d(a, c)) } }; var f = e.parseAs, g = e.getTrusted, k = e.trustAs; r(ga, function (a, b) { var c = M(b); e[Za(\"parse_as_\" + c)] = function (b) { return f(a, b) }; e[Za(\"get_trusted_\" + c)] = function (b) { return g(a, b) }; e[Za(\"trust_as_\" + c)] = function (b) { return k(a, b) } }); return e\r\n        }]\r\n    } function ce() {\r\n        this.$get = [\"$window\", \"$document\", function (b, a) {\r\n            var c = {}, d = U((/android (\\d+)/.exec(M((b.navigator || {}).userAgent)) || [])[1]), e = /Boxee/i.test((b.navigator ||\r\n            {}).userAgent), f = a[0] || {}, g = f.documentMode, k, m = /^(Moz|webkit|O|ms)(?=[A-Z])/, h = f.body && f.body.style, l = !1, n = !1; if (h) { for (var p in h) if (l = m.exec(p)) { k = l[0]; k = k.substr(0, 1).toUpperCase() + k.substr(1); break } k || (k = \"WebkitOpacity\" in h && \"webkit\"); l = !!(\"transition\" in h || k + \"Transition\" in h); n = !!(\"animation\" in h || k + \"Animation\" in h); !d || l && n || (l = A(f.body.style.webkitTransition), n = A(f.body.style.webkitAnimation)) } return {\r\n                history: !(!b.history || !b.history.pushState || 4 > d || e), hashchange: \"onhashchange\" in b && (!g || 7 <\r\n                g), hasEvent: function (a) { if (\"input\" == a && 9 == Q) return !1; if (y(c[a])) { var b = f.createElement(\"div\"); c[a] = \"on\" + a in b } return c[a] }, csp: Xa(), vendorPrefix: k, transitions: l, animations: n, android: d, msie: Q, msieDocumentMode: g\r\n            }\r\n        }]\r\n    } function ee() {\r\n        this.$get = [\"$rootScope\", \"$browser\", \"$q\", \"$exceptionHandler\", function (b, a, c, d) {\r\n            function e(e, k, m) {\r\n                var h = c.defer(), l = h.promise, n = z(m) && !m; k = a.defer(function () { try { h.resolve(e()) } catch (a) { h.reject(a), d(a) } finally { delete f[l.$$timeoutId] } n || b.$apply() }, k); l.$$timeoutId = k; f[k] = h;\r\n                return l\r\n            } var f = {}; e.cancel = function (b) { return b && b.$$timeoutId in f ? (f[b.$$timeoutId].reject(\"canceled\"), delete f[b.$$timeoutId], a.defer.cancel(b.$$timeoutId)) : !1 }; return e\r\n        }]\r\n    } function ua(b, a) {\r\n        var c = b; Q && (Y.setAttribute(\"href\", c), c = Y.href); Y.setAttribute(\"href\", c); return {\r\n            href: Y.href, protocol: Y.protocol ? Y.protocol.replace(/:$/, \"\") : \"\", host: Y.host, search: Y.search ? Y.search.replace(/^\\?/, \"\") : \"\", hash: Y.hash ? Y.hash.replace(/^#/, \"\") : \"\", hostname: Y.hostname, port: Y.port, pathname: \"/\" === Y.pathname.charAt(0) ? Y.pathname :\r\n            \"/\" + Y.pathname\r\n        }\r\n    } function Pb(b) { b = A(b) ? ua(b) : b; return b.protocol === Hc.protocol && b.host === Hc.host } function fe() { this.$get = ba(W) } function mc(b) { function a(d, e) { if (T(d)) { var f = {}; r(d, function (b, c) { f[c] = a(c, b) }); return f } return b.factory(d + c, e) } var c = \"Filter\"; this.register = a; this.$get = [\"$injector\", function (a) { return function (b) { return a.get(b + c) } }]; a(\"currency\", Ic); a(\"date\", Jc); a(\"filter\", Ce); a(\"json\", De); a(\"limitTo\", Ee); a(\"lowercase\", Fe); a(\"number\", Kc); a(\"orderBy\", Lc); a(\"uppercase\", Ge) } function Ce() {\r\n        return function (b,\r\n        a, c) {\r\n            if (!I(b)) return b; var d = typeof c, e = []; e.check = function (a) { for (var b = 0; b < e.length; b++) if (!e[b](a)) return !1; return !0 }; \"function\" !== d && (c = \"boolean\" === d && c ? function (a, b) { return Va.equals(a, b) } : function (a, b) { if (a && b && \"object\" === typeof a && \"object\" === typeof b) { for (var d in a) if (\"$\" !== d.charAt(0) && kb.call(a, d) && c(a[d], b[d])) return !0; return !1 } b = (\"\" + b).toLowerCase(); return -1 < (\"\" + a).toLowerCase().indexOf(b) }); var f = function (a, b) {\r\n                if (\"string\" == typeof b && \"!\" === b.charAt(0)) return !f(a, b.substr(1)); switch (typeof a) {\r\n                    case \"boolean\": case \"number\": case \"string\": return c(a,\r\n                    b); case \"object\": switch (typeof b) { case \"object\": return c(a, b); default: for (var d in a) if (\"$\" !== d.charAt(0) && f(a[d], b)) return !0 } return !1; case \"array\": for (d = 0; d < a.length; d++) if (f(a[d], b)) return !0; return !1; default: return !1\r\n                }\r\n            }; switch (typeof a) { case \"boolean\": case \"number\": case \"string\": a = { $: a }; case \"object\": for (var g in a) (function (b) { \"undefined\" !== typeof a[b] && e.push(function (c) { return f(\"$\" == b ? c : c && c[b], a[b]) }) })(g); break; case \"function\": e.push(a); break; default: return b } d = []; for (g = 0; g < b.length; g++) {\r\n                var k =\r\n                b[g]; e.check(k) && d.push(k)\r\n            } return d\r\n        }\r\n    } function Ic(b) { var a = b.NUMBER_FORMATS; return function (b, d) { y(d) && (d = a.CURRENCY_SYM); return Mc(b, a.PATTERNS[1], a.GROUP_SEP, a.DECIMAL_SEP, 2).replace(/\\u00A4/g, d) } } function Kc(b) { var a = b.NUMBER_FORMATS; return function (b, d) { return Mc(b, a.PATTERNS[0], a.GROUP_SEP, a.DECIMAL_SEP, d) } } function Mc(b, a, c, d, e) {\r\n        if (null == b || !isFinite(b) || T(b)) return \"\"; var f = 0 > b; b = Math.abs(b); var g = b + \"\", k = \"\", m = [], h = !1; if (-1 !== g.indexOf(\"e\")) {\r\n            var l = g.match(/([\\d\\.]+)e(-?)(\\d+)/); l && \"-\" == l[2] &&\r\n            l[3] > e + 1 ? (g = \"0\", b = 0) : (k = g, h = !0)\r\n        } if (h) 0 < e && (-1 < b && 1 > b) && (k = b.toFixed(e)); else {\r\n            g = (g.split(Nc)[1] || \"\").length; y(e) && (e = Math.min(Math.max(a.minFrac, g), a.maxFrac)); b = +(Math.round(+(b.toString() + \"e\" + e)).toString() + \"e\" + -e); 0 === b && (f = !1); b = (\"\" + b).split(Nc); g = b[0]; b = b[1] || \"\"; var l = 0, n = a.lgSize, p = a.gSize; if (g.length >= n + p) for (l = g.length - n, h = 0; h < l; h++) 0 === (l - h) % p && 0 !== h && (k += c), k += g.charAt(h); for (h = l; h < g.length; h++) 0 === (g.length - h) % n && 0 !== h && (k += c), k += g.charAt(h); for (; b.length < e;) b += \"0\"; e && \"0\" !== e && (k += d + b.substr(0,\r\n            e))\r\n        } m.push(f ? a.negPre : a.posPre); m.push(k); m.push(f ? a.negSuf : a.posSuf); return m.join(\"\")\r\n    } function Xb(b, a, c) { var d = \"\"; 0 > b && (d = \"-\", b = -b); for (b = \"\" + b; b.length < a;) b = \"0\" + b; c && (b = b.substr(b.length - a)); return d + b } function $(b, a, c, d) { c = c || 0; return function (e) { e = e[\"get\" + b](); if (0 < c || e > -c) e += c; 0 === e && -12 == c && (e = 12); return Xb(e, a, d) } } function vb(b, a) { return function (c, d) { var e = c[\"get\" + b](), f = Ia(a ? \"SHORT\" + b : b); return d[f][e] } } function Jc(b) {\r\n        function a(a) {\r\n            var b; if (b = a.match(c)) {\r\n                a = new Date(0); var f = 0, g = 0, k = b[8] ?\r\n                a.setUTCFullYear : a.setFullYear, m = b[8] ? a.setUTCHours : a.setHours; b[9] && (f = U(b[9] + b[10]), g = U(b[9] + b[11])); k.call(a, U(b[1]), U(b[2]) - 1, U(b[3])); f = U(b[4] || 0) - f; g = U(b[5] || 0) - g; k = U(b[6] || 0); b = Math.round(1E3 * parseFloat(\"0.\" + (b[7] || 0))); m.call(a, f, g, k, b)\r\n            } return a\r\n        } var c = /^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/; return function (c, e) {\r\n            var f = \"\", g = [], k, m; e = e || \"mediumDate\"; e = b.DATETIME_FORMATS[e] || e; A(c) && (c = He.test(c) ? U(c) : a(c)); ib(c) && (c = new Date(c));\r\n            if (!ta(c)) return c; for (; e;) (m = Ie.exec(e)) ? (g = g.concat(Ba.call(m, 1)), e = g.pop()) : (g.push(e), e = null); r(g, function (a) { k = Je[a]; f += k ? k(c, b.DATETIME_FORMATS) : a.replace(/(^'|'$)/g, \"\").replace(/''/g, \"'\") }); return f\r\n        }\r\n    } function De() { return function (b) { return na(b, !0) } } function Ee() {\r\n        return function (b, a) {\r\n            if (!I(b) && !A(b)) return b; a = Infinity === Math.abs(Number(a)) ? Number(a) : U(a); if (A(b)) return a ? 0 <= a ? b.slice(0, a) : b.slice(a, b.length) : \"\"; var c = [], d, e; a > b.length ? a = b.length : a < -b.length && (a = -b.length); 0 < a ? (d = 0, e = a) : (d =\r\n            b.length + a, e = b.length); for (; d < e; d++) c.push(b[d]); return c\r\n        }\r\n    } function Lc(b) {\r\n        return function (a, c, d) {\r\n            function e(a, b) { return Ua(b) ? function (b, c) { return a(c, b) } : a } function f(a, b) { var c = typeof a, d = typeof b; return c == d ? (ta(a) && ta(b) && (a = a.valueOf(), b = b.valueOf()), \"string\" == c && (a = a.toLowerCase(), b = b.toLowerCase()), a === b ? 0 : a < b ? -1 : 1) : c < d ? -1 : 1 } if (!Pa(a) || !c) return a; c = I(c) ? c : [c]; c = Vc(c, function (a) {\r\n                var c = !1, d = a || Qa; if (A(a)) {\r\n                    if (\"+\" == a.charAt(0) || \"-\" == a.charAt(0)) c = \"-\" == a.charAt(0), a = a.substring(1); d = b(a); if (d.constant) {\r\n                        var g =\r\n                        d(); return e(function (a, b) { return f(a[g], b[g]) }, c)\r\n                    }\r\n                } return e(function (a, b) { return f(d(a), d(b)) }, c)\r\n            }); for (var g = [], k = 0; k < a.length; k++) g.push(a[k]); return g.sort(e(function (a, b) { for (var d = 0; d < c.length; d++) { var e = c[d](a, b); if (0 !== e) return e } return 0 }, d))\r\n        }\r\n    } function ya(b) { P(b) && (b = { link: b }); b.restrict = b.restrict || \"AC\"; return ba(b) } function Oc(b, a, c, d) {\r\n        function e(a, c) { c = c ? \"-\" + mb(c, \"-\") : \"\"; d.setClass(b, (a ? wb : xb) + c, (a ? xb : wb) + c) } var f = this, g = b.parent().controller(\"form\") || yb, k = 0, m = f.$error = {}, h = []; f.$name =\r\n        a.name || a.ngForm; f.$dirty = !1; f.$pristine = !0; f.$valid = !0; f.$invalid = !1; g.$addControl(f); b.addClass(Oa); e(!0); f.$addControl = function (a) { Da(a.$name, \"input\"); h.push(a); a.$name && (f[a.$name] = a) }; f.$removeControl = function (a) { a.$name && f[a.$name] === a && delete f[a.$name]; r(m, function (b, c) { f.$setValidity(c, !0, a) }); Sa(h, a) }; f.$setValidity = function (a, b, c) {\r\n            var d = m[a]; if (b) d && (Sa(d, c), d.length || (k--, k || (e(b), f.$valid = !0, f.$invalid = !1), m[a] = !1, e(!0, a), g.$setValidity(a, !0, f))); else {\r\n                k || e(b); if (d) { if (-1 != Ra(d, c)) return } else m[a] =\r\n                d = [], k++, e(!1, a), g.$setValidity(a, !1, f); d.push(c); f.$valid = !1; f.$invalid = !0\r\n            }\r\n        }; f.$setDirty = function () { d.removeClass(b, Oa); d.addClass(b, zb); f.$dirty = !0; f.$pristine = !1; g.$setDirty() }; f.$setPristine = function () { d.removeClass(b, zb); d.addClass(b, Oa); f.$dirty = !1; f.$pristine = !0; r(h, function (a) { a.$setPristine() }) }\r\n    } function sa(b, a, c, d) { b.$setValidity(a, c); return c ? d : t } function Pc(b, a) { var c, d; if (a) for (c = 0; c < a.length; ++c) if (d = a[c], b[d]) return !0; return !1 } function Ke(b, a, c, d, e) {\r\n        T(e) && (b.$$hasNativeValidators = !0,\r\n        b.$parsers.push(function (f) { if (b.$error[a] || Pc(e, d) || !Pc(e, c)) return f; b.$setValidity(a, !1) }))\r\n    } function Ab(b, a, c, d, e, f) {\r\n        var g = a.prop(Le), k = a[0].placeholder, m = {}, h = M(a[0].type); d.$$validityState = g; if (!e.android) { var l = !1; a.on(\"compositionstart\", function (a) { l = !0 }); a.on(\"compositionend\", function () { l = !1; n() }) } var n = function (e) {\r\n            if (!l) {\r\n                var f = a.val(); if (Q && \"input\" === (e || m).type && a[0].placeholder !== k) k = a[0].placeholder; else if (\"password\" !== h && Ua(c.ngTrim || \"T\") && (f = aa(f)), e = g && d.$$hasNativeValidators, d.$viewValue !==\r\n                f || \"\" === f && e) b.$root.$$phase ? d.$setViewValue(f) : b.$apply(function () { d.$setViewValue(f) })\r\n            }\r\n        }; if (e.hasEvent(\"input\")) a.on(\"input\", n); else { var p, q = function () { p || (p = f.defer(function () { n(); p = null })) }; a.on(\"keydown\", function (a) { a = a.keyCode; 91 === a || (15 < a && 19 > a || 37 <= a && 40 >= a) || q() }); if (e.hasEvent(\"paste\")) a.on(\"paste cut\", q) } a.on(\"change\", n); d.$render = function () { a.val(d.$isEmpty(d.$viewValue) ? \"\" : d.$viewValue) }; var s = c.ngPattern; s && ((e = s.match(/^\\/(.*)\\/([gim]*)$/)) ? (s = RegExp(e[1], e[2]), e = function (a) {\r\n            return sa(d,\r\n            \"pattern\", d.$isEmpty(a) || s.test(a), a)\r\n        }) : e = function (c) { var e = b.$eval(s); if (!e || !e.test) throw D(\"ngPattern\")(\"noregexp\", s, e, ia(a)); return sa(d, \"pattern\", d.$isEmpty(c) || e.test(c), c) }, d.$formatters.push(e), d.$parsers.push(e)); if (c.ngMinlength) { var r = U(c.ngMinlength); e = function (a) { return sa(d, \"minlength\", d.$isEmpty(a) || a.length >= r, a) }; d.$parsers.push(e); d.$formatters.push(e) } if (c.ngMaxlength) {\r\n            var u = U(c.ngMaxlength); e = function (a) { return sa(d, \"maxlength\", d.$isEmpty(a) || a.length <= u, a) }; d.$parsers.push(e);\r\n            d.$formatters.push(e)\r\n        }\r\n    } function Yb(b, a) {\r\n        b = \"ngClass\" + b; return [\"$animate\", function (c) {\r\n            function d(a, b) { var c = [], d = 0; a: for (; d < a.length; d++) { for (var e = a[d], l = 0; l < b.length; l++) if (e == b[l]) continue a; c.push(e) } return c } function e(a) { if (!I(a)) { if (A(a)) return a.split(\" \"); if (T(a)) { var b = []; r(a, function (a, c) { a && (b = b.concat(c.split(\" \"))) }); return b } } return a } return {\r\n                restrict: \"AC\", link: function (f, g, k) {\r\n                    function m(a, b) {\r\n                        var c = g.data(\"$classCounts\") || {}, d = []; r(a, function (a) {\r\n                            if (0 < b || c[a]) c[a] = (c[a] || 0) + b, c[a] === +(0 <\r\n                            b) && d.push(a)\r\n                        }); g.data(\"$classCounts\", c); return d.join(\" \")\r\n                    } function h(b) { if (!0 === a || f.$index % 2 === a) { var h = e(b || []); if (!l) { var q = m(h, 1); k.$addClass(q) } else if (!Aa(b, l)) { var s = e(l), q = d(h, s), h = d(s, h), h = m(h, -1), q = m(q, 1); 0 === q.length ? c.removeClass(g, h) : 0 === h.length ? c.addClass(g, q) : c.setClass(g, q, h) } } l = ha(b) } var l; f.$watch(k[b], h, !0); k.$observe(\"class\", function (a) { h(f.$eval(k[b])) }); \"ngClass\" !== b && f.$watch(\"$index\", function (c, d) {\r\n                        var g = c & 1; if (g !== (d & 1)) {\r\n                            var h = e(f.$eval(k[b])); g === a ? (g = m(h, 1), k.$addClass(g)) :\r\n                            (g = m(h, -1), k.$removeClass(g))\r\n                        }\r\n                    })\r\n                }\r\n            }\r\n        }]\r\n    } var Le = \"validity\", M = function (b) { return A(b) ? b.toLowerCase() : b }, kb = Object.prototype.hasOwnProperty, Ia = function (b) { return A(b) ? b.toUpperCase() : b }, Q, v, Ea, Ba = [].slice, Me = [].push, za = Object.prototype.toString, Ta = D(\"ng\"), Va = W.angular || (W.angular = {}), Ya, Ma, ma = [\"0\", \"0\", \"0\"]; Q = U((/msie (\\d+)/.exec(M(navigator.userAgent)) || [])[1]); isNaN(Q) && (Q = U((/trident\\/.*; rv:(\\d+)/.exec(M(navigator.userAgent)) || [])[1])); F.$inject = []; Qa.$inject = []; var I = function () {\r\n        return P(Array.isArray) ?\r\n        Array.isArray : function (b) { return \"[object Array]\" === za.call(b) }\r\n    }(), aa = function () { return String.prototype.trim ? function (b) { return A(b) ? b.trim() : b } : function (b) { return A(b) ? b.replace(/^\\s\\s*/, \"\").replace(/\\s\\s*$/, \"\") : b } }(); Ma = 9 > Q ? function (b) { b = b.nodeName ? b : b[0]; return b.scopeName && \"HTML\" != b.scopeName ? Ia(b.scopeName + \":\" + b.nodeName) : b.nodeName } : function (b) { return b.nodeName ? b.nodeName : b[0].nodeName }; var Xa = function () {\r\n        if (z(Xa.isActive_)) return Xa.isActive_; var b = !(!X.querySelector(\"[ng-csp]\") && !X.querySelector(\"[data-ng-csp]\"));\r\n        if (!b) try { new Function(\"\") } catch (a) { b = !0 } return Xa.isActive_ = b\r\n    }, Yc = /[A-Z]/g, ad = { full: \"1.2.25\", major: 1, minor: 2, dot: 25, codeName: \"hypnotic-gesticulation\" }; S.expando = \"ng339\"; var ab = S.cache = {}, ne = 1, sb = W.document.addEventListener ? function (b, a, c) { b.addEventListener(a, c, !1) } : function (b, a, c) { b.attachEvent(\"on\" + a, c) }, $a = W.document.removeEventListener ? function (b, a, c) { b.removeEventListener(a, c, !1) } : function (b, a, c) { b.detachEvent(\"on\" + a, c) }; S._data = function (b) { return this.cache[b[this.expando]] || {} }; var ie = /([\\:\\-\\_]+(.))/g,\r\n    je = /^moz([A-Z])/, Hb = D(\"jqLite\"), ke = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/, Ib = /<|&#?\\w+;/, le = /<([\\w:]+)/, me = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi, ea = { option: [1, '<select multiple=\"multiple\">', \"</select>\"], thead: [1, \"<table>\", \"</table>\"], col: [2, \"<table><colgroup>\", \"</colgroup></table>\"], tr: [2, \"<table><tbody>\", \"</tbody></table>\"], td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"], _default: [0, \"\", \"\"] }; ea.optgroup = ea.option; ea.tbody = ea.tfoot = ea.colgroup = ea.caption = ea.thead; ea.th =\r\n    ea.td; var La = S.prototype = { ready: function (b) { function a() { c || (c = !0, b()) } var c = !1; \"complete\" === X.readyState ? setTimeout(a) : (this.on(\"DOMContentLoaded\", a), S(W).on(\"load\", a)) }, toString: function () { var b = []; r(this, function (a) { b.push(\"\" + a) }); return \"[\" + b.join(\", \") + \"]\" }, eq: function (b) { return 0 <= b ? v(this[b]) : v(this[this.length + b]) }, length: 0, push: Me, sort: [].sort, splice: [].splice }, qb = {}; r(\"multiple selected checked disabled readOnly required open\".split(\" \"), function (b) { qb[M(b)] = b }); var rc = {}; r(\"input select option textarea button form details\".split(\" \"),\r\n    function (b) { rc[Ia(b)] = !0 }); r({ data: Mb, removeData: Lb }, function (b, a) { S[a] = b }); r({\r\n        data: Mb, inheritedData: pb, scope: function (b) { return v.data(b, \"$scope\") || pb(b.parentNode || b, [\"$isolateScope\", \"$scope\"]) }, isolateScope: function (b) { return v.data(b, \"$isolateScope\") || v.data(b, \"$isolateScopeNoTemplate\") }, controller: oc, injector: function (b) { return pb(b, \"$injector\") }, removeAttr: function (b, a) { b.removeAttribute(a) }, hasClass: Nb, css: function (b, a, c) {\r\n            a = Za(a); if (z(c)) b.style[a] = c; else {\r\n                var d; 8 >= Q && (d = b.currentStyle && b.currentStyle[a],\r\n                \"\" === d && (d = \"auto\")); d = d || b.style[a]; 8 >= Q && (d = \"\" === d ? t : d); return d\r\n            }\r\n        }, attr: function (b, a, c) { var d = M(a); if (qb[d]) if (z(c)) c ? (b[a] = !0, b.setAttribute(a, d)) : (b[a] = !1, b.removeAttribute(d)); else return b[a] || (b.attributes.getNamedItem(a) || F).specified ? d : t; else if (z(c)) b.setAttribute(a, c); else if (b.getAttribute) return b = b.getAttribute(a, 2), null === b ? t : b }, prop: function (b, a, c) { if (z(c)) b[a] = c; else return b[a] }, text: function () {\r\n            function b(b, d) { var e = a[b.nodeType]; if (y(d)) return e ? b[e] : \"\"; b[e] = d } var a = []; 9 > Q ? (a[1] =\r\n            \"innerText\", a[3] = \"nodeValue\") : a[1] = a[3] = \"textContent\"; b.$dv = \"\"; return b\r\n        }(), val: function (b, a) { if (y(a)) { if (\"SELECT\" === Ma(b) && b.multiple) { var c = []; r(b.options, function (a) { a.selected && c.push(a.value || a.text) }); return 0 === c.length ? null : c } return b.value } b.value = a }, html: function (b, a) { if (y(a)) return b.innerHTML; for (var c = 0, d = b.childNodes; c < d.length; c++) Ja(d[c]); b.innerHTML = a }, empty: pc\r\n    }, function (b, a) {\r\n        S.prototype[a] = function (a, d) {\r\n            var e, f, g = this.length; if (b !== pc && (2 == b.length && b !== Nb && b !== oc ? a : d) === t) {\r\n                if (T(a)) {\r\n                    for (e =\r\n                    0; e < g; e++) if (b === Mb) b(this[e], a); else for (f in a) b(this[e], f, a[f]); return this\r\n                } e = b.$dv; g = e === t ? Math.min(g, 1) : g; for (f = 0; f < g; f++) { var k = b(this[f], a, d); e = e ? e + k : k } return e\r\n            } for (e = 0; e < g; e++) b(this[e], a, d); return this\r\n        }\r\n    }); r({\r\n        removeData: Lb, dealoc: Ja, on: function a(c, d, e, f) {\r\n            if (z(f)) throw Hb(\"onargs\"); var g = oa(c, \"events\"), k = oa(c, \"handle\"); g || oa(c, \"events\", g = {}); k || oa(c, \"handle\", k = oe(c, g)); r(d.split(\" \"), function (d) {\r\n                var f = g[d]; if (!f) {\r\n                    if (\"mouseenter\" == d || \"mouseleave\" == d) {\r\n                        var l = X.body.contains || X.body.compareDocumentPosition ?\r\n                        function (a, c) { var d = 9 === a.nodeType ? a.documentElement : a, e = c && c.parentNode; return a === e || !!(e && 1 === e.nodeType && (d.contains ? d.contains(e) : a.compareDocumentPosition && a.compareDocumentPosition(e) & 16)) } : function (a, c) { if (c) for (; c = c.parentNode;) if (c === a) return !0; return !1 }; g[d] = []; a(c, { mouseleave: \"mouseout\", mouseenter: \"mouseover\" }[d], function (a) { var c = a.relatedTarget; c && (c === this || l(this, c)) || k(a, d) })\r\n                    } else sb(c, d, k), g[d] = []; f = g[d]\r\n                } f.push(e)\r\n            })\r\n        }, off: nc, one: function (a, c, d) {\r\n            a = v(a); a.on(c, function f() {\r\n                a.off(c,\r\n                d); a.off(c, f)\r\n            }); a.on(c, d)\r\n        }, replaceWith: function (a, c) { var d, e = a.parentNode; Ja(a); r(new S(c), function (c) { d ? e.insertBefore(c, d.nextSibling) : e.replaceChild(c, a); d = c }) }, children: function (a) { var c = []; r(a.childNodes, function (a) { 1 === a.nodeType && c.push(a) }); return c }, contents: function (a) { return a.contentDocument || a.childNodes || [] }, append: function (a, c) { r(new S(c), function (c) { 1 !== a.nodeType && 11 !== a.nodeType || a.appendChild(c) }) }, prepend: function (a, c) {\r\n            if (1 === a.nodeType) {\r\n                var d = a.firstChild; r(new S(c), function (c) {\r\n                    a.insertBefore(c,\r\n                    d)\r\n                })\r\n            }\r\n        }, wrap: function (a, c) { c = v(c)[0]; var d = a.parentNode; d && d.replaceChild(c, a); c.appendChild(a) }, remove: function (a) { Ja(a); var c = a.parentNode; c && c.removeChild(a) }, after: function (a, c) { var d = a, e = a.parentNode; r(new S(c), function (a) { e.insertBefore(a, d.nextSibling); d = a }) }, addClass: ob, removeClass: nb, toggleClass: function (a, c, d) { c && r(c.split(\" \"), function (c) { var f = d; y(f) && (f = !Nb(a, c)); (f ? ob : nb)(a, c) }) }, parent: function (a) { return (a = a.parentNode) && 11 !== a.nodeType ? a : null }, next: function (a) {\r\n            if (a.nextElementSibling) return a.nextElementSibling;\r\n            for (a = a.nextSibling; null != a && 1 !== a.nodeType;) a = a.nextSibling; return a\r\n        }, find: function (a, c) { return a.getElementsByTagName ? a.getElementsByTagName(c) : [] }, clone: Kb, triggerHandler: function (a, c, d) { var e, f; e = c.type || c; var g = (oa(a, \"events\") || {})[e]; g && (e = { preventDefault: function () { this.defaultPrevented = !0 }, isDefaultPrevented: function () { return !0 === this.defaultPrevented }, stopPropagation: F, type: e, target: a }, c.type && (e = J(e, c)), c = ha(g), f = d ? [e].concat(d) : [e], r(c, function (c) { c.apply(a, f) })) }\r\n    }, function (a, c) {\r\n        S.prototype[c] =\r\n        function (c, e, f) { for (var g, k = 0; k < this.length; k++) y(g) ? (g = a(this[k], c, e, f), z(g) && (g = v(g))) : Jb(g, a(this[k], c, e, f)); return z(g) ? g : this }; S.prototype.bind = S.prototype.on; S.prototype.unbind = S.prototype.off\r\n    }); bb.prototype = { put: function (a, c) { this[Ka(a, this.nextUid)] = c }, get: function (a) { return this[Ka(a, this.nextUid)] }, remove: function (a) { var c = this[a = Ka(a, this.nextUid)]; delete this[a]; return c } }; var qe = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m, re = /,/, se = /^\\s*(_?)(\\S+?)\\1\\s*$/, pe = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg,\r\n    cb = D(\"$injector\"), Ne = D(\"$animate\"), Md = [\"$provide\", function (a) {\r\n        this.$$selectors = {}; this.register = function (c, d) { var e = c + \"-animation\"; if (c && \".\" != c.charAt(0)) throw Ne(\"notcsel\", c); this.$$selectors[c.substr(1)] = e; a.factory(e, d) }; this.classNameFilter = function (a) { 1 === arguments.length && (this.$$classNameFilter = a instanceof RegExp ? a : null); return this.$$classNameFilter }; this.$get = [\"$timeout\", \"$$asyncCallback\", function (a, d) {\r\n            return {\r\n                enter: function (a, c, g, k) {\r\n                    g ? g.after(a) : (c && c[0] || (c = g.parent()), c.append(a)); k &&\r\n                    d(k)\r\n                }, leave: function (a, c) { a.remove(); c && d(c) }, move: function (a, c, d, k) { this.enter(a, c, d, k) }, addClass: function (a, c, g) { c = A(c) ? c : I(c) ? c.join(\" \") : \"\"; r(a, function (a) { ob(a, c) }); g && d(g) }, removeClass: function (a, c, g) { c = A(c) ? c : I(c) ? c.join(\" \") : \"\"; r(a, function (a) { nb(a, c) }); g && d(g) }, setClass: function (a, c, g, k) { r(a, function (a) { ob(a, c); nb(a, g) }); k && d(k) }, enabled: F\r\n            }\r\n        }]\r\n    }], ja = D(\"$compile\"); ic.$inject = [\"$provide\", \"$$sanitizeUriProvider\"]; var we = /^(x[\\:\\-_]|data[\\:\\-_])/i, yc = D(\"$interpolate\"), Oe = /^([^\\?#]*)(\\?([^#]*))?(#(.*))?$/,\r\n    ze = { http: 80, https: 443, ftp: 21 }, Sb = D(\"$location\"); Ub.prototype = Tb.prototype = Bc.prototype = {\r\n        $$html5: !1, $$replace: !1, absUrl: tb(\"$$absUrl\"), url: function (a) { if (y(a)) return this.$$url; a = Oe.exec(a); a[1] && this.path(decodeURIComponent(a[1])); (a[2] || a[1]) && this.search(a[3] || \"\"); this.hash(a[5] || \"\"); return this }, protocol: tb(\"$$protocol\"), host: tb(\"$$host\"), port: tb(\"$$port\"), path: Cc(\"$$path\", function (a) { a = a ? a.toString() : \"\"; return \"/\" == a.charAt(0) ? a : \"/\" + a }), search: function (a, c) {\r\n            switch (arguments.length) {\r\n                case 0: return this.$$search;\r\n                case 1: if (A(a) || ib(a)) a = a.toString(), this.$$search = ec(a); else if (T(a)) r(a, function (c, e) { null == c && delete a[e] }), this.$$search = a; else throw Sb(\"isrcharg\"); break; default: y(c) || null === c ? delete this.$$search[a] : this.$$search[a] = c\r\n            } this.$$compose(); return this\r\n        }, hash: Cc(\"$$hash\", function (a) { return a ? a.toString() : \"\" }), replace: function () { this.$$replace = !0; return this }\r\n    }; var la = D(\"$parse\"), Fc = {}, wa, Pe = Function.prototype.call, Qe = Function.prototype.apply, Qc = Function.prototype.bind, gb = {\r\n        \"null\": function () { return null },\r\n        \"true\": function () { return !0 }, \"false\": function () { return !1 }, undefined: F, \"+\": function (a, c, d, e) { d = d(a, c); e = e(a, c); return z(d) ? z(e) ? d + e : d : z(e) ? e : t }, \"-\": function (a, c, d, e) { d = d(a, c); e = e(a, c); return (z(d) ? d : 0) - (z(e) ? e : 0) }, \"*\": function (a, c, d, e) { return d(a, c) * e(a, c) }, \"/\": function (a, c, d, e) { return d(a, c) / e(a, c) }, \"%\": function (a, c, d, e) { return d(a, c) % e(a, c) }, \"^\": function (a, c, d, e) { return d(a, c) ^ e(a, c) }, \"=\": F, \"===\": function (a, c, d, e) { return d(a, c) === e(a, c) }, \"!==\": function (a, c, d, e) { return d(a, c) !== e(a, c) }, \"==\": function (a,\r\n        c, d, e) { return d(a, c) == e(a, c) }, \"!=\": function (a, c, d, e) { return d(a, c) != e(a, c) }, \"<\": function (a, c, d, e) { return d(a, c) < e(a, c) }, \">\": function (a, c, d, e) { return d(a, c) > e(a, c) }, \"<=\": function (a, c, d, e) { return d(a, c) <= e(a, c) }, \">=\": function (a, c, d, e) { return d(a, c) >= e(a, c) }, \"&&\": function (a, c, d, e) { return d(a, c) && e(a, c) }, \"||\": function (a, c, d, e) { return d(a, c) || e(a, c) }, \"&\": function (a, c, d, e) { return d(a, c) & e(a, c) }, \"|\": function (a, c, d, e) { return e(a, c)(a, c, d(a, c)) }, \"!\": function (a, c, d) { return !d(a, c) }\r\n    }, Re = {\r\n        n: \"\\n\", f: \"\\f\", r: \"\\r\",\r\n        t: \"\\t\", v: \"\\v\", \"'\": \"'\", '\"': '\"'\r\n    }, Wb = function (a) { this.options = a }; Wb.prototype = {\r\n        constructor: Wb, lex: function (a) {\r\n            this.text = a; this.index = 0; this.ch = t; this.lastCh = \":\"; for (this.tokens = []; this.index < this.text.length;) {\r\n                this.ch = this.text.charAt(this.index); if (this.is(\"\\\"'\")) this.readString(this.ch); else if (this.isNumber(this.ch) || this.is(\".\") && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdent(this.ch)) this.readIdent(); else if (this.is(\"(){}[].,;:?\")) this.tokens.push({ index: this.index, text: this.ch }),\r\n                this.index++; else if (this.isWhitespace(this.ch)) { this.index++; continue } else { a = this.ch + this.peek(); var c = a + this.peek(2), d = gb[this.ch], e = gb[a], f = gb[c]; f ? (this.tokens.push({ index: this.index, text: c, fn: f }), this.index += 3) : e ? (this.tokens.push({ index: this.index, text: a, fn: e }), this.index += 2) : d ? (this.tokens.push({ index: this.index, text: this.ch, fn: d }), this.index += 1) : this.throwError(\"Unexpected next character \", this.index, this.index + 1) } this.lastCh = this.ch\r\n            } return this.tokens\r\n        }, is: function (a) { return -1 !== a.indexOf(this.ch) },\r\n        was: function (a) { return -1 !== a.indexOf(this.lastCh) }, peek: function (a) { a = a || 1; return this.index + a < this.text.length ? this.text.charAt(this.index + a) : !1 }, isNumber: function (a) { return \"0\" <= a && \"9\" >= a }, isWhitespace: function (a) { return \" \" === a || \"\\r\" === a || \"\\t\" === a || \"\\n\" === a || \"\\v\" === a || \"\\u00a0\" === a }, isIdent: function (a) { return \"a\" <= a && \"z\" >= a || \"A\" <= a && \"Z\" >= a || \"_\" === a || \"$\" === a }, isExpOperator: function (a) { return \"-\" === a || \"+\" === a || this.isNumber(a) }, throwError: function (a, c, d) {\r\n            d = d || this.index; c = z(c) ? \"s \" + c + \"-\" + this.index + \" [\" +\r\n            this.text.substring(c, d) + \"]\" : \" \" + d; throw la(\"lexerr\", a, c, this.text);\r\n        }, readNumber: function () {\r\n            for (var a = \"\", c = this.index; this.index < this.text.length;) { var d = M(this.text.charAt(this.index)); if (\".\" == d || this.isNumber(d)) a += d; else { var e = this.peek(); if (\"e\" == d && this.isExpOperator(e)) a += d; else if (this.isExpOperator(d) && e && this.isNumber(e) && \"e\" == a.charAt(a.length - 1)) a += d; else if (!this.isExpOperator(d) || e && this.isNumber(e) || \"e\" != a.charAt(a.length - 1)) break; else this.throwError(\"Invalid exponent\") } this.index++ } a *=\r\n            1; this.tokens.push({ index: c, text: a, literal: !0, constant: !0, fn: function () { return a } })\r\n        }, readIdent: function () {\r\n            for (var a = this, c = \"\", d = this.index, e, f, g, k; this.index < this.text.length;) { k = this.text.charAt(this.index); if (\".\" === k || this.isIdent(k) || this.isNumber(k)) \".\" === k && (e = this.index), c += k; else break; this.index++ } if (e) for (f = this.index; f < this.text.length;) { k = this.text.charAt(f); if (\"(\" === k) { g = c.substr(e - d + 1); c = c.substr(0, e - d); this.index = f; break } if (this.isWhitespace(k)) f++; else break } d = { index: d, text: c }; if (gb.hasOwnProperty(c)) d.fn =\r\n            gb[c], d.literal = !0, d.constant = !0; else { var m = Ec(c, this.options, this.text); d.fn = J(function (a, c) { return m(a, c) }, { assign: function (d, e) { return ub(d, c, e, a.text, a.options) } }) } this.tokens.push(d); g && (this.tokens.push({ index: e, text: \".\" }), this.tokens.push({ index: e + 1, text: g }))\r\n        }, readString: function (a) {\r\n            var c = this.index; this.index++; for (var d = \"\", e = a, f = !1; this.index < this.text.length;) {\r\n                var g = this.text.charAt(this.index), e = e + g; if (f) \"u\" === g ? (f = this.text.substring(this.index + 1, this.index + 5), f.match(/[\\da-f]{4}/i) ||\r\n                this.throwError(\"Invalid unicode escape [\\\\u\" + f + \"]\"), this.index += 4, d += String.fromCharCode(parseInt(f, 16))) : d += Re[g] || g, f = !1; else if (\"\\\\\" === g) f = !0; else { if (g === a) { this.index++; this.tokens.push({ index: c, text: e, string: d, literal: !0, constant: !0, fn: function () { return d } }); return } d += g } this.index++\r\n            } this.throwError(\"Unterminated quote\", c)\r\n        }\r\n    }; var fb = function (a, c, d) { this.lexer = a; this.$filter = c; this.options = d }; fb.ZERO = J(function () { return 0 }, { constant: !0 }); fb.prototype = {\r\n        constructor: fb, parse: function (a) {\r\n            this.text =\r\n            a; this.tokens = this.lexer.lex(a); a = this.statements(); 0 !== this.tokens.length && this.throwError(\"is an unexpected token\", this.tokens[0]); a.literal = !!a.literal; a.constant = !!a.constant; return a\r\n        }, primary: function () {\r\n            var a; if (this.expect(\"(\")) a = this.filterChain(), this.consume(\")\"); else if (this.expect(\"[\")) a = this.arrayDeclaration(); else if (this.expect(\"{\")) a = this.object(); else { var c = this.expect(); (a = c.fn) || this.throwError(\"not a primary expression\", c); a.literal = !!c.literal; a.constant = !!c.constant } for (var d; c =\r\n            this.expect(\"(\", \"[\", \".\") ;) \"(\" === c.text ? (a = this.functionCall(a, d), d = null) : \"[\" === c.text ? (d = a, a = this.objectIndex(a)) : \".\" === c.text ? (d = a, a = this.fieldAccess(a)) : this.throwError(\"IMPOSSIBLE\"); return a\r\n        }, throwError: function (a, c) { throw la(\"syntax\", c.text, a, c.index + 1, this.text, this.text.substring(c.index)); }, peekToken: function () { if (0 === this.tokens.length) throw la(\"ueoe\", this.text); return this.tokens[0] }, peek: function (a, c, d, e) {\r\n            if (0 < this.tokens.length) {\r\n                var f = this.tokens[0], g = f.text; if (g === a || g === c || g === d || g ===\r\n                e || !(a || c || d || e)) return f\r\n            } return !1\r\n        }, expect: function (a, c, d, e) { return (a = this.peek(a, c, d, e)) ? (this.tokens.shift(), a) : !1 }, consume: function (a) { this.expect(a) || this.throwError(\"is unexpected, expecting [\" + a + \"]\", this.peek()) }, unaryFn: function (a, c) { return J(function (d, e) { return a(d, e, c) }, { constant: c.constant }) }, ternaryFn: function (a, c, d) { return J(function (e, f) { return a(e, f) ? c(e, f) : d(e, f) }, { constant: a.constant && c.constant && d.constant }) }, binaryFn: function (a, c, d) {\r\n            return J(function (e, f) { return c(e, f, a, d) }, {\r\n                constant: a.constant &&\r\n                d.constant\r\n            })\r\n        }, statements: function () { for (var a = []; ;) if (0 < this.tokens.length && !this.peek(\"}\", \")\", \";\", \"]\") && a.push(this.filterChain()), !this.expect(\";\")) return 1 === a.length ? a[0] : function (c, d) { for (var e, f = 0; f < a.length; f++) { var g = a[f]; g && (e = g(c, d)) } return e } }, filterChain: function () { for (var a = this.expression(), c; ;) if (c = this.expect(\"|\")) a = this.binaryFn(a, c.fn, this.filter()); else return a }, filter: function () {\r\n            for (var a = this.expect(), c = this.$filter(a.text), d = []; ;) if (a = this.expect(\":\")) d.push(this.expression());\r\n            else { var e = function (a, e, k) { k = [k]; for (var m = 0; m < d.length; m++) k.push(d[m](a, e)); return c.apply(a, k) }; return function () { return e } }\r\n        }, expression: function () { return this.assignment() }, assignment: function () { var a = this.ternary(), c, d; return (d = this.expect(\"=\")) ? (a.assign || this.throwError(\"implies assignment but [\" + this.text.substring(0, d.index) + \"] can not be assigned to\", d), c = this.ternary(), function (d, f) { return a.assign(d, c(d, f), f) }) : a }, ternary: function () {\r\n            var a = this.logicalOR(), c, d; if (this.expect(\"?\")) {\r\n                c = this.assignment();\r\n                if (d = this.expect(\":\")) return this.ternaryFn(a, c, this.assignment()); this.throwError(\"expected :\", d)\r\n            } else return a\r\n        }, logicalOR: function () { for (var a = this.logicalAND(), c; ;) if (c = this.expect(\"||\")) a = this.binaryFn(a, c.fn, this.logicalAND()); else return a }, logicalAND: function () { var a = this.equality(), c; if (c = this.expect(\"&&\")) a = this.binaryFn(a, c.fn, this.logicalAND()); return a }, equality: function () { var a = this.relational(), c; if (c = this.expect(\"==\", \"!=\", \"===\", \"!==\")) a = this.binaryFn(a, c.fn, this.equality()); return a },\r\n        relational: function () { var a = this.additive(), c; if (c = this.expect(\"<\", \">\", \"<=\", \">=\")) a = this.binaryFn(a, c.fn, this.relational()); return a }, additive: function () { for (var a = this.multiplicative(), c; c = this.expect(\"+\", \"-\") ;) a = this.binaryFn(a, c.fn, this.multiplicative()); return a }, multiplicative: function () { for (var a = this.unary(), c; c = this.expect(\"*\", \"/\", \"%\") ;) a = this.binaryFn(a, c.fn, this.unary()); return a }, unary: function () {\r\n            var a; return this.expect(\"+\") ? this.primary() : (a = this.expect(\"-\")) ? this.binaryFn(fb.ZERO, a.fn,\r\n            this.unary()) : (a = this.expect(\"!\")) ? this.unaryFn(a.fn, this.unary()) : this.primary()\r\n        }, fieldAccess: function (a) { var c = this, d = this.expect().text, e = Ec(d, this.options, this.text); return J(function (c, d, k) { return e(k || a(c, d)) }, { assign: function (e, g, k) { (k = a(e, k)) || a.assign(e, k = {}); return ub(k, d, g, c.text, c.options) } }) }, objectIndex: function (a) {\r\n            var c = this, d = this.expression(); this.consume(\"]\"); return J(function (e, f) {\r\n                var g = a(e, f), k = d(e, f), m; ka(k, c.text); if (!g) return t; (g = va(g[k], c.text)) && (g.then && c.options.unwrapPromises) &&\r\n                (m = g, \"$$v\" in g || (m.$$v = t, m.then(function (a) { m.$$v = a })), g = g.$$v); return g\r\n            }, { assign: function (e, f, g) { var k = ka(d(e, g), c.text); (g = va(a(e, g), c.text)) || a.assign(e, g = {}); return g[k] = f } })\r\n        }, functionCall: function (a, c) {\r\n            var d = []; if (\")\" !== this.peekToken().text) { do d.push(this.expression()); while (this.expect(\",\")) } this.consume(\")\"); var e = this; return function (f, g) {\r\n                for (var k = [], m = c ? c(f, g) : f, h = 0; h < d.length; h++) k.push(va(d[h](f, g), e.text)); h = a(f, g, m) || F; va(m, e.text); var l = e.text; if (h) {\r\n                    if (h.constructor === h) throw la(\"isecfn\",\r\n                    l); if (h === Pe || h === Qe || Qc && h === Qc) throw la(\"isecff\", l);\r\n                } k = h.apply ? h.apply(m, k) : h(k[0], k[1], k[2], k[3], k[4]); return va(k, e.text)\r\n            }\r\n        }, arrayDeclaration: function () { var a = [], c = !0; if (\"]\" !== this.peekToken().text) { do { if (this.peek(\"]\")) break; var d = this.expression(); a.push(d); d.constant || (c = !1) } while (this.expect(\",\")) } this.consume(\"]\"); return J(function (c, d) { for (var g = [], k = 0; k < a.length; k++) g.push(a[k](c, d)); return g }, { literal: !0, constant: c }) }, object: function () {\r\n            var a = [], c = !0; if (\"}\" !== this.peekToken().text) {\r\n                do {\r\n                    if (this.peek(\"}\")) break;\r\n                    var d = this.expect(), d = d.string || d.text; this.consume(\":\"); var e = this.expression(); a.push({ key: d, value: e }); e.constant || (c = !1)\r\n                } while (this.expect(\",\"))\r\n            } this.consume(\"}\"); return J(function (c, d) { for (var e = {}, m = 0; m < a.length; m++) { var h = a[m]; e[h.key] = h.value(c, d) } return e }, { literal: !0, constant: c })\r\n        }\r\n    }; var Vb = {}, xa = D(\"$sce\"), ga = { HTML: \"html\", CSS: \"css\", URL: \"url\", RESOURCE_URL: \"resourceUrl\", JS: \"js\" }, Y = X.createElement(\"a\"), Hc = ua(W.location.href, !0); mc.$inject = [\"$provide\"]; Ic.$inject = [\"$locale\"]; Kc.$inject = [\"$locale\"];\r\n    var Nc = \".\", Je = {\r\n        yyyy: $(\"FullYear\", 4), yy: $(\"FullYear\", 2, 0, !0), y: $(\"FullYear\", 1), MMMM: vb(\"Month\"), MMM: vb(\"Month\", !0), MM: $(\"Month\", 2, 1), M: $(\"Month\", 1, 1), dd: $(\"Date\", 2), d: $(\"Date\", 1), HH: $(\"Hours\", 2), H: $(\"Hours\", 1), hh: $(\"Hours\", 2, -12), h: $(\"Hours\", 1, -12), mm: $(\"Minutes\", 2), m: $(\"Minutes\", 1), ss: $(\"Seconds\", 2), s: $(\"Seconds\", 1), sss: $(\"Milliseconds\", 3), EEEE: vb(\"Day\"), EEE: vb(\"Day\", !0), a: function (a, c) { return 12 > a.getHours() ? c.AMPMS[0] : c.AMPMS[1] }, Z: function (a) {\r\n            a = -1 * a.getTimezoneOffset(); return a = (0 <= a ? \"+\" : \"\") + (Xb(Math[0 <\r\n            a ? \"floor\" : \"ceil\"](a / 60), 2) + Xb(Math.abs(a % 60), 2))\r\n        }\r\n    }, Ie = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, He = /^\\-?\\d+$/; Jc.$inject = [\"$locale\"]; var Fe = ba(M), Ge = ba(Ia); Lc.$inject = [\"$parse\"]; var dd = ba({\r\n        restrict: \"E\", compile: function (a, c) {\r\n            8 >= Q && (c.href || c.name || c.$set(\"href\", \"\"), a.append(X.createComment(\"IE fix\"))); if (!c.href && !c.xlinkHref && !c.name) return function (a, c) {\r\n                var f = \"[object SVGAnimatedString]\" === za.call(c.prop(\"href\")) ? \"xlink:href\" : \"href\"; c.on(\"click\", function (a) {\r\n                    c.attr(f) ||\r\n                    a.preventDefault()\r\n                })\r\n            }\r\n        }\r\n    }), Fb = {}; r(qb, function (a, c) { if (\"multiple\" != a) { var d = pa(\"ng-\" + c); Fb[d] = function () { return { priority: 100, link: function (a, f, g) { a.$watch(g[d], function (a) { g.$set(c, !!a) }) } } } } }); r([\"src\", \"srcset\", \"href\"], function (a) {\r\n        var c = pa(\"ng-\" + a); Fb[c] = function () {\r\n            return {\r\n                priority: 99, link: function (d, e, f) {\r\n                    var g = a, k = a; \"href\" === a && \"[object SVGAnimatedString]\" === za.call(e.prop(\"href\")) && (k = \"xlinkHref\", f.$attr[k] = \"xlink:href\", g = null); f.$observe(c, function (c) {\r\n                        c ? (f.$set(k, c), Q && g && e.prop(g, f[k])) : \"href\" ===\r\n                        a && f.$set(k, null)\r\n                    })\r\n                }\r\n            }\r\n        }\r\n    }); var yb = { $addControl: F, $removeControl: F, $setValidity: F, $setDirty: F, $setPristine: F }; Oc.$inject = [\"$element\", \"$attrs\", \"$scope\", \"$animate\"]; var Rc = function (a) {\r\n        return [\"$timeout\", function (c) {\r\n            return {\r\n                name: \"form\", restrict: a ? \"EAC\" : \"E\", controller: Oc, compile: function () {\r\n                    return {\r\n                        pre: function (a, e, f, g) {\r\n                            if (!f.action) { var k = function (a) { a.preventDefault ? a.preventDefault() : a.returnValue = !1 }; sb(e[0], \"submit\", k); e.on(\"$destroy\", function () { c(function () { $a(e[0], \"submit\", k) }, 0, !1) }) } var m = e.parent().controller(\"form\"),\r\n                            h = f.name || f.ngForm; h && ub(a, h, g, h); if (m) e.on(\"$destroy\", function () { m.$removeControl(g); h && ub(a, h, t, h); J(g, yb) })\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }]\r\n    }, ed = Rc(), rd = Rc(!0), Se = /^(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/, Te = /^[a-z0-9!#$%&'*+\\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, Ue = /^\\s*(\\-|\\+)?(\\d+|(\\d*(\\.\\d*)))\\s*$/, Sc = {\r\n        text: Ab, number: function (a, c, d, e, f, g) {\r\n            Ab(a, c, d, e, f, g); e.$parsers.push(function (a) {\r\n                var c = e.$isEmpty(a); if (c || Ue.test(a)) return e.$setValidity(\"number\",\r\n                !0), \"\" === a ? null : c ? a : parseFloat(a); e.$setValidity(\"number\", !1); return t\r\n            }); Ke(e, \"number\", Ve, null, e.$$validityState); e.$formatters.push(function (a) { return e.$isEmpty(a) ? \"\" : \"\" + a }); d.min && (a = function (a) { var c = parseFloat(d.min); return sa(e, \"min\", e.$isEmpty(a) || a >= c, a) }, e.$parsers.push(a), e.$formatters.push(a)); d.max && (a = function (a) { var c = parseFloat(d.max); return sa(e, \"max\", e.$isEmpty(a) || a <= c, a) }, e.$parsers.push(a), e.$formatters.push(a)); e.$formatters.push(function (a) {\r\n                return sa(e, \"number\", e.$isEmpty(a) ||\r\n                ib(a), a)\r\n            })\r\n        }, url: function (a, c, d, e, f, g) { Ab(a, c, d, e, f, g); a = function (a) { return sa(e, \"url\", e.$isEmpty(a) || Se.test(a), a) }; e.$formatters.push(a); e.$parsers.push(a) }, email: function (a, c, d, e, f, g) { Ab(a, c, d, e, f, g); a = function (a) { return sa(e, \"email\", e.$isEmpty(a) || Te.test(a), a) }; e.$formatters.push(a); e.$parsers.push(a) }, radio: function (a, c, d, e) {\r\n            y(d.name) && c.attr(\"name\", hb()); c.on(\"click\", function () { c[0].checked && a.$apply(function () { e.$setViewValue(d.value) }) }); e.$render = function () { c[0].checked = d.value == e.$viewValue };\r\n            d.$observe(\"value\", e.$render)\r\n        }, checkbox: function (a, c, d, e) { var f = d.ngTrueValue, g = d.ngFalseValue; A(f) || (f = !0); A(g) || (g = !1); c.on(\"click\", function () { a.$apply(function () { e.$setViewValue(c[0].checked) }) }); e.$render = function () { c[0].checked = e.$viewValue }; e.$isEmpty = function (a) { return a !== f }; e.$formatters.push(function (a) { return a === f }); e.$parsers.push(function (a) { return a ? f : g }) }, hidden: F, button: F, submit: F, reset: F, file: F\r\n    }, Ve = [\"badInput\"], jc = [\"$browser\", \"$sniffer\", function (a, c) {\r\n        return {\r\n            restrict: \"E\", require: \"?ngModel\",\r\n            link: function (d, e, f, g) { g && (Sc[M(f.type)] || Sc.text)(d, e, f, g, c, a) }\r\n        }\r\n    }], wb = \"ng-valid\", xb = \"ng-invalid\", Oa = \"ng-pristine\", zb = \"ng-dirty\", We = [\"$scope\", \"$exceptionHandler\", \"$attrs\", \"$element\", \"$parse\", \"$animate\", function (a, c, d, e, f, g) {\r\n        function k(a, c) { c = c ? \"-\" + mb(c, \"-\") : \"\"; g.removeClass(e, (a ? xb : wb) + c); g.addClass(e, (a ? wb : xb) + c) } this.$modelValue = this.$viewValue = Number.NaN; this.$parsers = []; this.$formatters = []; this.$viewChangeListeners = []; this.$pristine = !0; this.$dirty = !1; this.$valid = !0; this.$invalid = !1; this.$name =\r\n        d.name; var m = f(d.ngModel), h = m.assign; if (!h) throw D(\"ngModel\")(\"nonassign\", d.ngModel, ia(e)); this.$render = F; this.$isEmpty = function (a) { return y(a) || \"\" === a || null === a || a !== a }; var l = e.inheritedData(\"$formController\") || yb, n = 0, p = this.$error = {}; e.addClass(Oa); k(!0); this.$setValidity = function (a, c) { p[a] !== !c && (c ? (p[a] && n--, n || (k(!0), this.$valid = !0, this.$invalid = !1)) : (k(!1), this.$invalid = !0, this.$valid = !1, n++), p[a] = !c, k(c, a), l.$setValidity(a, c, this)) }; this.$setPristine = function () {\r\n            this.$dirty = !1; this.$pristine =\r\n            !0; g.removeClass(e, zb); g.addClass(e, Oa)\r\n        }; this.$setViewValue = function (d) { this.$viewValue = d; this.$pristine && (this.$dirty = !0, this.$pristine = !1, g.removeClass(e, Oa), g.addClass(e, zb), l.$setDirty()); r(this.$parsers, function (a) { d = a(d) }); this.$modelValue !== d && (this.$modelValue = d, h(a, d), r(this.$viewChangeListeners, function (a) { try { a() } catch (d) { c(d) } })) }; var q = this; a.$watch(function () {\r\n            var c = m(a); if (q.$modelValue !== c) {\r\n                var d = q.$formatters, e = d.length; for (q.$modelValue = c; e--;) c = d[e](c); q.$viewValue !== c && (q.$viewValue =\r\n                c, q.$render())\r\n            } return c\r\n        })\r\n    }], Gd = function () { return { require: [\"ngModel\", \"^?form\"], controller: We, link: function (a, c, d, e) { var f = e[0], g = e[1] || yb; g.$addControl(f); a.$on(\"$destroy\", function () { g.$removeControl(f) }) } } }, Id = ba({ require: \"ngModel\", link: function (a, c, d, e) { e.$viewChangeListeners.push(function () { a.$eval(d.ngChange) }) } }), kc = function () {\r\n        return {\r\n            require: \"?ngModel\", link: function (a, c, d, e) {\r\n                if (e) {\r\n                    d.required = !0; var f = function (a) {\r\n                        if (d.required && e.$isEmpty(a)) e.$setValidity(\"required\", !1); else return e.$setValidity(\"required\",\r\n                        !0), a\r\n                    }; e.$formatters.push(f); e.$parsers.unshift(f); d.$observe(\"required\", function () { f(e.$viewValue) })\r\n                }\r\n            }\r\n        }\r\n    }, Hd = function () { return { require: \"ngModel\", link: function (a, c, d, e) { var f = (a = /\\/(.*)\\//.exec(d.ngList)) && RegExp(a[1]) || d.ngList || \",\"; e.$parsers.push(function (a) { if (!y(a)) { var c = []; a && r(a.split(f), function (a) { a && c.push(aa(a)) }); return c } }); e.$formatters.push(function (a) { return I(a) ? a.join(\", \") : t }); e.$isEmpty = function (a) { return !a || !a.length } } } }, Xe = /^(true|false|\\d+)$/, Jd = function () {\r\n        return {\r\n            priority: 100,\r\n            compile: function (a, c) { return Xe.test(c.ngValue) ? function (a, c, f) { f.$set(\"value\", a.$eval(f.ngValue)) } : function (a, c, f) { a.$watch(f.ngValue, function (a) { f.$set(\"value\", a) }) } }\r\n        }\r\n    }, jd = ya({ compile: function (a) { a.addClass(\"ng-binding\"); return function (a, d, e) { d.data(\"$binding\", e.ngBind); a.$watch(e.ngBind, function (a) { d.text(a == t ? \"\" : a) }) } } }), ld = [\"$interpolate\", function (a) { return function (c, d, e) { c = a(d.attr(e.$attr.ngBindTemplate)); d.addClass(\"ng-binding\").data(\"$binding\", c); e.$observe(\"ngBindTemplate\", function (a) { d.text(a) }) } }],\r\n    kd = [\"$sce\", \"$parse\", function (a, c) { return { compile: function (d) { d.addClass(\"ng-binding\"); return function (d, f, g) { f.data(\"$binding\", g.ngBindHtml); var k = c(g.ngBindHtml); d.$watch(function () { return (k(d) || \"\").toString() }, function (c) { f.html(a.getTrustedHtml(k(d)) || \"\") }) } } } }], md = Yb(\"\", !0), od = Yb(\"Odd\", 0), nd = Yb(\"Even\", 1), pd = ya({ compile: function (a, c) { c.$set(\"ngCloak\", t); a.removeClass(\"ng-cloak\") } }), qd = [function () { return { scope: !0, controller: \"@\", priority: 500 } }], lc = {}, Ye = { blur: !0, focus: !0 }; r(\"click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste\".split(\" \"),\r\n    function (a) { var c = pa(\"ng-\" + a); lc[c] = [\"$parse\", \"$rootScope\", function (d, e) { return { compile: function (f, g) { var k = d(g[c]); return function (c, d) { d.on(a, function (d) { var f = function () { k(c, { $event: d }) }; Ye[a] && e.$$phase ? c.$evalAsync(f) : c.$apply(f) }) } } } }] }); var td = [\"$animate\", function (a) {\r\n        return {\r\n            transclude: \"element\", priority: 600, terminal: !0, restrict: \"A\", $$tlb: !0, link: function (c, d, e, f, g) {\r\n                var k, m, h; c.$watch(e.ngIf, function (f) {\r\n                    Ua(f) ? m || (m = c.$new(), g(m, function (c) {\r\n                        c[c.length++] = X.createComment(\" end ngIf: \" + e.ngIf +\r\n                        \" \"); k = { clone: c }; a.enter(c, d.parent(), d)\r\n                    })) : (h && (h.remove(), h = null), m && (m.$destroy(), m = null), k && (h = Eb(k.clone), a.leave(h, function () { h = null }), k = null))\r\n                })\r\n            }\r\n        }\r\n    }], ud = [\"$http\", \"$templateCache\", \"$anchorScroll\", \"$animate\", \"$sce\", function (a, c, d, e, f) {\r\n        return {\r\n            restrict: \"ECA\", priority: 400, terminal: !0, transclude: \"element\", controller: Va.noop, compile: function (g, k) {\r\n                var m = k.ngInclude || k.src, h = k.onload || \"\", l = k.autoscroll; return function (g, k, q, r, E) {\r\n                    var u = 0, t, v, R, w = function () {\r\n                        v && (v.remove(), v = null); t && (t.$destroy(), t = null);\r\n                        R && (e.leave(R, function () { v = null }), v = R, R = null)\r\n                    }; g.$watch(f.parseAsResourceUrl(m), function (f) { var m = function () { !z(l) || l && !g.$eval(l) || d() }, q = ++u; f ? (a.get(f, { cache: c }).success(function (a) { if (q === u) { var c = g.$new(); r.template = a; a = E(c, function (a) { w(); e.enter(a, null, k, m) }); t = c; R = a; t.$emit(\"$includeContentLoaded\"); g.$eval(h) } }).error(function () { q === u && w() }), g.$emit(\"$includeContentRequested\")) : (w(), r.template = null) })\r\n                }\r\n            }\r\n        }\r\n    }], Kd = [\"$compile\", function (a) {\r\n        return {\r\n            restrict: \"ECA\", priority: -400, require: \"ngInclude\",\r\n            link: function (c, d, e, f) { d.html(f.template); a(d.contents())(c) }\r\n        }\r\n    }], vd = ya({ priority: 450, compile: function () { return { pre: function (a, c, d) { a.$eval(d.ngInit) } } } }), wd = ya({ terminal: !0, priority: 1E3 }), xd = [\"$locale\", \"$interpolate\", function (a, c) {\r\n        var d = /{}/g; return {\r\n            restrict: \"EA\", link: function (e, f, g) {\r\n                var k = g.count, m = g.$attr.when && f.attr(g.$attr.when), h = g.offset || 0, l = e.$eval(m) || {}, n = {}, p = c.startSymbol(), q = c.endSymbol(), s = /^when(Minus)?(.+)$/; r(g, function (a, c) {\r\n                    s.test(c) && (l[M(c.replace(\"when\", \"\").replace(\"Minus\", \"-\"))] =\r\n                    f.attr(g.$attr[c]))\r\n                }); r(l, function (a, e) { n[e] = c(a.replace(d, p + k + \"-\" + h + q)) }); e.$watch(function () { var c = parseFloat(e.$eval(k)); if (isNaN(c)) return \"\"; c in l || (c = a.pluralCat(c - h)); return n[c](e, f, !0) }, function (a) { f.text(a) })\r\n            }\r\n        }\r\n    }], yd = [\"$parse\", \"$animate\", function (a, c) {\r\n        var d = D(\"ngRepeat\"); return {\r\n            transclude: \"element\", priority: 1E3, terminal: !0, $$tlb: !0, link: function (e, f, g, k, m) {\r\n                var h = g.ngRepeat, l = h.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/), n, p, q, s, t, u, B = { $id: Ka }; if (!l) throw d(\"iexp\",\r\n                h); g = l[1]; k = l[2]; (l = l[3]) ? (n = a(l), p = function (a, c, d) { u && (B[u] = a); B[t] = c; B.$index = d; return n(e, B) }) : (q = function (a, c) { return Ka(c) }, s = function (a) { return a }); l = g.match(/^(?:([\\$\\w]+)|\\(([\\$\\w]+)\\s*,\\s*([\\$\\w]+)\\))$/); if (!l) throw d(\"iidexp\", g); t = l[3] || l[1]; u = l[2]; var z = {}; e.$watchCollection(k, function (a) {\r\n                    var g, k, l = f[0], n, B = {}, C, x, H, A, F, D, y, I = []; if (Pa(a)) D = a, F = p || q; else { F = p || s; D = []; for (H in a) a.hasOwnProperty(H) && \"$\" != H.charAt(0) && D.push(H); D.sort() } C = D.length; k = I.length = D.length; for (g = 0; g < k; g++) if (H = a ===\r\n                    D ? g : D[g], A = a[H], n = F(H, A, g), Da(n, \"`track by` id\"), z.hasOwnProperty(n)) y = z[n], delete z[n], B[n] = y, I[g] = y; else { if (B.hasOwnProperty(n)) throw r(I, function (a) { a && a.scope && (z[a.id] = a) }), d(\"dupes\", h, n, na(A)); I[g] = { id: n }; B[n] = !1 } for (H in z) z.hasOwnProperty(H) && (y = z[H], g = Eb(y.clone), c.leave(g), r(g, function (a) { a.$$NG_REMOVED = !0 }), y.scope.$destroy()); g = 0; for (k = D.length; g < k; g++) {\r\n                        H = a === D ? g : D[g]; A = a[H]; y = I[g]; I[g - 1] && (l = I[g - 1].clone[I[g - 1].clone.length - 1]); if (y.scope) {\r\n                            x = y.scope; n = l; do n = n.nextSibling; while (n && n.$$NG_REMOVED);\r\n                            y.clone[0] != n && c.move(Eb(y.clone), null, v(l)); l = y.clone[y.clone.length - 1]\r\n                        } else x = e.$new(); x[t] = A; u && (x[u] = H); x.$index = g; x.$first = 0 === g; x.$last = g === C - 1; x.$middle = !(x.$first || x.$last); x.$odd = !(x.$even = 0 === (g & 1)); y.scope || m(x, function (a) { a[a.length++] = X.createComment(\" end ngRepeat: \" + h + \" \"); c.enter(a, null, v(l)); l = a; y.scope = x; y.clone = a; B[y.id] = y })\r\n                    } z = B\r\n                })\r\n            }\r\n        }\r\n    }], zd = [\"$animate\", function (a) { return function (c, d, e) { c.$watch(e.ngShow, function (c) { a[Ua(c) ? \"removeClass\" : \"addClass\"](d, \"ng-hide\") }) } }], sd = [\"$animate\",\r\n    function (a) { return function (c, d, e) { c.$watch(e.ngHide, function (c) { a[Ua(c) ? \"addClass\" : \"removeClass\"](d, \"ng-hide\") }) } }], Ad = ya(function (a, c, d) { a.$watch(d.ngStyle, function (a, d) { d && a !== d && r(d, function (a, d) { c.css(d, \"\") }); a && c.css(a) }, !0) }), Bd = [\"$animate\", function (a) {\r\n        return {\r\n            restrict: \"EA\", require: \"ngSwitch\", controller: [\"$scope\", function () { this.cases = {} }], link: function (c, d, e, f) {\r\n                var g = [], k = [], m = [], h = []; c.$watch(e.ngSwitch || e.on, function (d) {\r\n                    var n, p; n = 0; for (p = m.length; n < p; ++n) m[n].remove(); n = m.length = 0; for (p =\r\n                    h.length; n < p; ++n) { var q = k[n]; h[n].$destroy(); m[n] = q; a.leave(q, function () { m.splice(n, 1) }) } k.length = 0; h.length = 0; if (g = f.cases[\"!\" + d] || f.cases[\"?\"]) c.$eval(e.change), r(g, function (d) { var e = c.$new(); h.push(e); d.transclude(e, function (c) { var e = d.element; k.push(c); a.enter(c, e.parent(), e) }) })\r\n                })\r\n            }\r\n        }\r\n    }], Cd = ya({ transclude: \"element\", priority: 800, require: \"^ngSwitch\", link: function (a, c, d, e, f) { e.cases[\"!\" + d.ngSwitchWhen] = e.cases[\"!\" + d.ngSwitchWhen] || []; e.cases[\"!\" + d.ngSwitchWhen].push({ transclude: f, element: c }) } }), Dd =\r\n    ya({ transclude: \"element\", priority: 800, require: \"^ngSwitch\", link: function (a, c, d, e, f) { e.cases[\"?\"] = e.cases[\"?\"] || []; e.cases[\"?\"].push({ transclude: f, element: c }) } }), Fd = ya({ link: function (a, c, d, e, f) { if (!f) throw D(\"ngTransclude\")(\"orphan\", ia(c)); f(function (a) { c.empty(); c.append(a) }) } }), fd = [\"$templateCache\", function (a) { return { restrict: \"E\", terminal: !0, compile: function (c, d) { \"text/ng-template\" == d.type && a.put(d.id, c[0].text) } } }], Ze = D(\"ngOptions\"), Ed = ba({ terminal: !0 }), gd = [\"$compile\", \"$parse\", function (a, c) {\r\n        var d =\r\n        /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+group\\s+by\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?$/, e = { $setViewValue: F }; return {\r\n            restrict: \"E\", require: [\"select\", \"?ngModel\"], controller: [\"$element\", \"$scope\", \"$attrs\", function (a, c, d) {\r\n                var m = this, h = {}, l = e, n; m.databound = d.ngModel; m.init = function (a, c, d) { l = a; n = d }; m.addOption = function (c) { Da(c, '\"option value\"'); h[c] = !0; l.$viewValue == c && (a.val(c), n.parent() && n.remove()) };\r\n                m.removeOption = function (a) { this.hasOption(a) && (delete h[a], l.$viewValue == a && this.renderUnknownOption(a)) }; m.renderUnknownOption = function (c) { c = \"? \" + Ka(c) + \" ?\"; n.val(c); a.prepend(n); a.val(c); n.prop(\"selected\", !0) }; m.hasOption = function (a) { return h.hasOwnProperty(a) }; c.$on(\"$destroy\", function () { m.renderUnknownOption = F })\r\n            }], link: function (e, g, k, m) {\r\n                function h(a, c, d, e) {\r\n                    d.$render = function () { var a = d.$viewValue; e.hasOption(a) ? (A.parent() && A.remove(), c.val(a), \"\" === a && u.prop(\"selected\", !0)) : y(a) && u ? c.val(\"\") : e.renderUnknownOption(a) };\r\n                    c.on(\"change\", function () { a.$apply(function () { A.parent() && A.remove(); d.$setViewValue(c.val()) }) })\r\n                } function l(a, c, d) { var e; d.$render = function () { var a = new bb(d.$viewValue); r(c.find(\"option\"), function (c) { c.selected = z(a.get(c.value)) }) }; a.$watch(function () { Aa(e, d.$viewValue) || (e = ha(d.$viewValue), d.$render()) }); c.on(\"change\", function () { a.$apply(function () { var a = []; r(c.find(\"option\"), function (c) { c.selected && a.push(c.value) }); d.$setViewValue(a) }) }) } function n(e, f, g) {\r\n                    function k() {\r\n                        var a = { \"\": [] }, c = [\"\"], d, h,\r\n                        s, t, w; s = g.$modelValue; t = u(e) || []; var A = n ? Zb(t) : t, F, L, x; L = {}; x = !1; if (q) if (h = g.$modelValue, v && I(h)) for (x = new bb([]), d = {}, w = 0; w < h.length; w++) d[m] = h[w], x.put(v(e, d), h[w]); else x = new bb(h); w = x; var C, J; for (x = 0; F = A.length, x < F; x++) { h = x; if (n) { h = A[x]; if (\"$\" === h.charAt(0)) continue; L[n] = h } L[m] = t[h]; d = p(e, L) || \"\"; (h = a[d]) || (h = a[d] = [], c.push(d)); q ? d = z(w.remove(v ? v(e, L) : r(e, L))) : (v ? (d = {}, d[m] = s, d = v(e, d) === v(e, L)) : d = s === r(e, L), w = w || d); C = l(e, L); C = z(C) ? C : \"\"; h.push({ id: v ? v(e, L) : n ? A[x] : x, label: C, selected: d }) } q || (E || null ===\r\n                        s ? a[\"\"].unshift({ id: \"\", label: \"\", selected: !w }) : w || a[\"\"].unshift({ id: \"?\", label: \"\", selected: !0 })); L = 0; for (A = c.length; L < A; L++) {\r\n                            d = c[L]; h = a[d]; y.length <= L ? (s = { element: D.clone().attr(\"label\", d), label: h.label }, t = [s], y.push(t), f.append(s.element)) : (t = y[L], s = t[0], s.label != d && s.element.attr(\"label\", s.label = d)); C = null; x = 0; for (F = h.length; x < F; x++) d = h[x], (w = t[x + 1]) ? (C = w.element, w.label !== d.label && C.text(w.label = d.label), w.id !== d.id && C.val(w.id = d.id), C[0].selected !== d.selected && (C.prop(\"selected\", w.selected = d.selected),\r\n                            Q && C.prop(\"selected\", w.selected))) : (\"\" === d.id && E ? J = E : (J = B.clone()).val(d.id).prop(\"selected\", d.selected).attr(\"selected\", d.selected).text(d.label), t.push({ element: J, label: d.label, id: d.id, selected: d.selected }), C ? C.after(J) : s.element.append(J), C = J); for (x++; t.length > x;) t.pop().element.remove()\r\n                        } for (; y.length > L;) y.pop()[0].element.remove()\r\n                    } var h; if (!(h = s.match(d))) throw Ze(\"iexp\", s, ia(f)); var l = c(h[2] || h[1]), m = h[4] || h[6], n = h[5], p = c(h[3] || \"\"), r = c(h[2] ? h[1] : m), u = c(h[7]), v = h[8] ? c(h[8]) : null, y = [[{\r\n                        element: f,\r\n                        label: \"\"\r\n                    }]]; E && (a(E)(e), E.removeClass(\"ng-scope\"), E.remove()); f.empty(); f.on(\"change\", function () {\r\n                        e.$apply(function () {\r\n                            var a, c = u(e) || [], d = {}, h, l, p, s, w, z, x; if (q) for (l = [], s = 0, z = y.length; s < z; s++) for (a = y[s], p = 1, w = a.length; p < w; p++) { if ((h = a[p].element)[0].selected) { h = h.val(); n && (d[n] = h); if (v) for (x = 0; x < c.length && (d[m] = c[x], v(e, d) != h) ; x++); else d[m] = c[h]; l.push(r(e, d)) } } else if (h = f.val(), \"?\" == h) l = t; else if (\"\" === h) l = null; else if (v) for (x = 0; x < c.length; x++) { if (d[m] = c[x], v(e, d) == h) { l = r(e, d); break } } else d[m] = c[h],\r\n                            n && (d[n] = h), l = r(e, d); g.$setViewValue(l); k()\r\n                        })\r\n                    }); g.$render = k; e.$watchCollection(u, k); e.$watchCollection(function () { var a = {}, c = u(e); if (c) { for (var d = Array(c.length), f = 0, g = c.length; f < g; f++) a[m] = c[f], d[f] = l(e, a); return d } }, k); q && e.$watchCollection(function () { return g.$modelValue }, k)\r\n                } if (m[1]) {\r\n                    var p = m[0]; m = m[1]; var q = k.multiple, s = k.ngOptions, E = !1, u, B = v(X.createElement(\"option\")), D = v(X.createElement(\"optgroup\")), A = B.clone(); k = 0; for (var w = g.children(), F = w.length; k < F; k++) if (\"\" === w[k].value) { u = E = w.eq(k); break } p.init(m,\r\n                    E, A); q && (m.$isEmpty = function (a) { return !a || 0 === a.length }); s ? n(e, g, m) : q ? l(e, g, m) : h(e, g, m, p)\r\n                }\r\n            }\r\n        }\r\n    }], id = [\"$interpolate\", function (a) {\r\n        var c = { addOption: F, removeOption: F }; return {\r\n            restrict: \"E\", priority: 100, compile: function (d, e) {\r\n                if (y(e.value)) { var f = a(d.text(), !0); f || e.$set(\"value\", d.text()) } return function (a, d, e) {\r\n                    var h = d.parent(), l = h.data(\"$selectController\") || h.parent().data(\"$selectController\"); l && l.databound ? d.prop(\"selected\", !1) : l = c; f ? a.$watch(f, function (a, c) { e.$set(\"value\", a); a !== c && l.removeOption(c); l.addOption(a) }) :\r\n                    l.addOption(e.value); d.on(\"$destroy\", function () { l.removeOption(e.value) })\r\n                }\r\n            }\r\n        }\r\n    }], hd = ba({ restrict: \"E\", terminal: !0 }); W.angular.bootstrap ? console.log(\"WARNING: Tried to load angular more than once.\") : ((Ea = W.jQuery) && Ea.fn.on ? (v = Ea, J(Ea.fn, { scope: La.scope, isolateScope: La.isolateScope, controller: La.controller, injector: La.injector, inheritedData: La.inheritedData }), Gb(\"remove\", !0, !0, !1), Gb(\"empty\", !1, !1, !1), Gb(\"html\", !1, !1, !0)) : v = S, Va.element = v, $c(Va), v(X).ready(function () { Xc(X, fc) }))\r\n})(window, document);\r\n!window.angular.$$csp() && window.angular.element(document).find(\"head\").prepend('<style type=\"text/css\">@charset \"UTF-8\";[ng\\\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\\\:form{display:block;}.ng-animate-block-transitions{transition:0s all!important;-webkit-transition:0s all!important;}.ng-hide-add-active,.ng-hide-remove{display:block!important;}</style>');\r\n//# sourceMappingURL=angular.min.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./libraries/angular/angular.min.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\r\n * State-based routing for AngularJS\r\n * @version v0.2.18\r\n * @link http://angular-ui.github.com/\r\n * @license MIT License, http://www.opensource.org/licenses/MIT\r\n */\r\n\r\n/* commonjs package manager support (eg componentjs) */\r\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports) {\r\n    module.exports = 'ui.router';\r\n}\r\n\r\n(function (window, angular, undefined) {\r\n    /*jshint globalstrict:true*/\r\n    /*global angular:false*/\r\n    'use strict';\r\n\r\n    var isDefined = angular.isDefined,\r\n        isFunction = angular.isFunction,\r\n        isString = angular.isString,\r\n        isObject = angular.isObject,\r\n        isArray = angular.isArray,\r\n        forEach = angular.forEach,\r\n        extend = angular.extend,\r\n        copy = angular.copy,\r\n        toJson = angular.toJson;\r\n\r\n    function inherit(parent, extra) {\r\n        return extend(new (extend(function () { }, { prototype: parent }))(), extra);\r\n    }\r\n\r\n    function merge(dst) {\r\n        forEach(arguments, function (obj) {\r\n            if (obj !== dst) {\r\n                forEach(obj, function (value, key) {\r\n                    if (!dst.hasOwnProperty(key)) dst[key] = value;\r\n                });\r\n            }\r\n        });\r\n        return dst;\r\n    }\r\n\r\n    /**\r\n     * Finds the common ancestor path between two states.\r\n     *\r\n     * @param {Object} first The first state.\r\n     * @param {Object} second The second state.\r\n     * @return {Array} Returns an array of state names in descending order, not including the root.\r\n     */\r\n    function ancestors(first, second) {\r\n        var path = [];\r\n\r\n        for (var n in first.path) {\r\n            if (first.path[n] !== second.path[n]) break;\r\n            path.push(first.path[n]);\r\n        }\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * IE8-safe wrapper for `Object.keys()`.\r\n     *\r\n     * @param {Object} object A JavaScript object.\r\n     * @return {Array} Returns the keys of the object as an array.\r\n     */\r\n    function objectKeys(object) {\r\n        if (Object.keys) {\r\n            return Object.keys(object);\r\n        }\r\n        var result = [];\r\n\r\n        forEach(object, function (val, key) {\r\n            result.push(key);\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * IE8-safe wrapper for `Array.prototype.indexOf()`.\r\n     *\r\n     * @param {Array} array A JavaScript array.\r\n     * @param {*} value A value to search the array for.\r\n     * @return {Number} Returns the array index value of `value`, or `-1` if not present.\r\n     */\r\n    function indexOf(array, value) {\r\n        if (Array.prototype.indexOf) {\r\n            return array.indexOf(value, Number(arguments[2]) || 0);\r\n        }\r\n        var len = array.length >>> 0, from = Number(arguments[2]) || 0;\r\n        from = (from < 0) ? Math.ceil(from) : Math.floor(from);\r\n\r\n        if (from < 0) from += len;\r\n\r\n        for (; from < len; from++) {\r\n            if (from in array && array[from] === value) return from;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Merges a set of parameters with all parameters inherited between the common parents of the\r\n     * current state and a given destination state.\r\n     *\r\n     * @param {Object} currentParams The value of the current state parameters ($stateParams).\r\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\r\n     * @param {Object} $current Internal definition of object representing the current state.\r\n     * @param {Object} $to Internal definition of object representing state to transition to.\r\n     */\r\n    function inheritParams(currentParams, newParams, $current, $to) {\r\n        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\r\n\r\n        for (var i in parents) {\r\n            if (!parents[i] || !parents[i].params) continue;\r\n            parentParams = objectKeys(parents[i].params);\r\n            if (!parentParams.length) continue;\r\n\r\n            for (var j in parentParams) {\r\n                if (indexOf(inheritList, parentParams[j]) >= 0) continue;\r\n                inheritList.push(parentParams[j]);\r\n                inherited[parentParams[j]] = currentParams[parentParams[j]];\r\n            }\r\n        }\r\n        return extend({}, inherited, newParams);\r\n    }\r\n\r\n    /**\r\n     * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\r\n     *\r\n     * @param {Object} a The first object.\r\n     * @param {Object} b The second object.\r\n     * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\r\n     *                     it defaults to the list of keys in `a`.\r\n     * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\r\n     */\r\n    function equalForKeys(a, b, keys) {\r\n        if (!keys) {\r\n            keys = [];\r\n            for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\r\n        }\r\n\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var k = keys[i];\r\n            if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the subset of an object, based on a list of keys.\r\n     *\r\n     * @param {Array} keys\r\n     * @param {Object} values\r\n     * @return {Boolean} Returns a subset of `values`.\r\n     */\r\n    function filterByKeys(keys, values) {\r\n        var filtered = {};\r\n\r\n        forEach(keys, function (name) {\r\n            filtered[name] = values[name];\r\n        });\r\n        return filtered;\r\n    }\r\n\r\n    // like _.indexBy\r\n    // when you know that your index values will be unique, or you want last-one-in to win\r\n    function indexBy(array, propName) {\r\n        var result = {};\r\n        forEach(array, function (item) {\r\n            result[item[propName]] = item;\r\n        });\r\n        return result;\r\n    }\r\n\r\n    // extracted from underscore.js\r\n    // Return a copy of the object only containing the whitelisted properties.\r\n    function pick(obj) {\r\n        var copy = {};\r\n        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\r\n        forEach(keys, function (key) {\r\n            if (key in obj) copy[key] = obj[key];\r\n        });\r\n        return copy;\r\n    }\r\n\r\n    // extracted from underscore.js\r\n    // Return a copy of the object omitting the blacklisted properties.\r\n    function omit(obj) {\r\n        var copy = {};\r\n        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\r\n        for (var key in obj) {\r\n            if (indexOf(keys, key) == -1) copy[key] = obj[key];\r\n        }\r\n        return copy;\r\n    }\r\n\r\n    function pluck(collection, key) {\r\n        var result = isArray(collection) ? [] : {};\r\n\r\n        forEach(collection, function (val, i) {\r\n            result[i] = isFunction(key) ? key(val) : val[key];\r\n        });\r\n        return result;\r\n    }\r\n\r\n    function filter(collection, callback) {\r\n        var array = isArray(collection);\r\n        var result = array ? [] : {};\r\n        forEach(collection, function (val, i) {\r\n            if (callback(val, i)) {\r\n                result[array ? result.length : i] = val;\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    function map(collection, callback) {\r\n        var result = isArray(collection) ? [] : {};\r\n\r\n        forEach(collection, function (val, i) {\r\n            result[i] = callback(val, i);\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @ngdoc overview\r\n     * @name ui.router.util\r\n     *\r\n     * @description\r\n     * # ui.router.util sub-module\r\n     *\r\n     * This module is a dependency of other sub-modules. Do not include this module as a dependency\r\n     * in your angular app (use {@link ui.router} module instead).\r\n     *\r\n     */\r\n    angular.module('ui.router.util', ['ng']);\r\n\r\n    /**\r\n     * @ngdoc overview\r\n     * @name ui.router.router\r\n     * \r\n     * @requires ui.router.util\r\n     *\r\n     * @description\r\n     * # ui.router.router sub-module\r\n     *\r\n     * This module is a dependency of other sub-modules. Do not include this module as a dependency\r\n     * in your angular app (use {@link ui.router} module instead).\r\n     */\r\n    angular.module('ui.router.router', ['ui.router.util']);\r\n\r\n    /**\r\n     * @ngdoc overview\r\n     * @name ui.router.state\r\n     * \r\n     * @requires ui.router.router\r\n     * @requires ui.router.util\r\n     *\r\n     * @description\r\n     * # ui.router.state sub-module\r\n     *\r\n     * This module is a dependency of the main ui.router module. Do not include this module as a dependency\r\n     * in your angular app (use {@link ui.router} module instead).\r\n     * \r\n     */\r\n    angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\r\n\r\n    /**\r\n     * @ngdoc overview\r\n     * @name ui.router\r\n     *\r\n     * @requires ui.router.state\r\n     *\r\n     * @description\r\n     * # ui.router\r\n     * \r\n     * ## The main module for ui.router \r\n     * There are several sub-modules included with the ui.router module, however only this module is needed\r\n     * as a dependency within your angular app. The other modules are for organization purposes. \r\n     *\r\n     * The modules are:\r\n     * * ui.router - the main \"umbrella\" module\r\n     * * ui.router.router - \r\n     * \r\n     * *You'll need to include **only** this module as the dependency within your angular app.*\r\n     * \r\n     * <pre>\r\n     * <!doctype html>\r\n     * <html ng-app=\"myApp\">\r\n     * <head>\r\n     *   <script src=\"js/angular.js\"></script>\r\n     *   <!-- Include the ui-router script -->\r\n     *   <script src=\"js/angular-ui-router.min.js\"></script>\r\n     *   <script>\r\n     *     // ...and add 'ui.router' as a dependency\r\n     *     var myApp = angular.module('myApp', ['ui.router']);\r\n     *   </script>\r\n     * </head>\r\n     * <body>\r\n     * </body>\r\n     * </html>\r\n     * </pre>\r\n     */\r\n    angular.module('ui.router', ['ui.router.state']);\r\n\r\n    angular.module('ui.router.compat', ['ui.router']);\r\n\r\n    /**\r\n     * @ngdoc object\r\n     * @name ui.router.util.$resolve\r\n     *\r\n     * @requires $q\r\n     * @requires $injector\r\n     *\r\n     * @description\r\n     * Manages resolution of (acyclic) graphs of promises.\r\n     */\r\n    $Resolve.$inject = ['$q', '$injector'];\r\n    function $Resolve($q, $injector) {\r\n\r\n        var VISIT_IN_PROGRESS = 1,\r\n            VISIT_DONE = 2,\r\n            NOTHING = {},\r\n            NO_DEPENDENCIES = [],\r\n            NO_LOCALS = NOTHING,\r\n            NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\r\n\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$resolve#study\r\n         * @methodOf ui.router.util.$resolve\r\n         *\r\n         * @description\r\n         * Studies a set of invocables that are likely to be used multiple times.\r\n         * <pre>\r\n         * $resolve.study(invocables)(locals, parent, self)\r\n         * </pre>\r\n         * is equivalent to\r\n         * <pre>\r\n         * $resolve.resolve(invocables, locals, parent, self)\r\n         * </pre>\r\n         * but the former is more efficient (in fact `resolve` just calls `study` \r\n         * internally).\r\n         *\r\n         * @param {object} invocables Invocable objects\r\n         * @return {function} a function to pass in locals, parent and self\r\n         */\r\n        this.study = function (invocables) {\r\n            if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\r\n            var invocableKeys = objectKeys(invocables || {});\r\n\r\n            // Perform a topological sort of invocables to build an ordered plan\r\n            var plan = [], cycle = [], visited = {};\r\n            function visit(value, key) {\r\n                if (visited[key] === VISIT_DONE) return;\r\n\r\n                cycle.push(key);\r\n                if (visited[key] === VISIT_IN_PROGRESS) {\r\n                    cycle.splice(0, indexOf(cycle, key));\r\n                    throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\r\n                }\r\n                visited[key] = VISIT_IN_PROGRESS;\r\n\r\n                if (isString(value)) {\r\n                    plan.push(key, [function () { return $injector.get(value); }], NO_DEPENDENCIES);\r\n                } else {\r\n                    var params = $injector.annotate(value);\r\n                    forEach(params, function (param) {\r\n                        if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\r\n                    });\r\n                    plan.push(key, value, params);\r\n                }\r\n\r\n                cycle.pop();\r\n                visited[key] = VISIT_DONE;\r\n            }\r\n            forEach(invocables, visit);\r\n            invocables = cycle = visited = null; // plan is all that's required\r\n\r\n            function isResolve(value) {\r\n                return isObject(value) && value.then && value.$$promises;\r\n            }\r\n\r\n            return function (locals, parent, self) {\r\n                if (isResolve(locals) && self === undefined) {\r\n                    self = parent; parent = locals; locals = null;\r\n                }\r\n                if (!locals) locals = NO_LOCALS;\r\n                else if (!isObject(locals)) {\r\n                    throw new Error(\"'locals' must be an object\");\r\n                }\r\n                if (!parent) parent = NO_PARENT;\r\n                else if (!isResolve(parent)) {\r\n                    throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\r\n                }\r\n\r\n                // To complete the overall resolution, we have to wait for the parent\r\n                // promise and for the promise for each invokable in our plan.\r\n                var resolution = $q.defer(),\r\n                    result = resolution.promise,\r\n                    promises = result.$$promises = {},\r\n                    values = extend({}, locals),\r\n                    wait = 1 + plan.length / 3,\r\n                    merged = false;\r\n\r\n                function done() {\r\n                    // Merge parent values we haven't got yet and publish our own $$values\r\n                    if (!--wait) {\r\n                        if (!merged) merge(values, parent.$$values);\r\n                        result.$$values = values;\r\n                        result.$$promises = result.$$promises || true; // keep for isResolve()\r\n                        delete result.$$inheritedValues;\r\n                        resolution.resolve(values);\r\n                    }\r\n                }\r\n\r\n                function fail(reason) {\r\n                    result.$$failure = reason;\r\n                    resolution.reject(reason);\r\n                }\r\n\r\n                // Short-circuit if parent has already failed\r\n                if (isDefined(parent.$$failure)) {\r\n                    fail(parent.$$failure);\r\n                    return result;\r\n                }\r\n\r\n                if (parent.$$inheritedValues) {\r\n                    merge(values, omit(parent.$$inheritedValues, invocableKeys));\r\n                }\r\n\r\n                // Merge parent values if the parent has already resolved, or merge\r\n                // parent promises and wait if the parent resolve is still in progress.\r\n                extend(promises, parent.$$promises);\r\n                if (parent.$$values) {\r\n                    merged = merge(values, omit(parent.$$values, invocableKeys));\r\n                    result.$$inheritedValues = omit(parent.$$values, invocableKeys);\r\n                    done();\r\n                } else {\r\n                    if (parent.$$inheritedValues) {\r\n                        result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\r\n                    }\r\n                    parent.then(done, fail);\r\n                }\r\n\r\n                // Process each invocable in the plan, but ignore any where a local of the same name exists.\r\n                for (var i = 0, ii = plan.length; i < ii; i += 3) {\r\n                    if (locals.hasOwnProperty(plan[i])) done();\r\n                    else invoke(plan[i], plan[i + 1], plan[i + 2]);\r\n                }\r\n\r\n                function invoke(key, invocable, params) {\r\n                    // Create a deferred for this invocation. Failures will propagate to the resolution as well.\r\n                    var invocation = $q.defer(), waitParams = 0;\r\n                    function onfailure(reason) {\r\n                        invocation.reject(reason);\r\n                        fail(reason);\r\n                    }\r\n                    // Wait for any parameter that we have a promise for (either from parent or from this\r\n                    // resolve; in that case study() will have made sure it's ordered before us in the plan).\r\n                    forEach(params, function (dep) {\r\n                        if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\r\n                            waitParams++;\r\n                            promises[dep].then(function (result) {\r\n                                values[dep] = result;\r\n                                if (!(--waitParams)) proceed();\r\n                            }, onfailure);\r\n                        }\r\n                    });\r\n                    if (!waitParams) proceed();\r\n                    function proceed() {\r\n                        if (isDefined(result.$$failure)) return;\r\n                        try {\r\n                            invocation.resolve($injector.invoke(invocable, self, values));\r\n                            invocation.promise.then(function (result) {\r\n                                values[key] = result;\r\n                                done();\r\n                            }, onfailure);\r\n                        } catch (e) {\r\n                            onfailure(e);\r\n                        }\r\n                    }\r\n                    // Publish promise synchronously; invocations further down in the plan may depend on it.\r\n                    promises[key] = invocation.promise;\r\n                }\r\n\r\n                return result;\r\n            };\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$resolve#resolve\r\n         * @methodOf ui.router.util.$resolve\r\n         *\r\n         * @description\r\n         * Resolves a set of invocables. An invocable is a function to be invoked via \r\n         * `$injector.invoke()`, and can have an arbitrary number of dependencies. \r\n         * An invocable can either return a value directly,\r\n         * or a `$q` promise. If a promise is returned it will be resolved and the \r\n         * resulting value will be used instead. Dependencies of invocables are resolved \r\n         * (in this order of precedence)\r\n         *\r\n         * - from the specified `locals`\r\n         * - from another invocable that is part of this `$resolve` call\r\n         * - from an invocable that is inherited from a `parent` call to `$resolve` \r\n         *   (or recursively\r\n         * - from any ancestor `$resolve` of that parent).\r\n         *\r\n         * The return value of `$resolve` is a promise for an object that contains \r\n         * (in this order of precedence)\r\n         *\r\n         * - any `locals` (if specified)\r\n         * - the resolved return values of all injectables\r\n         * - any values inherited from a `parent` call to `$resolve` (if specified)\r\n         *\r\n         * The promise will resolve after the `parent` promise (if any) and all promises \r\n         * returned by injectables have been resolved. If any invocable \r\n         * (or `$injector.invoke`) throws an exception, or if a promise returned by an \r\n         * invocable is rejected, the `$resolve` promise is immediately rejected with the \r\n         * same error. A rejection of a `parent` promise (if specified) will likewise be \r\n         * propagated immediately. Once the `$resolve` promise has been rejected, no \r\n         * further invocables will be called.\r\n         * \r\n         * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\r\n         * to throw an error. As a special case, an injectable can depend on a parameter \r\n         * with the same name as the injectable, which will be fulfilled from the `parent` \r\n         * injectable of the same name. This allows inherited values to be decorated. \r\n         * Note that in this case any other injectable in the same `$resolve` with the same\r\n         * dependency would see the decorated value, not the inherited value.\r\n         *\r\n         * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \r\n         * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \r\n         * exception.\r\n         *\r\n         * Invocables are invoked eagerly as soon as all dependencies are available. \r\n         * This is true even for dependencies inherited from a `parent` call to `$resolve`.\r\n         *\r\n         * As a special case, an invocable can be a string, in which case it is taken to \r\n         * be a service name to be passed to `$injector.get()`. This is supported primarily \r\n         * for backwards-compatibility with the `resolve` property of `$routeProvider` \r\n         * routes.\r\n         *\r\n         * @param {object} invocables functions to invoke or \r\n         * `$injector` services to fetch.\r\n         * @param {object} locals  values to make available to the injectables\r\n         * @param {object} parent  a promise returned by another call to `$resolve`.\r\n         * @param {object} self  the `this` for the invoked methods\r\n         * @return {object} Promise for an object that contains the resolved return value\r\n         * of all invocables, as well as any inherited and local values.\r\n         */\r\n        this.resolve = function (invocables, locals, parent, self) {\r\n            return this.study(invocables)(locals, parent, self);\r\n        };\r\n    }\r\n\r\n    angular.module('ui.router.util').service('$resolve', $Resolve);\r\n\r\n\r\n    /**\r\n     * @ngdoc object\r\n     * @name ui.router.util.$templateFactory\r\n     *\r\n     * @requires $http\r\n     * @requires $templateCache\r\n     * @requires $injector\r\n     *\r\n     * @description\r\n     * Service. Manages loading of templates.\r\n     */\r\n    $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\r\n    function $TemplateFactory($http, $templateCache, $injector) {\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$templateFactory#fromConfig\r\n         * @methodOf ui.router.util.$templateFactory\r\n         *\r\n         * @description\r\n         * Creates a template from a configuration object. \r\n         *\r\n         * @param {object} config Configuration object for which to load a template. \r\n         * The following properties are search in the specified order, and the first one \r\n         * that is defined is used to create the template:\r\n         *\r\n         * @param {string|object} config.template html string template or function to \r\n         * load via {@link ui.router.util.$templateFactory#fromString fromString}.\r\n         * @param {string|object} config.templateUrl url to load or a function returning \r\n         * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\r\n         * @param {Function} config.templateProvider function to invoke via \r\n         * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\r\n         * @param {object} params  Parameters to pass to the template function.\r\n         * @param {object} locals Locals to pass to `invoke` if the template is loaded \r\n         * via a `templateProvider`. Defaults to `{ params: params }`.\r\n         *\r\n         * @return {string|object}  The template html as a string, or a promise for \r\n         * that string,or `null` if no template is configured.\r\n         */\r\n        this.fromConfig = function (config, params, locals) {\r\n            return (\r\n              isDefined(config.template) ? this.fromString(config.template, params) :\r\n              isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\r\n              isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\r\n              null\r\n            );\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$templateFactory#fromString\r\n         * @methodOf ui.router.util.$templateFactory\r\n         *\r\n         * @description\r\n         * Creates a template from a string or a function returning a string.\r\n         *\r\n         * @param {string|object} template html template as a string or function that \r\n         * returns an html template as a string.\r\n         * @param {object} params Parameters to pass to the template function.\r\n         *\r\n         * @return {string|object} The template html as a string, or a promise for that \r\n         * string.\r\n         */\r\n        this.fromString = function (template, params) {\r\n            return isFunction(template) ? template(params) : template;\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$templateFactory#fromUrl\r\n         * @methodOf ui.router.util.$templateFactory\r\n         * \r\n         * @description\r\n         * Loads a template from the a URL via `$http` and `$templateCache`.\r\n         *\r\n         * @param {string|Function} url url of the template to load, or a function \r\n         * that returns a url.\r\n         * @param {Object} params Parameters to pass to the url function.\r\n         * @return {string|Promise.<string>} The template html as a string, or a promise \r\n         * for that string.\r\n         */\r\n        this.fromUrl = function (url, params) {\r\n            if (isFunction(url)) url = url(params);\r\n            if (url == null) return null;\r\n            else return $http\r\n                .get(url, { cache: $templateCache, headers: { Accept: 'text/html' } })\r\n                .then(function (response) { return response.data; });\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$templateFactory#fromProvider\r\n         * @methodOf ui.router.util.$templateFactory\r\n         *\r\n         * @description\r\n         * Creates a template by invoking an injectable provider function.\r\n         *\r\n         * @param {Function} provider Function to invoke via `$injector.invoke`\r\n         * @param {Object} params Parameters for the template.\r\n         * @param {Object} locals Locals to pass to `invoke`. Defaults to \r\n         * `{ params: params }`.\r\n         * @return {string|Promise.<string>} The template html as a string, or a promise \r\n         * for that string.\r\n         */\r\n        this.fromProvider = function (provider, params, locals) {\r\n            return $injector.invoke(provider, null, locals || { params: params });\r\n        };\r\n    }\r\n\r\n    angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\r\n\r\n    var $$UMFP; // reference to $UrlMatcherFactoryProvider\r\n\r\n    /**\r\n     * @ngdoc object\r\n     * @name ui.router.util.type:UrlMatcher\r\n     *\r\n     * @description\r\n     * Matches URLs against patterns and extracts named parameters from the path or the search\r\n     * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\r\n     * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\r\n     * do not influence whether or not a URL is matched, but their values are passed through into\r\n     * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\r\n     *\r\n     * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\r\n     * syntax, which optionally allows a regular expression for the parameter to be specified:\r\n     *\r\n     * * `':'` name - colon placeholder\r\n     * * `'*'` name - catch-all placeholder\r\n     * * `'{' name '}'` - curly placeholder\r\n     * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\r\n     *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\r\n     *\r\n     * Parameter names may contain only word characters (latin letters, digits, and underscore) and\r\n     * must be unique within the pattern (across both path and search parameters). For colon\r\n     * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\r\n     * number of characters other than '/'. For catch-all placeholders the path parameter matches\r\n     * any number of characters.\r\n     *\r\n     * Examples:\r\n     *\r\n     * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\r\n     *   trailing slashes, and patterns have to match the entire path, not just a prefix.\r\n     * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\r\n     *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\r\n     * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\r\n     * * `'/user/{id:[^/]*}'` - Same as the previous example.\r\n     * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\r\n     *   parameter consists of 1 to 8 hex digits.\r\n     * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\r\n     *   path into the parameter 'path'.\r\n     * * `'/files/*path'` - ditto.\r\n     * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\r\n     *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\r\n     *\r\n     * @param {string} pattern  The pattern to compile into a matcher.\r\n     * @param {Object} config  A configuration object hash:\r\n     * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\r\n     *   an existing UrlMatcher\r\n     *\r\n     * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\r\n     * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\r\n     *\r\n     * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\r\n     *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\r\n     *   non-null) will start with this prefix.\r\n     *\r\n     * @property {string} source  The pattern that was passed into the constructor\r\n     *\r\n     * @property {string} sourcePath  The path portion of the source property\r\n     *\r\n     * @property {string} sourceSearch  The search portion of the source property\r\n     *\r\n     * @property {string} regex  The constructed regex that will be used to match against the url when\r\n     *   it is time to determine which url will match.\r\n     *\r\n     * @returns {Object}  New `UrlMatcher` object\r\n     */\r\n    function UrlMatcher(pattern, config, parentMatcher) {\r\n        config = extend({ params: {} }, isObject(config) ? config : {});\r\n\r\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\r\n        //   '*' name\r\n        //   ':' name\r\n        //   '{' name '}'\r\n        //   '{' name ':' regexp '}'\r\n        // The regular expression is somewhat complicated due to the need to allow curly braces\r\n        // inside the regular expression. The placeholder regexp breaks down as follows:\r\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\r\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\r\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\r\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\r\n        //    \\\\.                            - a backslash escape\r\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\r\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\r\n            searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\r\n            compiled = '^', last = 0, m,\r\n            segments = this.segments = [],\r\n            parentParams = parentMatcher ? parentMatcher.params : {},\r\n            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\r\n            paramNames = [];\r\n\r\n        function addParameter(id, type, config, location) {\r\n            paramNames.push(id);\r\n            if (parentParams[id]) return parentParams[id];\r\n            if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\r\n            if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\r\n            params[id] = new $$UMFP.Param(id, type, config, location);\r\n            return params[id];\r\n        }\r\n\r\n        function quoteRegExp(string, pattern, squash, optional) {\r\n            var surroundPattern = ['', ''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\r\n            if (!pattern) return result;\r\n            switch (squash) {\r\n                case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\r\n                case true:\r\n                    result = result.replace(/\\/$/, '');\r\n                    surroundPattern = ['(?:\\/(', ')|\\/)?'];\r\n                    break;\r\n                default: surroundPattern = ['(' + squash + \"|\", ')?']; break;\r\n            }\r\n            return result + surroundPattern[0] + pattern + surroundPattern[1];\r\n        }\r\n\r\n        this.source = pattern;\r\n\r\n        // Split into static segments separated by path parameter placeholders.\r\n        // The number of segments is always 1 more than the number of parameters.\r\n        function matchDetails(m, isSearch) {\r\n            var id, regexp, segment, type, cfg, arrayMode;\r\n            id = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\r\n            cfg = config.params[id];\r\n            segment = pattern.substring(last, m.index);\r\n            regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\r\n\r\n            if (regexp) {\r\n                type = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\r\n            }\r\n\r\n            return {\r\n                id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\r\n            };\r\n        }\r\n\r\n        var p, param, segment;\r\n        while ((m = placeholder.exec(pattern))) {\r\n            p = matchDetails(m, false);\r\n            if (p.segment.indexOf('?') >= 0) break; // we're into the search part\r\n\r\n            param = addParameter(p.id, p.type, p.cfg, \"path\");\r\n            compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\r\n            segments.push(p.segment);\r\n            last = placeholder.lastIndex;\r\n        }\r\n        segment = pattern.substring(last);\r\n\r\n        // Find any search parameter names and remove them from the last segment\r\n        var i = segment.indexOf('?');\r\n\r\n        if (i >= 0) {\r\n            var search = this.sourceSearch = segment.substring(i);\r\n            segment = segment.substring(0, i);\r\n            this.sourcePath = pattern.substring(0, last + i);\r\n\r\n            if (search.length > 0) {\r\n                last = 0;\r\n                while ((m = searchPlaceholder.exec(search))) {\r\n                    p = matchDetails(m, true);\r\n                    param = addParameter(p.id, p.type, p.cfg, \"search\");\r\n                    last = placeholder.lastIndex;\r\n                    // check if ?&\r\n                }\r\n            }\r\n        } else {\r\n            this.sourcePath = pattern;\r\n            this.sourceSearch = '';\r\n        }\r\n\r\n        compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\r\n        segments.push(segment);\r\n\r\n        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\r\n        this.prefix = segments[0];\r\n        this.$$paramNames = paramNames;\r\n    }\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ui.router.util.type:UrlMatcher#concat\r\n     * @methodOf ui.router.util.type:UrlMatcher\r\n     *\r\n     * @description\r\n     * Returns a new matcher for a pattern constructed by appending the path part and adding the\r\n     * search parameters of the specified pattern to this pattern. The current pattern is not\r\n     * modified. This can be understood as creating a pattern for URLs that are relative to (or\r\n     * suffixes of) the current pattern.\r\n     *\r\n     * @example\r\n     * The following two matchers are equivalent:\r\n     * <pre>\r\n     * new UrlMatcher('/user/{id}?q').concat('/details?date');\r\n     * new UrlMatcher('/user/{id}/details?q&date');\r\n     * </pre>\r\n     *\r\n     * @param {string} pattern  The pattern to append.\r\n     * @param {Object} config  An object hash of the configuration for the matcher.\r\n     * @returns {UrlMatcher}  A matcher for the concatenated pattern.\r\n     */\r\n    UrlMatcher.prototype.concat = function (pattern, config) {\r\n        // Because order of search parameters is irrelevant, we can add our own search\r\n        // parameters to the end of the new pattern. Parse the new pattern by itself\r\n        // and then join the bits together, but it's much easier to do this on a string level.\r\n        var defaultConfig = {\r\n            caseInsensitive: $$UMFP.caseInsensitive(),\r\n            strict: $$UMFP.strictMode(),\r\n            squash: $$UMFP.defaultSquashPolicy()\r\n        };\r\n        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\r\n    };\r\n\r\n    UrlMatcher.prototype.toString = function () {\r\n        return this.source;\r\n    };\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ui.router.util.type:UrlMatcher#exec\r\n     * @methodOf ui.router.util.type:UrlMatcher\r\n     *\r\n     * @description\r\n     * Tests the specified path against this matcher, and returns an object containing the captured\r\n     * parameter values, or null if the path does not match. The returned object contains the values\r\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\r\n     * they are not present in `searchParams`. This means that search parameters are always treated\r\n     * as optional.\r\n     *\r\n     * @example\r\n     * <pre>\r\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\r\n     *   x: '1', q: 'hello'\r\n     * });\r\n     * // returns { id: 'bob', q: 'hello', r: null }\r\n     * </pre>\r\n     *\r\n     * @param {string} path  The URL path to match, e.g. `$location.path()`.\r\n     * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\r\n     * @returns {Object}  The captured parameter values.\r\n     */\r\n    UrlMatcher.prototype.exec = function (path, searchParams) {\r\n        var m = this.regexp.exec(path);\r\n        if (!m) return null;\r\n        searchParams = searchParams || {};\r\n\r\n        var paramNames = this.parameters(), nTotal = paramNames.length,\r\n          nPath = this.segments.length - 1,\r\n          values = {}, i, j, cfg, paramName;\r\n\r\n        if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\r\n\r\n        function decodePathArray(string) {\r\n            function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\r\n            function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\r\n\r\n            var split = reverseString(string).split(/-(?!\\\\)/);\r\n            var allReversed = map(split, reverseString);\r\n            return map(allReversed, unquoteDashes).reverse();\r\n        }\r\n\r\n        var param, paramVal;\r\n        for (i = 0; i < nPath; i++) {\r\n            paramName = paramNames[i];\r\n            param = this.params[paramName];\r\n            paramVal = m[i + 1];\r\n            // if the param value matches a pre-replace pair, replace the value before decoding.\r\n            for (j = 0; j < param.replace.length; j++) {\r\n                if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\r\n            }\r\n            if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\r\n            if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\r\n            values[paramName] = param.value(paramVal);\r\n        }\r\n        for (/**/; i < nTotal; i++) {\r\n            paramName = paramNames[i];\r\n            values[paramName] = this.params[paramName].value(searchParams[paramName]);\r\n            param = this.params[paramName];\r\n            paramVal = searchParams[paramName];\r\n            for (j = 0; j < param.replace.length; j++) {\r\n                if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\r\n            }\r\n            if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\r\n            values[paramName] = param.value(paramVal);\r\n        }\r\n\r\n        return values;\r\n    };\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ui.router.util.type:UrlMatcher#parameters\r\n     * @methodOf ui.router.util.type:UrlMatcher\r\n     *\r\n     * @description\r\n     * Returns the names of all path and search parameters of this pattern in an unspecified order.\r\n     *\r\n     * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\r\n     *    pattern has no parameters, an empty array is returned.\r\n     */\r\n    UrlMatcher.prototype.parameters = function (param) {\r\n        if (!isDefined(param)) return this.$$paramNames;\r\n        return this.params[param] || null;\r\n    };\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ui.router.util.type:UrlMatcher#validates\r\n     * @methodOf ui.router.util.type:UrlMatcher\r\n     *\r\n     * @description\r\n     * Checks an object hash of parameters to validate their correctness according to the parameter\r\n     * types of this `UrlMatcher`.\r\n     *\r\n     * @param {Object} params The object hash of parameters to validate.\r\n     * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\r\n     */\r\n    UrlMatcher.prototype.validates = function (params) {\r\n        return this.params.$$validates(params);\r\n    };\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ui.router.util.type:UrlMatcher#format\r\n     * @methodOf ui.router.util.type:UrlMatcher\r\n     *\r\n     * @description\r\n     * Creates a URL that matches this pattern by substituting the specified values\r\n     * for the path and search parameters. Null values for path parameters are\r\n     * treated as empty strings.\r\n     *\r\n     * @example\r\n     * <pre>\r\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\r\n     * // returns '/user/bob?q=yes'\r\n     * </pre>\r\n     *\r\n     * @param {Object} values  the values to substitute for the parameters in this pattern.\r\n     * @returns {string}  the formatted URL (path and optionally search part).\r\n     */\r\n    UrlMatcher.prototype.format = function (values) {\r\n        values = values || {};\r\n        var segments = this.segments, params = this.parameters(), paramset = this.params;\r\n        if (!this.validates(values)) return null;\r\n\r\n        var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\r\n\r\n        function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\r\n            return encodeURIComponent(str).replace(/-/g, function (c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\r\n        }\r\n\r\n        for (i = 0; i < nTotal; i++) {\r\n            var isPathParam = i < nPath;\r\n            var name = params[i], param = paramset[name], value = param.value(values[name]);\r\n            var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\r\n            var squash = isDefaultValue ? param.squash : false;\r\n            var encoded = param.type.encode(value);\r\n\r\n            if (isPathParam) {\r\n                var nextSegment = segments[i + 1];\r\n                var isFinalPathParam = i + 1 === nPath;\r\n\r\n                if (squash === false) {\r\n                    if (encoded != null) {\r\n                        if (isArray(encoded)) {\r\n                            result += map(encoded, encodeDashes).join(\"-\");\r\n                        } else {\r\n                            result += encodeURIComponent(encoded);\r\n                        }\r\n                    }\r\n                    result += nextSegment;\r\n                } else if (squash === true) {\r\n                    var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\r\n                    result += nextSegment.match(capture)[1];\r\n                } else if (isString(squash)) {\r\n                    result += squash + nextSegment;\r\n                }\r\n\r\n                if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\r\n            } else {\r\n                if (encoded == null || (isDefaultValue && squash !== false)) continue;\r\n                if (!isArray(encoded)) encoded = [encoded];\r\n                if (encoded.length === 0) continue;\r\n                encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\r\n                result += (search ? '&' : '?') + (name + '=' + encoded);\r\n                search = true;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * @ngdoc object\r\n     * @name ui.router.util.type:Type\r\n     *\r\n     * @description\r\n     * Implements an interface to define custom parameter types that can be decoded from and encoded to\r\n     * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\r\n     * objects when matching or formatting URLs, or comparing or validating parameter values.\r\n     *\r\n     * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\r\n     * information on registering custom types.\r\n     *\r\n     * @param {Object} config  A configuration object which contains the custom type definition.  The object's\r\n     *        properties will override the default methods and/or pattern in `Type`'s public interface.\r\n     * @example\r\n     * <pre>\r\n     * {\r\n     *   decode: function(val) { return parseInt(val, 10); },\r\n     *   encode: function(val) { return val && val.toString(); },\r\n     *   equals: function(a, b) { return this.is(a) && a === b; },\r\n     *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\r\n     *   pattern: /\\d+/\r\n     * }\r\n     * </pre>\r\n     *\r\n     * @property {RegExp} pattern The regular expression pattern used to match values of this type when\r\n     *           coming from a substring of a URL.\r\n     *\r\n     * @returns {Object}  Returns a new `Type` object.\r\n     */\r\n    function Type(config) {\r\n        extend(this, config);\r\n    }\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ui.router.util.type:Type#is\r\n     * @methodOf ui.router.util.type:Type\r\n     *\r\n     * @description\r\n     * Detects whether a value is of a particular type. Accepts a native (decoded) value\r\n     * and determines whether it matches the current `Type` object.\r\n     *\r\n     * @param {*} val  The value to check.\r\n     * @param {string} key  Optional. If the type check is happening in the context of a specific\r\n     *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\r\n     *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\r\n     * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\r\n     */\r\n    Type.prototype.is = function (val, key) {\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ui.router.util.type:Type#encode\r\n     * @methodOf ui.router.util.type:Type\r\n     *\r\n     * @description\r\n     * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\r\n     * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\r\n     * only needs to be a representation of `val` that has been coerced to a string.\r\n     *\r\n     * @param {*} val  The value to encode.\r\n     * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\r\n     *        meta-programming of `Type` objects.\r\n     * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\r\n     */\r\n    Type.prototype.encode = function (val, key) {\r\n        return val;\r\n    };\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ui.router.util.type:Type#decode\r\n     * @methodOf ui.router.util.type:Type\r\n     *\r\n     * @description\r\n     * Converts a parameter value (from URL string or transition param) to a custom/native value.\r\n     *\r\n     * @param {string} val  The URL parameter value to decode.\r\n     * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\r\n     *        meta-programming of `Type` objects.\r\n     * @returns {*}  Returns a custom representation of the URL parameter value.\r\n     */\r\n    Type.prototype.decode = function (val, key) {\r\n        return val;\r\n    };\r\n\r\n    /**\r\n     * @ngdoc function\r\n     * @name ui.router.util.type:Type#equals\r\n     * @methodOf ui.router.util.type:Type\r\n     *\r\n     * @description\r\n     * Determines whether two decoded values are equivalent.\r\n     *\r\n     * @param {*} a  A value to compare against.\r\n     * @param {*} b  A value to compare against.\r\n     * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\r\n     */\r\n    Type.prototype.equals = function (a, b) {\r\n        return a == b;\r\n    };\r\n\r\n    Type.prototype.$subPattern = function () {\r\n        var sub = this.pattern.toString();\r\n        return sub.substr(1, sub.length - 2);\r\n    };\r\n\r\n    Type.prototype.pattern = /.*/;\r\n\r\n    Type.prototype.toString = function () { return \"{Type:\" + this.name + \"}\"; };\r\n\r\n    /** Given an encoded string, or a decoded object, returns a decoded object */\r\n    Type.prototype.$normalize = function (val) {\r\n        return this.is(val) ? val : this.decode(val);\r\n    };\r\n\r\n    /*\r\n     * Wraps an existing custom Type as an array of Type, depending on 'mode'.\r\n     * e.g.:\r\n     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\r\n     * - url: \"/path?queryParam=1&queryParam=2\r\n     * - $stateParams.queryParam will be [1, 2]\r\n     * if `mode` is \"auto\", then\r\n     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\r\n     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\r\n     */\r\n    Type.prototype.$asArray = function (mode, isSearch) {\r\n        if (!mode) return this;\r\n        if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\r\n\r\n        function ArrayType(type, mode) {\r\n            function bindTo(type, callbackName) {\r\n                return function () {\r\n                    return type[callbackName].apply(type, arguments);\r\n                };\r\n            }\r\n\r\n            // Wrap non-array value as array\r\n            function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [val] : []); }\r\n            // Unwrap array value for \"auto\" mode. Return undefined for empty array.\r\n            function arrayUnwrap(val) {\r\n                switch (val.length) {\r\n                    case 0: return undefined;\r\n                    case 1: return mode === \"auto\" ? val[0] : val;\r\n                    default: return val;\r\n                }\r\n            }\r\n            function falsey(val) { return !val; }\r\n\r\n            // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\r\n            function arrayHandler(callback, allTruthyMode) {\r\n                return function handleArray(val) {\r\n                    if (isArray(val) && val.length === 0) return val;\r\n                    val = arrayWrap(val);\r\n                    var result = map(val, callback);\r\n                    if (allTruthyMode === true)\r\n                        return filter(result, falsey).length === 0;\r\n                    return arrayUnwrap(result);\r\n                };\r\n            }\r\n\r\n            // Wraps type (.equals) functions to operate on each value of an array\r\n            function arrayEqualsHandler(callback) {\r\n                return function handleArray(val1, val2) {\r\n                    var left = arrayWrap(val1), right = arrayWrap(val2);\r\n                    if (left.length !== right.length) return false;\r\n                    for (var i = 0; i < left.length; i++) {\r\n                        if (!callback(left[i], right[i])) return false;\r\n                    }\r\n                    return true;\r\n                };\r\n            }\r\n\r\n            this.encode = arrayHandler(bindTo(type, 'encode'));\r\n            this.decode = arrayHandler(bindTo(type, 'decode'));\r\n            this.is = arrayHandler(bindTo(type, 'is'), true);\r\n            this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\r\n            this.pattern = type.pattern;\r\n            this.$normalize = arrayHandler(bindTo(type, '$normalize'));\r\n            this.name = type.name;\r\n            this.$arrayMode = mode;\r\n        }\r\n\r\n        return new ArrayType(this, mode);\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * @ngdoc object\r\n     * @name ui.router.util.$urlMatcherFactory\r\n     *\r\n     * @description\r\n     * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\r\n     * is also available to providers under the name `$urlMatcherFactoryProvider`.\r\n     */\r\n    function $UrlMatcherFactory() {\r\n        $$UMFP = this;\r\n\r\n        var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\r\n\r\n        // Use tildes to pre-encode slashes.\r\n        // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\r\n        // and bidirectional encoding/decoding fails.\r\n        // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\r\n        function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\r\n        function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\r\n\r\n        var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\r\n            \"string\": {\r\n                encode: valToString,\r\n                decode: valFromString,\r\n                // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\r\n                // In 0.2.x, string params are optional by default for backwards compat\r\n                is: function (val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\r\n                pattern: /[^/]*/\r\n            },\r\n            \"int\": {\r\n                encode: valToString,\r\n                decode: function (val) { return parseInt(val, 10); },\r\n                is: function (val) { return isDefined(val) && this.decode(val.toString()) === val; },\r\n                pattern: /\\d+/\r\n            },\r\n            \"bool\": {\r\n                encode: function (val) { return val ? 1 : 0; },\r\n                decode: function (val) { return parseInt(val, 10) !== 0; },\r\n                is: function (val) { return val === true || val === false; },\r\n                pattern: /0|1/\r\n            },\r\n            \"date\": {\r\n                encode: function (val) {\r\n                    if (!this.is(val))\r\n                        return undefined;\r\n                    return [val.getFullYear(),\r\n                      ('0' + (val.getMonth() + 1)).slice(-2),\r\n                      ('0' + val.getDate()).slice(-2)\r\n                    ].join(\"-\");\r\n                },\r\n                decode: function (val) {\r\n                    if (this.is(val)) return val;\r\n                    var match = this.capture.exec(val);\r\n                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\r\n                },\r\n                is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\r\n                equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\r\n                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\r\n                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\r\n            },\r\n            \"json\": {\r\n                encode: angular.toJson,\r\n                decode: angular.fromJson,\r\n                is: angular.isObject,\r\n                equals: angular.equals,\r\n                pattern: /[^/]*/\r\n            },\r\n            \"any\": { // does not encode/decode\r\n                encode: angular.identity,\r\n                decode: angular.identity,\r\n                equals: angular.equals,\r\n                pattern: /.*/\r\n            }\r\n        };\r\n\r\n        function getDefaultConfig() {\r\n            return {\r\n                strict: isStrictMode,\r\n                caseInsensitive: isCaseInsensitive\r\n            };\r\n        }\r\n\r\n        function isInjectable(value) {\r\n            return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\r\n        }\r\n\r\n        /**\r\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\r\n         */\r\n        $UrlMatcherFactory.$$getDefaultValue = function (config) {\r\n            if (!isInjectable(config.value)) return config.value;\r\n            if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\r\n            return injector.invoke(config.value);\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$urlMatcherFactory#caseInsensitive\r\n         * @methodOf ui.router.util.$urlMatcherFactory\r\n         *\r\n         * @description\r\n         * Defines whether URL matching should be case sensitive (the default behavior), or not.\r\n         *\r\n         * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\r\n         * @returns {boolean} the current value of caseInsensitive\r\n         */\r\n        this.caseInsensitive = function (value) {\r\n            if (isDefined(value))\r\n                isCaseInsensitive = value;\r\n            return isCaseInsensitive;\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$urlMatcherFactory#strictMode\r\n         * @methodOf ui.router.util.$urlMatcherFactory\r\n         *\r\n         * @description\r\n         * Defines whether URLs should match trailing slashes, or not (the default behavior).\r\n         *\r\n         * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\r\n         * @returns {boolean} the current value of strictMode\r\n         */\r\n        this.strictMode = function (value) {\r\n            if (isDefined(value))\r\n                isStrictMode = value;\r\n            return isStrictMode;\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\r\n         * @methodOf ui.router.util.$urlMatcherFactory\r\n         *\r\n         * @description\r\n         * Sets the default behavior when generating or matching URLs with default parameter values.\r\n         *\r\n         * @param {string} value A string that defines the default parameter URL squashing behavior.\r\n         *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\r\n         *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\r\n         *             parameter is surrounded by slashes, squash (remove) one slash from the URL\r\n         *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\r\n         *             the parameter value from the URL and replace it with this string.\r\n         */\r\n        this.defaultSquashPolicy = function (value) {\r\n            if (!isDefined(value)) return defaultSquashPolicy;\r\n            if (value !== true && value !== false && !isString(value))\r\n                throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\r\n            defaultSquashPolicy = value;\r\n            return value;\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$urlMatcherFactory#compile\r\n         * @methodOf ui.router.util.$urlMatcherFactory\r\n         *\r\n         * @description\r\n         * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\r\n         *\r\n         * @param {string} pattern  The URL pattern.\r\n         * @param {Object} config  The config object hash.\r\n         * @returns {UrlMatcher}  The UrlMatcher.\r\n         */\r\n        this.compile = function (pattern, config) {\r\n            return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$urlMatcherFactory#isMatcher\r\n         * @methodOf ui.router.util.$urlMatcherFactory\r\n         *\r\n         * @description\r\n         * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\r\n         *\r\n         * @param {Object} object  The object to perform the type check against.\r\n         * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\r\n         *          implementing all the same methods.\r\n         */\r\n        this.isMatcher = function (o) {\r\n            if (!isObject(o)) return false;\r\n            var result = true;\r\n\r\n            forEach(UrlMatcher.prototype, function (val, name) {\r\n                if (isFunction(val)) {\r\n                    result = result && (isDefined(o[name]) && isFunction(o[name]));\r\n                }\r\n            });\r\n            return result;\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.util.$urlMatcherFactory#type\r\n         * @methodOf ui.router.util.$urlMatcherFactory\r\n         *\r\n         * @description\r\n         * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\r\n         * generate URLs with typed parameters.\r\n         *\r\n         * @param {string} name  The type name.\r\n         * @param {Object|Function} definition   The type definition. See\r\n         *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\r\n         * @param {Object|Function} definitionFn (optional) A function that is injected before the app\r\n         *        runtime starts.  The result of this function is merged into the existing `definition`.\r\n         *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\r\n         *\r\n         * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\r\n         *\r\n         * @example\r\n         * This is a simple example of a custom type that encodes and decodes items from an\r\n         * array, using the array index as the URL-encoded value:\r\n         *\r\n         * <pre>\r\n         * var list = ['John', 'Paul', 'George', 'Ringo'];\r\n         *\r\n         * $urlMatcherFactoryProvider.type('listItem', {\r\n         *   encode: function(item) {\r\n         *     // Represent the list item in the URL using its corresponding index\r\n         *     return list.indexOf(item);\r\n         *   },\r\n         *   decode: function(item) {\r\n         *     // Look up the list item by index\r\n         *     return list[parseInt(item, 10)];\r\n         *   },\r\n         *   is: function(item) {\r\n         *     // Ensure the item is valid by checking to see that it appears\r\n         *     // in the list\r\n         *     return list.indexOf(item) > -1;\r\n         *   }\r\n         * });\r\n         *\r\n         * $stateProvider.state('list', {\r\n         *   url: \"/list/{item:listItem}\",\r\n         *   controller: function($scope, $stateParams) {\r\n         *     console.log($stateParams.item);\r\n         *   }\r\n         * });\r\n         *\r\n         * // ...\r\n         *\r\n         * // Changes URL to '/list/3', logs \"Ringo\" to the console\r\n         * $state.go('list', { item: \"Ringo\" });\r\n         * </pre>\r\n         *\r\n         * This is a more complex example of a type that relies on dependency injection to\r\n         * interact with services, and uses the parameter name from the URL to infer how to\r\n         * handle encoding and decoding parameter values:\r\n         *\r\n         * <pre>\r\n         * // Defines a custom type that gets a value from a service,\r\n         * // where each service gets different types of values from\r\n         * // a backend API:\r\n         * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\r\n         *\r\n         *   // Matches up services to URL parameter names\r\n         *   var services = {\r\n         *     user: Users,\r\n         *     post: Posts\r\n         *   };\r\n         *\r\n         *   return {\r\n         *     encode: function(object) {\r\n         *       // Represent the object in the URL using its unique ID\r\n         *       return object.id;\r\n         *     },\r\n         *     decode: function(value, key) {\r\n         *       // Look up the object by ID, using the parameter\r\n         *       // name (key) to call the correct service\r\n         *       return services[key].findById(value);\r\n         *     },\r\n         *     is: function(object, key) {\r\n         *       // Check that object is a valid dbObject\r\n         *       return angular.isObject(object) && object.id && services[key];\r\n         *     }\r\n         *     equals: function(a, b) {\r\n         *       // Check the equality of decoded objects by comparing\r\n         *       // their unique IDs\r\n         *       return a.id === b.id;\r\n         *     }\r\n         *   };\r\n         * });\r\n         *\r\n         * // In a config() block, you can then attach URLs with\r\n         * // type-annotated parameters:\r\n         * $stateProvider.state('users', {\r\n         *   url: \"/users\",\r\n         *   // ...\r\n         * }).state('users.item', {\r\n         *   url: \"/{user:dbObject}\",\r\n         *   controller: function($scope, $stateParams) {\r\n         *     // $stateParams.user will now be an object returned from\r\n         *     // the Users service\r\n         *   },\r\n         *   // ...\r\n         * });\r\n         * </pre>\r\n         */\r\n        this.type = function (name, definition, definitionFn) {\r\n            if (!isDefined(definition)) return $types[name];\r\n            if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\r\n\r\n            $types[name] = new Type(extend({ name: name }, definition));\r\n            if (definitionFn) {\r\n                typeQueue.push({ name: name, def: definitionFn });\r\n                if (!enqueue) flushTypeQueue();\r\n            }\r\n            return this;\r\n        };\r\n\r\n        // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\r\n        function flushTypeQueue() {\r\n            while (typeQueue.length) {\r\n                var type = typeQueue.shift();\r\n                if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\r\n                angular.extend($types[type.name], injector.invoke(type.def));\r\n            }\r\n        }\r\n\r\n        // Register default types. Store them in the prototype of $types.\r\n        forEach(defaultTypes, function (type, name) { $types[name] = new Type(extend({ name: name }, type)); });\r\n        $types = inherit($types, {});\r\n\r\n        /* No need to document $get, since it returns this */\r\n        this.$get = ['$injector', function ($injector) {\r\n            injector = $injector;\r\n            enqueue = false;\r\n            flushTypeQueue();\r\n\r\n            forEach(defaultTypes, function (type, name) {\r\n                if (!$types[name]) $types[name] = new Type(type);\r\n            });\r\n            return this;\r\n        }];\r\n\r\n        this.Param = function Param(id, type, config, location) {\r\n            var self = this;\r\n            config = unwrapShorthand(config);\r\n            type = getType(config, type, location);\r\n            var arrayMode = getArrayMode();\r\n            type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\r\n            if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\r\n                config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\r\n            var isOptional = config.value !== undefined;\r\n            var squash = getSquashPolicy(config, isOptional);\r\n            var replace = getReplace(config, arrayMode, isOptional, squash);\r\n\r\n            function unwrapShorthand(config) {\r\n                var keys = isObject(config) ? objectKeys(config) : [];\r\n                var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\r\n                                  indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\r\n                if (isShorthand) config = { value: config };\r\n                config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\r\n                return config;\r\n            }\r\n\r\n            function getType(config, urlType, location) {\r\n                if (config.type && urlType) throw new Error(\"Param '\" + id + \"' has two type configurations.\");\r\n                if (urlType) return urlType;\r\n                if (!config.type) return (location === \"config\" ? $types.any : $types.string);\r\n\r\n                if (angular.isString(config.type))\r\n                    return $types[config.type];\r\n                if (config.type instanceof Type)\r\n                    return config.type;\r\n                return new Type(config.type);\r\n            }\r\n\r\n            // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\r\n            function getArrayMode() {\r\n                var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\r\n                var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\r\n                return extend(arrayDefaults, arrayParamNomenclature, config).array;\r\n            }\r\n\r\n            /**\r\n             * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\r\n             */\r\n            function getSquashPolicy(config, isOptional) {\r\n                var squash = config.squash;\r\n                if (!isOptional || squash === false) return false;\r\n                if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\r\n                if (squash === true || isString(squash)) return squash;\r\n                throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\r\n            }\r\n\r\n            function getReplace(config, arrayMode, isOptional, squash) {\r\n                var replace, configuredKeys, defaultPolicy = [\r\n                  { from: \"\", to: (isOptional || arrayMode ? undefined : \"\") },\r\n                  { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\r\n                ];\r\n                replace = isArray(config.replace) ? config.replace : [];\r\n                if (isString(squash))\r\n                    replace.push({ from: squash, to: undefined });\r\n                configuredKeys = map(replace, function (item) { return item.from; });\r\n                return filter(defaultPolicy, function (item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\r\n            }\r\n\r\n            /**\r\n             * [Internal] Get the default value of a parameter, which may be an injectable function.\r\n             */\r\n            function $$getDefaultValue() {\r\n                if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\r\n                var defaultValue = injector.invoke(config.$$fn);\r\n                if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\r\n                    throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\r\n                return defaultValue;\r\n            }\r\n\r\n            /**\r\n             * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\r\n             * default value, which may be the result of an injectable function.\r\n             */\r\n            function $value(value) {\r\n                function hasReplaceVal(val) { return function (obj) { return obj.from === val; }; }\r\n                function $replace(value) {\r\n                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function (obj) { return obj.to; });\r\n                    return replacement.length ? replacement[0] : value;\r\n                }\r\n                value = $replace(value);\r\n                return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\r\n            }\r\n\r\n            function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\r\n\r\n            extend(this, {\r\n                id: id,\r\n                type: type,\r\n                location: location,\r\n                array: arrayMode,\r\n                squash: squash,\r\n                replace: replace,\r\n                isOptional: isOptional,\r\n                value: $value,\r\n                dynamic: undefined,\r\n                config: config,\r\n                toString: toString\r\n            });\r\n        };\r\n\r\n        function ParamSet(params) {\r\n            extend(this, params || {});\r\n        }\r\n\r\n        ParamSet.prototype = {\r\n            $$new: function () {\r\n                return inherit(this, extend(new ParamSet(), { $$parent: this }));\r\n            },\r\n            $$keys: function () {\r\n                var keys = [], chain = [], parent = this,\r\n                  ignore = objectKeys(ParamSet.prototype);\r\n                while (parent) { chain.push(parent); parent = parent.$$parent; }\r\n                chain.reverse();\r\n                forEach(chain, function (paramset) {\r\n                    forEach(objectKeys(paramset), function (key) {\r\n                        if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\r\n                    });\r\n                });\r\n                return keys;\r\n            },\r\n            $$values: function (paramValues) {\r\n                var values = {}, self = this;\r\n                forEach(self.$$keys(), function (key) {\r\n                    values[key] = self[key].value(paramValues && paramValues[key]);\r\n                });\r\n                return values;\r\n            },\r\n            $$equals: function (paramValues1, paramValues2) {\r\n                var equal = true, self = this;\r\n                forEach(self.$$keys(), function (key) {\r\n                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\r\n                    if (!self[key].type.equals(left, right)) equal = false;\r\n                });\r\n                return equal;\r\n            },\r\n            $$validates: function $$validate(paramValues) {\r\n                var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\r\n                for (i = 0; i < keys.length; i++) {\r\n                    param = this[keys[i]];\r\n                    rawVal = paramValues[keys[i]];\r\n                    if ((rawVal === undefined || rawVal === null) && param.isOptional)\r\n                        break; // There was no parameter value, but the param is optional\r\n                    normalized = param.type.$normalize(rawVal);\r\n                    if (!param.type.is(normalized))\r\n                        return false; // The value was not of the correct Type, and could not be decoded to the correct Type\r\n                    encoded = param.type.encode(normalized);\r\n                    if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\r\n                        return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\r\n                }\r\n                return true;\r\n            },\r\n            $$parent: undefined\r\n        };\r\n\r\n        this.ParamSet = ParamSet;\r\n    }\r\n\r\n    // Register as a provider so it's available to other providers\r\n    angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\r\n    angular.module('ui.router.util').run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\r\n\r\n    /**\r\n     * @ngdoc object\r\n     * @name ui.router.router.$urlRouterProvider\r\n     *\r\n     * @requires ui.router.util.$urlMatcherFactoryProvider\r\n     * @requires $locationProvider\r\n     *\r\n     * @description\r\n     * `$urlRouterProvider` has the responsibility of watching `$location`. \r\n     * When `$location` changes it runs through a list of rules one by one until a \r\n     * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \r\n     * a url in a state configuration. All urls are compiled into a UrlMatcher object.\r\n     *\r\n     * There are several methods on `$urlRouterProvider` that make it useful to use directly\r\n     * in your module config.\r\n     */\r\n    $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\r\n    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {\r\n        var rules = [], otherwise = null, interceptDeferred = false, listener;\r\n\r\n        // Returns a string that is a prefix of all strings matching the RegExp\r\n        function regExpPrefix(re) {\r\n            var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\r\n            return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\r\n        }\r\n\r\n        // Interpolates matched values into a String.replace()-style pattern\r\n        function interpolate(pattern, match) {\r\n            return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\r\n                return match[what === '$' ? 0 : Number(what)];\r\n            });\r\n        }\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.router.$urlRouterProvider#rule\r\n         * @methodOf ui.router.router.$urlRouterProvider\r\n         *\r\n         * @description\r\n         * Defines rules that are used by `$urlRouterProvider` to find matches for\r\n         * specific URLs.\r\n         *\r\n         * @example\r\n         * <pre>\r\n         * var app = angular.module('app', ['ui.router.router']);\r\n         *\r\n         * app.config(function ($urlRouterProvider) {\r\n         *   // Here's an example of how you might allow case insensitive urls\r\n         *   $urlRouterProvider.rule(function ($injector, $location) {\r\n         *     var path = $location.path(),\r\n         *         normalized = path.toLowerCase();\r\n         *\r\n         *     if (path !== normalized) {\r\n         *       return normalized;\r\n         *     }\r\n         *   });\r\n         * });\r\n         * </pre>\r\n         *\r\n         * @param {function} rule Handler function that takes `$injector` and `$location`\r\n         * services as arguments. You can use them to return a valid path as a string.\r\n         *\r\n         * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\r\n         */\r\n        this.rule = function (rule) {\r\n            if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\r\n            rules.push(rule);\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * @ngdoc object\r\n         * @name ui.router.router.$urlRouterProvider#otherwise\r\n         * @methodOf ui.router.router.$urlRouterProvider\r\n         *\r\n         * @description\r\n         * Defines a path that is used when an invalid route is requested.\r\n         *\r\n         * @example\r\n         * <pre>\r\n         * var app = angular.module('app', ['ui.router.router']);\r\n         *\r\n         * app.config(function ($urlRouterProvider) {\r\n         *   // if the path doesn't match any of the urls you configured\r\n         *   // otherwise will take care of routing the user to the\r\n         *   // specified url\r\n         *   $urlRouterProvider.otherwise('/index');\r\n         *\r\n         *   // Example of using function rule as param\r\n         *   $urlRouterProvider.otherwise(function ($injector, $location) {\r\n         *     return '/a/valid/url';\r\n         *   });\r\n         * });\r\n         * </pre>\r\n         *\r\n         * @param {string|function} rule The url path you want to redirect to or a function \r\n         * rule that returns the url path. The function version is passed two params: \r\n         * `$injector` and `$location` services, and must return a url string.\r\n         *\r\n         * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\r\n         */\r\n        this.otherwise = function (rule) {\r\n            if (isString(rule)) {\r\n                var redirect = rule;\r\n                rule = function () { return redirect; };\r\n            }\r\n            else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\r\n            otherwise = rule;\r\n            return this;\r\n        };\r\n\r\n\r\n        function handleIfMatch($injector, handler, match) {\r\n            if (!match) return false;\r\n            var result = $injector.invoke(handler, handler, { $match: match });\r\n            return isDefined(result) ? result : true;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.router.$urlRouterProvider#when\r\n         * @methodOf ui.router.router.$urlRouterProvider\r\n         *\r\n         * @description\r\n         * Registers a handler for a given url matching. \r\n         * \r\n         * If the handler is a string, it is\r\n         * treated as a redirect, and is interpolated according to the syntax of match\r\n         * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\r\n         *\r\n         * If the handler is a function, it is injectable. It gets invoked if `$location`\r\n         * matches. You have the option of inject the match object as `$match`.\r\n         *\r\n         * The handler can return\r\n         *\r\n         * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\r\n         *   will continue trying to find another one that matches.\r\n         * - **string** which is treated as a redirect and passed to `$location.url()`\r\n         * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\r\n         *\r\n         * @example\r\n         * <pre>\r\n         * var app = angular.module('app', ['ui.router.router']);\r\n         *\r\n         * app.config(function ($urlRouterProvider) {\r\n         *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\r\n         *     if ($state.$current.navigable !== state ||\r\n         *         !equalForKeys($match, $stateParams) {\r\n         *      $state.transitionTo(state, $match, false);\r\n         *     }\r\n         *   });\r\n         * });\r\n         * </pre>\r\n         *\r\n         * @param {string|object} what The incoming path that you want to redirect.\r\n         * @param {string|function} handler The path you want to redirect your user to.\r\n         */\r\n        this.when = function (what, handler) {\r\n            var redirect, handlerIsString = isString(handler);\r\n            if (isString(what)) what = $urlMatcherFactory.compile(what);\r\n\r\n            if (!handlerIsString && !isFunction(handler) && !isArray(handler))\r\n                throw new Error(\"invalid 'handler' in when()\");\r\n\r\n            var strategies = {\r\n                matcher: function (what, handler) {\r\n                    if (handlerIsString) {\r\n                        redirect = $urlMatcherFactory.compile(handler);\r\n                        handler = ['$match', function ($match) { return redirect.format($match); }];\r\n                    }\r\n                    return extend(function ($injector, $location) {\r\n                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\r\n                    }, {\r\n                        prefix: isString(what.prefix) ? what.prefix : ''\r\n                    });\r\n                },\r\n                regex: function (what, handler) {\r\n                    if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\r\n\r\n                    if (handlerIsString) {\r\n                        redirect = handler;\r\n                        handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\r\n                    }\r\n                    return extend(function ($injector, $location) {\r\n                        return handleIfMatch($injector, handler, what.exec($location.path()));\r\n                    }, {\r\n                        prefix: regExpPrefix(what)\r\n                    });\r\n                }\r\n            };\r\n\r\n            var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\r\n\r\n            for (var n in check) {\r\n                if (check[n]) return this.rule(strategies[n](what, handler));\r\n            }\r\n\r\n            throw new Error(\"invalid 'what' in when()\");\r\n        };\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.router.$urlRouterProvider#deferIntercept\r\n         * @methodOf ui.router.router.$urlRouterProvider\r\n         *\r\n         * @description\r\n         * Disables (or enables) deferring location change interception.\r\n         *\r\n         * If you wish to customize the behavior of syncing the URL (for example, if you wish to\r\n         * defer a transition but maintain the current URL), call this method at configuration time.\r\n         * Then, at run time, call `$urlRouter.listen()` after you have configured your own\r\n         * `$locationChangeSuccess` event handler.\r\n         *\r\n         * @example\r\n         * <pre>\r\n         * var app = angular.module('app', ['ui.router.router']);\r\n         *\r\n         * app.config(function ($urlRouterProvider) {\r\n         *\r\n         *   // Prevent $urlRouter from automatically intercepting URL changes;\r\n         *   // this allows you to configure custom behavior in between\r\n         *   // location changes and route synchronization:\r\n         *   $urlRouterProvider.deferIntercept();\r\n         *\r\n         * }).run(function ($rootScope, $urlRouter, UserService) {\r\n         *\r\n         *   $rootScope.$on('$locationChangeSuccess', function(e) {\r\n         *     // UserService is an example service for managing user state\r\n         *     if (UserService.isLoggedIn()) return;\r\n         *\r\n         *     // Prevent $urlRouter's default handler from firing\r\n         *     e.preventDefault();\r\n         *\r\n         *     UserService.handleLogin().then(function() {\r\n         *       // Once the user has logged in, sync the current URL\r\n         *       // to the router:\r\n         *       $urlRouter.sync();\r\n         *     });\r\n         *   });\r\n         *\r\n         *   // Configures $urlRouter's listener *after* your custom listener\r\n         *   $urlRouter.listen();\r\n         * });\r\n         * </pre>\r\n         *\r\n         * @param {boolean} defer Indicates whether to defer location change interception. Passing\r\n                  no parameter is equivalent to `true`.\r\n         */\r\n        this.deferIntercept = function (defer) {\r\n            if (defer === undefined) defer = true;\r\n            interceptDeferred = defer;\r\n        };\r\n\r\n        /**\r\n         * @ngdoc object\r\n         * @name ui.router.router.$urlRouter\r\n         *\r\n         * @requires $location\r\n         * @requires $rootScope\r\n         * @requires $injector\r\n         * @requires $browser\r\n         *\r\n         * @description\r\n         *\r\n         */\r\n        this.$get = $get;\r\n        $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\r\n        function $get($location, $rootScope, $injector, $browser, $sniffer) {\r\n\r\n            var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\r\n\r\n            function appendBasePath(url, isHtml5, absolute) {\r\n                if (baseHref === '/') return url;\r\n                if (isHtml5) return baseHref.slice(0, -1) + url;\r\n                if (absolute) return baseHref.slice(1) + url;\r\n                return url;\r\n            }\r\n\r\n            // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\r\n            function update(evt) {\r\n                if (evt && evt.defaultPrevented) return;\r\n                var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\r\n                lastPushedUrl = undefined;\r\n                // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\r\n                //if (ignoreUpdate) return true;\r\n\r\n                function check(rule) {\r\n                    var handled = rule($injector, $location);\r\n\r\n                    if (!handled) return false;\r\n                    if (isString(handled)) $location.replace().url(handled);\r\n                    return true;\r\n                }\r\n                var n = rules.length, i;\r\n\r\n                for (i = 0; i < n; i++) {\r\n                    if (check(rules[i])) return;\r\n                }\r\n                // always check otherwise last to allow dynamic updates to the set of rules\r\n                if (otherwise) check(otherwise);\r\n            }\r\n\r\n            function listen() {\r\n                listener = listener || $rootScope.$on('$locationChangeSuccess', update);\r\n                return listener;\r\n            }\r\n\r\n            if (!interceptDeferred) listen();\r\n\r\n            return {\r\n                /**\r\n                 * @ngdoc function\r\n                 * @name ui.router.router.$urlRouter#sync\r\n                 * @methodOf ui.router.router.$urlRouter\r\n                 *\r\n                 * @description\r\n                 * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\r\n                 * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\r\n                 * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\r\n                 * with the transition by calling `$urlRouter.sync()`.\r\n                 *\r\n                 * @example\r\n                 * <pre>\r\n                 * angular.module('app', ['ui.router'])\r\n                 *   .run(function($rootScope, $urlRouter) {\r\n                 *     $rootScope.$on('$locationChangeSuccess', function(evt) {\r\n                 *       // Halt state change from even starting\r\n                 *       evt.preventDefault();\r\n                 *       // Perform custom logic\r\n                 *       var meetsRequirement = ...\r\n                 *       // Continue with the update and state transition if logic allows\r\n                 *       if (meetsRequirement) $urlRouter.sync();\r\n                 *     });\r\n                 * });\r\n                 * </pre>\r\n                 */\r\n                sync: function () {\r\n                    update();\r\n                },\r\n\r\n                listen: function () {\r\n                    return listen();\r\n                },\r\n\r\n                update: function (read) {\r\n                    if (read) {\r\n                        location = $location.url();\r\n                        return;\r\n                    }\r\n                    if ($location.url() === location) return;\r\n\r\n                    $location.url(location);\r\n                    $location.replace();\r\n                },\r\n\r\n                push: function (urlMatcher, params, options) {\r\n                    var url = urlMatcher.format(params || {});\r\n\r\n                    // Handle the special hash param, if needed\r\n                    if (url !== null && params && params['#']) {\r\n                        url += '#' + params['#'];\r\n                    }\r\n\r\n                    $location.url(url);\r\n                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\r\n                    if (options && options.replace) $location.replace();\r\n                },\r\n\r\n                /**\r\n                 * @ngdoc function\r\n                 * @name ui.router.router.$urlRouter#href\r\n                 * @methodOf ui.router.router.$urlRouter\r\n                 *\r\n                 * @description\r\n                 * A URL generation method that returns the compiled URL for a given\r\n                 * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\r\n                 *\r\n                 * @example\r\n                 * <pre>\r\n                 * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\r\n                 *   person: \"bob\"\r\n                 * });\r\n                 * // $bob == \"/about/bob\";\r\n                 * </pre>\r\n                 *\r\n                 * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\r\n                 * @param {object=} params An object of parameter values to fill the matcher's required parameters.\r\n                 * @param {object=} options Options object. The options are:\r\n                 *\r\n                 * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\r\n                 *\r\n                 * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\r\n                 */\r\n                href: function (urlMatcher, params, options) {\r\n                    if (!urlMatcher.validates(params)) return null;\r\n\r\n                    var isHtml5 = $locationProvider.html5Mode();\r\n                    if (angular.isObject(isHtml5)) {\r\n                        isHtml5 = isHtml5.enabled;\r\n                    }\r\n\r\n                    isHtml5 = isHtml5 && $sniffer.history;\r\n\r\n                    var url = urlMatcher.format(params);\r\n                    options = options || {};\r\n\r\n                    if (!isHtml5 && url !== null) {\r\n                        url = \"#\" + $locationProvider.hashPrefix() + url;\r\n                    }\r\n\r\n                    // Handle special hash param, if needed\r\n                    if (url !== null && params && params['#']) {\r\n                        url += '#' + params['#'];\r\n                    }\r\n\r\n                    url = appendBasePath(url, isHtml5, options.absolute);\r\n\r\n                    if (!options.absolute || !url) {\r\n                        return url;\r\n                    }\r\n\r\n                    var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\r\n                    port = (port === 80 || port === 443 ? '' : ':' + port);\r\n\r\n                    return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\r\n\r\n    /**\r\n     * @ngdoc object\r\n     * @name ui.router.state.$stateProvider\r\n     *\r\n     * @requires ui.router.router.$urlRouterProvider\r\n     * @requires ui.router.util.$urlMatcherFactoryProvider\r\n     *\r\n     * @description\r\n     * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\r\n     * on state.\r\n     *\r\n     * A state corresponds to a \"place\" in the application in terms of the overall UI and\r\n     * navigation. A state describes (via the controller / template / view properties) what\r\n     * the UI looks like and does at that place.\r\n     *\r\n     * States often have things in common, and the primary way of factoring out these\r\n     * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\r\n     * nested states.\r\n     *\r\n     * The `$stateProvider` provides interfaces to declare these states for your app.\r\n     */\r\n    $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\r\n    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {\r\n\r\n        var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\r\n\r\n        // Builds state properties from definition passed to registerState()\r\n        var stateBuilder = {\r\n\r\n            // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\r\n            // state.children = [];\r\n            // if (parent) parent.children.push(state);\r\n            parent: function (state) {\r\n                if (isDefined(state.parent) && state.parent) return findState(state.parent);\r\n                // regex matches any valid composite state name\r\n                // would match \"contact.list\" but not \"contacts\"\r\n                var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\r\n                return compositeName ? findState(compositeName[1]) : root;\r\n            },\r\n\r\n            // inherit 'data' from parent and override by own values (if any)\r\n            data: function (state) {\r\n                if (state.parent && state.parent.data) {\r\n                    state.data = state.self.data = inherit(state.parent.data, state.data);\r\n                }\r\n                return state.data;\r\n            },\r\n\r\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\r\n            url: function (state) {\r\n                var url = state.url, config = { params: state.params || {} };\r\n\r\n                if (isString(url)) {\r\n                    if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\r\n                    return (state.parent.navigable || root).url.concat(url, config);\r\n                }\r\n\r\n                if (!url || $urlMatcherFactory.isMatcher(url)) return url;\r\n                throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\r\n            },\r\n\r\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\r\n            navigable: function (state) {\r\n                return state.url ? state : (state.parent ? state.parent.navigable : null);\r\n            },\r\n\r\n            // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\r\n            ownParams: function (state) {\r\n                var params = state.url && state.url.params || new $$UMFP.ParamSet();\r\n                forEach(state.params || {}, function (config, id) {\r\n                    if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\r\n                });\r\n                return params;\r\n            },\r\n\r\n            // Derive parameters for this state and ensure they're a super-set of parent's parameters\r\n            params: function (state) {\r\n                var ownParams = pick(state.ownParams, state.ownParams.$$keys());\r\n                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\r\n            },\r\n\r\n            // If there is no explicit multi-view configuration, make one up so we don't have\r\n            // to handle both cases in the view directive later. Note that having an explicit\r\n            // 'views' property will mean the default unnamed view properties are ignored. This\r\n            // is also a good time to resolve view names to absolute names, so everything is a\r\n            // straight lookup at link time.\r\n            views: function (state) {\r\n                var views = {};\r\n\r\n                forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\r\n                    if (name.indexOf('@') < 0) name += '@' + state.parent.name;\r\n                    views[name] = view;\r\n                });\r\n                return views;\r\n            },\r\n\r\n            // Keep a full path from the root down to this state as this is needed for state activation.\r\n            path: function (state) {\r\n                return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\r\n            },\r\n\r\n            // Speed up $state.contains() as it's used a lot\r\n            includes: function (state) {\r\n                var includes = state.parent ? extend({}, state.parent.includes) : {};\r\n                includes[state.name] = true;\r\n                return includes;\r\n            },\r\n\r\n            $delegates: {}\r\n        };\r\n\r\n        function isRelative(stateName) {\r\n            return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\r\n        }\r\n\r\n        function findState(stateOrName, base) {\r\n            if (!stateOrName) return undefined;\r\n\r\n            var isStr = isString(stateOrName),\r\n                name = isStr ? stateOrName : stateOrName.name,\r\n                path = isRelative(name);\r\n\r\n            if (path) {\r\n                if (!base) throw new Error(\"No reference point given for path '\" + name + \"'\");\r\n                base = findState(base);\r\n\r\n                var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\r\n\r\n                for (; i < pathLength; i++) {\r\n                    if (rel[i] === \"\" && i === 0) {\r\n                        current = base;\r\n                        continue;\r\n                    }\r\n                    if (rel[i] === \"^\") {\r\n                        if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\r\n                        current = current.parent;\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n                rel = rel.slice(i).join(\".\");\r\n                name = current.name + (current.name && rel ? \".\" : \"\") + rel;\r\n            }\r\n            var state = states[name];\r\n\r\n            if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\r\n                return state;\r\n            }\r\n            return undefined;\r\n        }\r\n\r\n        function queueState(parentName, state) {\r\n            if (!queue[parentName]) {\r\n                queue[parentName] = [];\r\n            }\r\n            queue[parentName].push(state);\r\n        }\r\n\r\n        function flushQueuedChildren(parentName) {\r\n            var queued = queue[parentName] || [];\r\n            while (queued.length) {\r\n                registerState(queued.shift());\r\n            }\r\n        }\r\n\r\n        function registerState(state) {\r\n            // Wrap a new object around the state so we can store our private details easily.\r\n            state = inherit(state, {\r\n                self: state,\r\n                resolve: state.resolve || {},\r\n                toString: function () { return this.name; }\r\n            });\r\n\r\n            var name = state.name;\r\n            if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\r\n            if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\r\n\r\n            // Get parent name\r\n            var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\r\n                : (isString(state.parent)) ? state.parent\r\n                : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\r\n                : '';\r\n\r\n            // If parent is not registered yet, add state to queue and register later\r\n            if (parentName && !states[parentName]) {\r\n                return queueState(parentName, state.self);\r\n            }\r\n\r\n            for (var key in stateBuilder) {\r\n                if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\r\n            }\r\n            states[name] = state;\r\n\r\n            // Register the state in the global state list and with $urlRouter if necessary.\r\n            if (!state[abstractKey] && state.url) {\r\n                $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\r\n                    if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\r\n                        $state.transitionTo(state, $match, { inherit: true, location: false });\r\n                    }\r\n                }]);\r\n            }\r\n\r\n            // Register any queued children\r\n            flushQueuedChildren(name);\r\n\r\n            return state;\r\n        }\r\n\r\n        // Checks text to see if it looks like a glob.\r\n        function isGlob(text) {\r\n            return text.indexOf('*') > -1;\r\n        }\r\n\r\n        // Returns true if glob matches current $state name.\r\n        function doesStateMatchGlob(glob) {\r\n            var globSegments = glob.split('.'),\r\n                segments = $state.$current.name.split('.');\r\n\r\n            //match single stars\r\n            for (var i = 0, l = globSegments.length; i < l; i++) {\r\n                if (globSegments[i] === '*') {\r\n                    segments[i] = '*';\r\n                }\r\n            }\r\n\r\n            //match greedy starts\r\n            if (globSegments[0] === '**') {\r\n                segments = segments.slice(indexOf(segments, globSegments[1]));\r\n                segments.unshift('**');\r\n            }\r\n            //match greedy ends\r\n            if (globSegments[globSegments.length - 1] === '**') {\r\n                segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\r\n                segments.push('**');\r\n            }\r\n\r\n            if (globSegments.length != segments.length) {\r\n                return false;\r\n            }\r\n\r\n            return segments.join('') === globSegments.join('');\r\n        }\r\n\r\n\r\n        // Implicit root state that is always active\r\n        root = registerState({\r\n            name: '',\r\n            url: '^',\r\n            views: null,\r\n            'abstract': true\r\n        });\r\n        root.navigable = null;\r\n\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.state.$stateProvider#decorator\r\n         * @methodOf ui.router.state.$stateProvider\r\n         *\r\n         * @description\r\n         * Allows you to extend (carefully) or override (at your own peril) the \r\n         * `stateBuilder` object used internally by `$stateProvider`. This can be used \r\n         * to add custom functionality to ui-router, for example inferring templateUrl \r\n         * based on the state name.\r\n         *\r\n         * When passing only a name, it returns the current (original or decorated) builder\r\n         * function that matches `name`.\r\n         *\r\n         * The builder functions that can be decorated are listed below. Though not all\r\n         * necessarily have a good use case for decoration, that is up to you to decide.\r\n         *\r\n         * In addition, users can attach custom decorators, which will generate new \r\n         * properties within the state's internal definition. There is currently no clear \r\n         * use-case for this beyond accessing internal states (i.e. $state.$current), \r\n         * however, expect this to become increasingly relevant as we introduce additional \r\n         * meta-programming features.\r\n         *\r\n         * **Warning**: Decorators should not be interdependent because the order of \r\n         * execution of the builder functions in non-deterministic. Builder functions \r\n         * should only be dependent on the state definition object and super function.\r\n         *\r\n         *\r\n         * Existing builder functions and current return values:\r\n         *\r\n         * - **parent** `{object}` - returns the parent state object.\r\n         * - **data** `{object}` - returns state data, including any inherited data that is not\r\n         *   overridden by own values (if any).\r\n         * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\r\n         *   or `null`.\r\n         * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \r\n         *   navigable).\r\n         * - **params** `{object}` - returns an array of state params that are ensured to \r\n         *   be a super-set of parent's params.\r\n         * - **views** `{object}` - returns a views object where each key is an absolute view \r\n         *   name (i.e. \"viewName@stateName\") and each value is the config object \r\n         *   (template, controller) for the view. Even when you don't use the views object \r\n         *   explicitly on a state config, one is still created for you internally.\r\n         *   So by decorating this builder function you have access to decorating template \r\n         *   and controller properties.\r\n         * - **ownParams** `{object}` - returns an array of params that belong to the state, \r\n         *   not including any params defined by ancestor states.\r\n         * - **path** `{string}` - returns the full path from the root down to this state. \r\n         *   Needed for state activation.\r\n         * - **includes** `{object}` - returns an object that includes every state that \r\n         *   would pass a `$state.includes()` test.\r\n         *\r\n         * @example\r\n         * <pre>\r\n         * // Override the internal 'views' builder with a function that takes the state\r\n         * // definition, and a reference to the internal function being overridden:\r\n         * $stateProvider.decorator('views', function (state, parent) {\r\n         *   var result = {},\r\n         *       views = parent(state);\r\n         *\r\n         *   angular.forEach(views, function (config, name) {\r\n         *     var autoName = (state.name + '.' + name).replace('.', '/');\r\n         *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\r\n         *     result[name] = config;\r\n         *   });\r\n         *   return result;\r\n         * });\r\n         *\r\n         * $stateProvider.state('home', {\r\n         *   views: {\r\n         *     'contact.list': { controller: 'ListController' },\r\n         *     'contact.item': { controller: 'ItemController' }\r\n         *   }\r\n         * });\r\n         *\r\n         * // ...\r\n         *\r\n         * $state.go('home');\r\n         * // Auto-populates list and item views with /partials/home/contact/list.html,\r\n         * // and /partials/home/contact/item.html, respectively.\r\n         * </pre>\r\n         *\r\n         * @param {string} name The name of the builder function to decorate. \r\n         * @param {object} func A function that is responsible for decorating the original \r\n         * builder function. The function receives two parameters:\r\n         *\r\n         *   - `{object}` - state - The state config object.\r\n         *   - `{object}` - super - The original builder function.\r\n         *\r\n         * @return {object} $stateProvider - $stateProvider instance\r\n         */\r\n        this.decorator = decorator;\r\n        function decorator(name, func) {\r\n            /*jshint validthis: true */\r\n            if (isString(name) && !isDefined(func)) {\r\n                return stateBuilder[name];\r\n            }\r\n            if (!isFunction(func) || !isString(name)) {\r\n                return this;\r\n            }\r\n            if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\r\n                stateBuilder.$delegates[name] = stateBuilder[name];\r\n            }\r\n            stateBuilder[name] = func;\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.state.$stateProvider#state\r\n         * @methodOf ui.router.state.$stateProvider\r\n         *\r\n         * @description\r\n         * Registers a state configuration under a given state name. The stateConfig object\r\n         * has the following acceptable properties.\r\n         *\r\n         * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\r\n         * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\r\n         * @param {object} stateConfig State configuration object.\r\n         * @param {string|function=} stateConfig.template\r\n         * <a id='template'></a>\r\n         *   html template as a string or a function that returns\r\n         *   an html template as a string which should be used by the uiView directives. This property \r\n         *   takes precedence over templateUrl.\r\n         *   \r\n         *   If `template` is a function, it will be called with the following parameters:\r\n         *\r\n         *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\r\n         *     applying the current state\r\n         *\r\n         * <pre>template:\r\n         *   \"<h1>inline template definition</h1>\" +\r\n         *   \"<div ui-view></div>\"</pre>\r\n         * <pre>template: function(params) {\r\n         *       return \"<h1>generated template</h1>\"; }</pre>\r\n         * </div>\r\n         *\r\n         * @param {string|function=} stateConfig.templateUrl\r\n         * <a id='templateUrl'></a>\r\n         *\r\n         *   path or function that returns a path to an html\r\n         *   template that should be used by uiView.\r\n         *   \r\n         *   If `templateUrl` is a function, it will be called with the following parameters:\r\n         *\r\n         *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \r\n         *     applying the current state\r\n         *\r\n         * <pre>templateUrl: \"home.html\"</pre>\r\n         * <pre>templateUrl: function(params) {\r\n         *     return myTemplates[params.pageId]; }</pre>\r\n         *\r\n         * @param {function=} stateConfig.templateProvider\r\n         * <a id='templateProvider'></a>\r\n         *    Provider function that returns HTML content string.\r\n         * <pre> templateProvider:\r\n         *       function(MyTemplateService, params) {\r\n         *         return MyTemplateService.getTemplate(params.pageId);\r\n         *       }</pre>\r\n         *\r\n         * @param {string|function=} stateConfig.controller\r\n         * <a id='controller'></a>\r\n         *\r\n         *  Controller fn that should be associated with newly\r\n         *   related scope or the name of a registered controller if passed as a string.\r\n         *   Optionally, the ControllerAs may be declared here.\r\n         * <pre>controller: \"MyRegisteredController\"</pre>\r\n         * <pre>controller:\r\n         *     \"MyRegisteredController as fooCtrl\"}</pre>\r\n         * <pre>controller: function($scope, MyService) {\r\n         *     $scope.data = MyService.getData(); }</pre>\r\n         *\r\n         * @param {function=} stateConfig.controllerProvider\r\n         * <a id='controllerProvider'></a>\r\n         *\r\n         * Injectable provider function that returns the actual controller or string.\r\n         * <pre>controllerProvider:\r\n         *   function(MyResolveData) {\r\n         *     if (MyResolveData.foo)\r\n         *       return \"FooCtrl\"\r\n         *     else if (MyResolveData.bar)\r\n         *       return \"BarCtrl\";\r\n         *     else return function($scope) {\r\n         *       $scope.baz = \"Qux\";\r\n         *     }\r\n         *   }</pre>\r\n         *\r\n         * @param {string=} stateConfig.controllerAs\r\n         * <a id='controllerAs'></a>\r\n         * \r\n         * A controller alias name. If present the controller will be\r\n         *   published to scope under the controllerAs name.\r\n         * <pre>controllerAs: \"myCtrl\"</pre>\r\n         *\r\n         * @param {string|object=} stateConfig.parent\r\n         * <a id='parent'></a>\r\n         * Optionally specifies the parent state of this state.\r\n         *\r\n         * <pre>parent: 'parentState'</pre>\r\n         * <pre>parent: parentState // JS variable</pre>\r\n         *\r\n         * @param {object=} stateConfig.resolve\r\n         * <a id='resolve'></a>\r\n         *\r\n         * An optional map&lt;string, function&gt; of dependencies which\r\n         *   should be injected into the controller. If any of these dependencies are promises, \r\n         *   the router will wait for them all to be resolved before the controller is instantiated.\r\n         *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\r\n         *   and the values of the resolved promises are injected into any controllers that reference them.\r\n         *   If any  of the promises are rejected the $stateChangeError event is fired.\r\n         *\r\n         *   The map object is:\r\n         *   \r\n         *   - key - {string}: name of dependency to be injected into controller\r\n         *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \r\n         *     it is injected and return value it treated as dependency. If result is a promise, it is \r\n         *     resolved before its value is injected into controller.\r\n         *\r\n         * <pre>resolve: {\r\n         *     myResolve1:\r\n         *       function($http, $stateParams) {\r\n         *         return $http.get(\"/api/foos/\"+stateParams.fooID);\r\n         *       }\r\n         *     }</pre>\r\n         *\r\n         * @param {string=} stateConfig.url\r\n         * <a id='url'></a>\r\n         *\r\n         *   A url fragment with optional parameters. When a state is navigated or\r\n         *   transitioned to, the `$stateParams` service will be populated with any \r\n         *   parameters that were passed.\r\n         *\r\n         *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\r\n         *   more details on acceptable patterns )\r\n         *\r\n         * examples:\r\n         * <pre>url: \"/home\"\r\n         * url: \"/users/:userid\"\r\n         * url: \"/books/{bookid:[a-zA-Z_-]}\"\r\n         * url: \"/books/{categoryid:int}\"\r\n         * url: \"/books/{publishername:string}/{categoryid:int}\"\r\n         * url: \"/messages?before&after\"\r\n         * url: \"/messages?{before:date}&{after:date}\"\r\n         * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\r\n         * </pre>\r\n         *\r\n         * @param {object=} stateConfig.views\r\n         * <a id='views'></a>\r\n         * an optional map&lt;string, object&gt; which defined multiple views, or targets views\r\n         * manually/explicitly.\r\n         *\r\n         * Examples:\r\n         *\r\n         * Targets three named `ui-view`s in the parent state's template\r\n         * <pre>views: {\r\n         *     header: {\r\n         *       controller: \"headerCtrl\",\r\n         *       templateUrl: \"header.html\"\r\n         *     }, body: {\r\n         *       controller: \"bodyCtrl\",\r\n         *       templateUrl: \"body.html\"\r\n         *     }, footer: {\r\n         *       controller: \"footCtrl\",\r\n         *       templateUrl: \"footer.html\"\r\n         *     }\r\n         *   }</pre>\r\n         *\r\n         * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\r\n         * <pre>views: {\r\n         *     'header@top': {\r\n         *       controller: \"msgHeaderCtrl\",\r\n         *       templateUrl: \"msgHeader.html\"\r\n         *     }, 'body': {\r\n         *       controller: \"messagesCtrl\",\r\n         *       templateUrl: \"messages.html\"\r\n         *     }\r\n         *   }</pre>\r\n         *\r\n         * @param {boolean=} [stateConfig.abstract=false]\r\n         * <a id='abstract'></a>\r\n         * An abstract state will never be directly activated,\r\n         *   but can provide inherited properties to its common children states.\r\n         * <pre>abstract: true</pre>\r\n         *\r\n         * @param {function=} stateConfig.onEnter\r\n         * <a id='onEnter'></a>\r\n         *\r\n         * Callback function for when a state is entered. Good way\r\n         *   to trigger an action or dispatch an event, such as opening a dialog.\r\n         * If minifying your scripts, make sure to explicitly annotate this function,\r\n         * because it won't be automatically annotated by your build tools.\r\n         *\r\n         * <pre>onEnter: function(MyService, $stateParams) {\r\n         *     MyService.foo($stateParams.myParam);\r\n         * }</pre>\r\n         *\r\n         * @param {function=} stateConfig.onExit\r\n         * <a id='onExit'></a>\r\n         *\r\n         * Callback function for when a state is exited. Good way to\r\n         *   trigger an action or dispatch an event, such as opening a dialog.\r\n         * If minifying your scripts, make sure to explicitly annotate this function,\r\n         * because it won't be automatically annotated by your build tools.\r\n         *\r\n         * <pre>onExit: function(MyService, $stateParams) {\r\n         *     MyService.cleanup($stateParams.myParam);\r\n         * }</pre>\r\n         *\r\n         * @param {boolean=} [stateConfig.reloadOnSearch=true]\r\n         * <a id='reloadOnSearch'></a>\r\n         *\r\n         * If `false`, will not retrigger the same state\r\n         *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \r\n         *   Useful for when you'd like to modify $location.search() without triggering a reload.\r\n         * <pre>reloadOnSearch: false</pre>\r\n         *\r\n         * @param {object=} stateConfig.data\r\n         * <a id='data'></a>\r\n         *\r\n         * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\r\n         *   prototypally inherited.  In other words, adding a data property to a state adds it to\r\n         *   the entire subtree via prototypal inheritance.\r\n         *\r\n         * <pre>data: {\r\n         *     requiredRole: 'foo'\r\n         * } </pre>\r\n         *\r\n         * @param {object=} stateConfig.params\r\n         * <a id='params'></a>\r\n         *\r\n         * A map which optionally configures parameters declared in the `url`, or\r\n         *   defines additional non-url parameters.  For each parameter being\r\n         *   configured, add a configuration object keyed to the name of the parameter.\r\n         *\r\n         *   Each parameter configuration object may contain the following properties:\r\n         *\r\n         *   - ** value ** - {object|function=}: specifies the default value for this\r\n         *     parameter.  This implicitly sets this parameter as optional.\r\n         *\r\n         *     When UI-Router routes to a state and no value is\r\n         *     specified for this parameter in the URL or transition, the\r\n         *     default value will be used instead.  If `value` is a function,\r\n         *     it will be injected and invoked, and the return value used.\r\n         *\r\n         *     *Note*: `undefined` is treated as \"no default value\" while `null`\r\n         *     is treated as \"the default value is `null`\".\r\n         *\r\n         *     *Shorthand*: If you only need to configure the default value of the\r\n         *     parameter, you may use a shorthand syntax.   In the **`params`**\r\n         *     map, instead mapping the param name to a full parameter configuration\r\n         *     object, simply set map it to the default parameter value, e.g.:\r\n         *\r\n         * <pre>// define a parameter's default value\r\n         * params: {\r\n         *     param1: { value: \"defaultValue\" }\r\n         * }\r\n         * // shorthand default values\r\n         * params: {\r\n         *     param1: \"defaultValue\",\r\n         *     param2: \"param2Default\"\r\n         * }</pre>\r\n         *\r\n         *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\r\n         *     treated as an array of values.  If you specified a Type, the value will be\r\n         *     treated as an array of the specified Type.  Note: query parameter values\r\n         *     default to a special `\"auto\"` mode.\r\n         *\r\n         *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\r\n         *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\r\n         *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\r\n         *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\r\n         *     value (e.g.: `{ foo: '1' }`).\r\n         *\r\n         * <pre>params: {\r\n         *     param1: { array: true }\r\n         * }</pre>\r\n         *\r\n         *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\r\n         *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\r\n         *     configured default squash policy.\r\n         *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\r\n         *\r\n         *   There are three squash settings:\r\n         *\r\n         *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\r\n         *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\r\n         *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\r\n         *       This can allow for cleaner looking URLs.\r\n         *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\r\n         *\r\n         * <pre>params: {\r\n         *     param1: {\r\n         *       value: \"defaultId\",\r\n         *       squash: true\r\n         * } }\r\n         * // squash \"defaultValue\" to \"~\"\r\n         * params: {\r\n         *     param1: {\r\n         *       value: \"defaultValue\",\r\n         *       squash: \"~\"\r\n         * } }\r\n         * </pre>\r\n         *\r\n         *\r\n         * @example\r\n         * <pre>\r\n         * // Some state name examples\r\n         *\r\n         * // stateName can be a single top-level name (must be unique).\r\n         * $stateProvider.state(\"home\", {});\r\n         *\r\n         * // Or it can be a nested state name. This state is a child of the\r\n         * // above \"home\" state.\r\n         * $stateProvider.state(\"home.newest\", {});\r\n         *\r\n         * // Nest states as deeply as needed.\r\n         * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\r\n         *\r\n         * // state() returns $stateProvider, so you can chain state declarations.\r\n         * $stateProvider\r\n         *   .state(\"home\", {})\r\n         *   .state(\"about\", {})\r\n         *   .state(\"contacts\", {});\r\n         * </pre>\r\n         *\r\n         */\r\n        this.state = state;\r\n        function state(name, definition) {\r\n            /*jshint validthis: true */\r\n            if (isObject(name)) definition = name;\r\n            else definition.name = name;\r\n            registerState(definition);\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * @ngdoc object\r\n         * @name ui.router.state.$state\r\n         *\r\n         * @requires $rootScope\r\n         * @requires $q\r\n         * @requires ui.router.state.$view\r\n         * @requires $injector\r\n         * @requires ui.router.util.$resolve\r\n         * @requires ui.router.state.$stateParams\r\n         * @requires ui.router.router.$urlRouter\r\n         *\r\n         * @property {object} params A param object, e.g. {sectionId: section.id)}, that \r\n         * you'd like to test against the current active state.\r\n         * @property {object} current A reference to the state's config object. However \r\n         * you passed it in. Useful for accessing custom data.\r\n         * @property {object} transition Currently pending transition. A promise that'll \r\n         * resolve or reject.\r\n         *\r\n         * @description\r\n         * `$state` service is responsible for representing states as well as transitioning\r\n         * between them. It also provides interfaces to ask for current state or even states\r\n         * you're coming from.\r\n         */\r\n        this.$get = $get;\r\n        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\r\n        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {\r\n\r\n            var TransitionSuperseded = $q.reject(new Error('transition superseded'));\r\n            var TransitionPrevented = $q.reject(new Error('transition prevented'));\r\n            var TransitionAborted = $q.reject(new Error('transition aborted'));\r\n            var TransitionFailed = $q.reject(new Error('transition failed'));\r\n\r\n            // Handles the case where a state which is the target of a transition is not found, and the user\r\n            // can optionally retry or defer the transition\r\n            function handleRedirect(redirect, state, params, options) {\r\n                /**\r\n                 * @ngdoc event\r\n                 * @name ui.router.state.$state#$stateNotFound\r\n                 * @eventOf ui.router.state.$state\r\n                 * @eventType broadcast on root scope\r\n                 * @description\r\n                 * Fired when a requested state **cannot be found** using the provided state name during transition.\r\n                 * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\r\n                 * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\r\n                 * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\r\n                 * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\r\n                 *\r\n                 * @param {Object} event Event object.\r\n                 * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\r\n                 * @param {State} fromState Current state object.\r\n                 * @param {Object} fromParams Current state params.\r\n                 *\r\n                 * @example\r\n                 *\r\n                 * <pre>\r\n                 * // somewhere, assume lazy.state has not been defined\r\n                 * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\r\n                 *\r\n                 * // somewhere else\r\n                 * $scope.$on('$stateNotFound',\r\n                 * function(event, unfoundState, fromState, fromParams){\r\n                 *     console.log(unfoundState.to); // \"lazy.state\"\r\n                 *     console.log(unfoundState.toParams); // {a:1, b:2}\r\n                 *     console.log(unfoundState.options); // {inherit:false} + default options\r\n                 * })\r\n                 * </pre>\r\n                 */\r\n                var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\r\n\r\n                if (evt.defaultPrevented) {\r\n                    $urlRouter.update();\r\n                    return TransitionAborted;\r\n                }\r\n\r\n                if (!evt.retry) {\r\n                    return null;\r\n                }\r\n\r\n                // Allow the handler to return a promise to defer state lookup retry\r\n                if (options.$retry) {\r\n                    $urlRouter.update();\r\n                    return TransitionFailed;\r\n                }\r\n                var retryTransition = $state.transition = $q.when(evt.retry);\r\n\r\n                retryTransition.then(function () {\r\n                    if (retryTransition !== $state.transition) return TransitionSuperseded;\r\n                    redirect.options.$retry = true;\r\n                    return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\r\n                }, function () {\r\n                    return TransitionAborted;\r\n                });\r\n                $urlRouter.update();\r\n\r\n                return retryTransition;\r\n            }\r\n\r\n            root.locals = { resolve: null, globals: { $stateParams: {} } };\r\n\r\n            $state = {\r\n                params: {},\r\n                current: root.self,\r\n                $current: root,\r\n                transition: null\r\n            };\r\n\r\n            /**\r\n             * @ngdoc function\r\n             * @name ui.router.state.$state#reload\r\n             * @methodOf ui.router.state.$state\r\n             *\r\n             * @description\r\n             * A method that force reloads the current state. All resolves are re-resolved,\r\n             * controllers reinstantiated, and events re-fired.\r\n             *\r\n             * @example\r\n             * <pre>\r\n             * var app angular.module('app', ['ui.router']);\r\n             *\r\n             * app.controller('ctrl', function ($scope, $state) {\r\n             *   $scope.reload = function(){\r\n             *     $state.reload();\r\n             *   }\r\n             * });\r\n             * </pre>\r\n             *\r\n             * `reload()` is just an alias for:\r\n             * <pre>\r\n             * $state.transitionTo($state.current, $stateParams, { \r\n             *   reload: true, inherit: false, notify: true\r\n             * });\r\n             * </pre>\r\n             *\r\n             * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\r\n             * @example\r\n             * <pre>\r\n             * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \r\n             * //and current state is 'contacts.detail.item'\r\n             * var app angular.module('app', ['ui.router']);\r\n             *\r\n             * app.controller('ctrl', function ($scope, $state) {\r\n             *   $scope.reload = function(){\r\n             *     //will reload 'contact.detail' and 'contact.detail.item' states\r\n             *     $state.reload('contact.detail');\r\n             *   }\r\n             * });\r\n             * </pre>\r\n             *\r\n             * `reload()` is just an alias for:\r\n             * <pre>\r\n             * $state.transitionTo($state.current, $stateParams, { \r\n             *   reload: true, inherit: false, notify: true\r\n             * });\r\n             * </pre>\r\n        \r\n             * @returns {promise} A promise representing the state of the new transition. See\r\n             * {@link ui.router.state.$state#methods_go $state.go}.\r\n             */\r\n            $state.reload = function reload(state) {\r\n                return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true });\r\n            };\r\n\r\n            /**\r\n             * @ngdoc function\r\n             * @name ui.router.state.$state#go\r\n             * @methodOf ui.router.state.$state\r\n             *\r\n             * @description\r\n             * Convenience method for transitioning to a new state. `$state.go` calls \r\n             * `$state.transitionTo` internally but automatically sets options to \r\n             * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \r\n             * This allows you to easily use an absolute or relative to path and specify \r\n             * only the parameters you'd like to update (while letting unspecified parameters \r\n             * inherit from the currently active ancestor states).\r\n             *\r\n             * @example\r\n             * <pre>\r\n             * var app = angular.module('app', ['ui.router']);\r\n             *\r\n             * app.controller('ctrl', function ($scope, $state) {\r\n             *   $scope.changeState = function () {\r\n             *     $state.go('contact.detail');\r\n             *   };\r\n             * });\r\n             * </pre>\r\n             * <img src='../ngdoc_assets/StateGoExamples.png'/>\r\n             *\r\n             * @param {string} to Absolute state name or relative state path. Some examples:\r\n             *\r\n             * - `$state.go('contact.detail')` - will go to the `contact.detail` state\r\n             * - `$state.go('^')` - will go to a parent state\r\n             * - `$state.go('^.sibling')` - will go to a sibling state\r\n             * - `$state.go('.child.grandchild')` - will go to grandchild state\r\n             *\r\n             * @param {object=} params A map of the parameters that will be sent to the state, \r\n             * will populate $stateParams. Any parameters that are not specified will be inherited from currently \r\n             * defined parameters. Only parameters specified in the state definition can be overridden, new \r\n             * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\r\n             * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\r\n             * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\r\n             * will get you all current parameters, etc.\r\n             * @param {object=} options Options object. The options are:\r\n             *\r\n             * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\r\n             *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\r\n             * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\r\n             * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \r\n             *    defines which state to be relative from.\r\n             * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\r\n             * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\r\n             *    have changed.  It will reload the resolves and views of the current state and parent states.\r\n             *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\r\n             *    the transition reloads the resolves and views for that matched state, and all its children states.\r\n             *\r\n             * @returns {promise} A promise representing the state of the new transition.\r\n             *\r\n             * Possible success values:\r\n             *\r\n             * - $state.current\r\n             *\r\n             * <br/>Possible rejection values:\r\n             *\r\n             * - 'transition superseded' - when a newer transition has been started after this one\r\n             * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\r\n             * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\r\n             *   when a `$stateNotFound` `event.retry` promise errors.\r\n             * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\r\n             * - *resolve error* - when an error has occurred with a `resolve`\r\n             *\r\n             */\r\n            $state.go = function go(to, params, options) {\r\n                return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\r\n            };\r\n\r\n            /**\r\n             * @ngdoc function\r\n             * @name ui.router.state.$state#transitionTo\r\n             * @methodOf ui.router.state.$state\r\n             *\r\n             * @description\r\n             * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\r\n             * uses `transitionTo` internally. `$state.go` is recommended in most situations.\r\n             *\r\n             * @example\r\n             * <pre>\r\n             * var app = angular.module('app', ['ui.router']);\r\n             *\r\n             * app.controller('ctrl', function ($scope, $state) {\r\n             *   $scope.changeState = function () {\r\n             *     $state.transitionTo('contact.detail');\r\n             *   };\r\n             * });\r\n             * </pre>\r\n             *\r\n             * @param {string} to State name.\r\n             * @param {object=} toParams A map of the parameters that will be sent to the state,\r\n             * will populate $stateParams.\r\n             * @param {object=} options Options object. The options are:\r\n             *\r\n             * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\r\n             *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\r\n             * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\r\n             * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \r\n             *    defines which state to be relative from.\r\n             * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\r\n             * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \r\n             *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\r\n             *    use this when you want to force a reload when *everything* is the same, including search params.\r\n             *    if String, then will reload the state with the name given in reload, and any children.\r\n             *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\r\n             *\r\n             * @returns {promise} A promise representing the state of the new transition. See\r\n             * {@link ui.router.state.$state#methods_go $state.go}.\r\n             */\r\n            $state.transitionTo = function transitionTo(to, toParams, options) {\r\n                toParams = toParams || {};\r\n                options = extend({\r\n                    location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\r\n                }, options || {});\r\n\r\n                var from = $state.$current, fromParams = $state.params, fromPath = from.path;\r\n                var evt, toState = findState(to, options.relative);\r\n\r\n                // Store the hash param for later (since it will be stripped out by various methods)\r\n                var hash = toParams['#'];\r\n\r\n                if (!isDefined(toState)) {\r\n                    var redirect = { to: to, toParams: toParams, options: options };\r\n                    var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\r\n\r\n                    if (redirectResult) {\r\n                        return redirectResult;\r\n                    }\r\n\r\n                    // Always retry once if the $stateNotFound was not prevented\r\n                    // (handles either redirect changed or state lazy-definition)\r\n                    to = redirect.to;\r\n                    toParams = redirect.toParams;\r\n                    options = redirect.options;\r\n                    toState = findState(to, options.relative);\r\n\r\n                    if (!isDefined(toState)) {\r\n                        if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\r\n                        throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\r\n                    }\r\n                }\r\n                if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\r\n                if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\r\n                if (!toState.params.$$validates(toParams)) return TransitionFailed;\r\n\r\n                toParams = toState.params.$$values(toParams);\r\n                to = toState;\r\n\r\n                var toPath = to.path;\r\n\r\n                // Starting from the root of the path, keep all levels that haven't changed\r\n                var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\r\n\r\n                if (!options.reload) {\r\n                    while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\r\n                        locals = toLocals[keep] = state.locals;\r\n                        keep++;\r\n                        state = toPath[keep];\r\n                    }\r\n                } else if (isString(options.reload) || isObject(options.reload)) {\r\n                    if (isObject(options.reload) && !options.reload.name) {\r\n                        throw new Error('Invalid reload state object');\r\n                    }\r\n\r\n                    var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\r\n                    if (options.reload && !reloadState) {\r\n                        throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\r\n                    }\r\n\r\n                    while (state && state === fromPath[keep] && state !== reloadState) {\r\n                        locals = toLocals[keep] = state.locals;\r\n                        keep++;\r\n                        state = toPath[keep];\r\n                    }\r\n                }\r\n\r\n                // If we're going to the same state and all locals are kept, we've got nothing to do.\r\n                // But clear 'transition', as we still want to cancel any other pending transitions.\r\n                // TODO: We may not want to bump 'transition' if we're called from a location change\r\n                // that we've initiated ourselves, because we might accidentally abort a legitimate\r\n                // transition initiated from code?\r\n                if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\r\n                    if (hash) toParams['#'] = hash;\r\n                    $state.params = toParams;\r\n                    copy($state.params, $stateParams);\r\n                    copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\r\n                    if (options.location && to.navigable && to.navigable.url) {\r\n                        $urlRouter.push(to.navigable.url, toParams, {\r\n                            $$avoidResync: true, replace: options.location === 'replace'\r\n                        });\r\n                        $urlRouter.update(true);\r\n                    }\r\n                    $state.transition = null;\r\n                    return $q.when($state.current);\r\n                }\r\n\r\n                // Filter parameters before we pass them to event handlers etc.\r\n                toParams = filterByKeys(to.params.$$keys(), toParams || {});\r\n\r\n                // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\r\n                if (hash) toParams['#'] = hash;\r\n\r\n                // Broadcast start event and cancel the transition if requested\r\n                if (options.notify) {\r\n                    /**\r\n                     * @ngdoc event\r\n                     * @name ui.router.state.$state#$stateChangeStart\r\n                     * @eventOf ui.router.state.$state\r\n                     * @eventType broadcast on root scope\r\n                     * @description\r\n                     * Fired when the state transition **begins**. You can use `event.preventDefault()`\r\n                     * to prevent the transition from happening and then the transition promise will be\r\n                     * rejected with a `'transition prevented'` value.\r\n                     *\r\n                     * @param {Object} event Event object.\r\n                     * @param {State} toState The state being transitioned to.\r\n                     * @param {Object} toParams The params supplied to the `toState`.\r\n                     * @param {State} fromState The current state, pre-transition.\r\n                     * @param {Object} fromParams The params supplied to the `fromState`.\r\n                     *\r\n                     * @example\r\n                     *\r\n                     * <pre>\r\n                     * $rootScope.$on('$stateChangeStart',\r\n                     * function(event, toState, toParams, fromState, fromParams){\r\n                     *     event.preventDefault();\r\n                     *     // transitionTo() promise will be rejected with\r\n                     *     // a 'transition prevented' error\r\n                     * })\r\n                     * </pre>\r\n                     */\r\n                    if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\r\n                        $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\r\n                        //Don't update and resync url if there's been a new transition started. see issue #2238, #600\r\n                        if ($state.transition == null) $urlRouter.update();\r\n                        return TransitionPrevented;\r\n                    }\r\n                }\r\n\r\n                // Resolve locals for the remaining states, but don't update any global state just\r\n                // yet -- if anything fails to resolve the current state needs to remain untouched.\r\n                // We also set up an inheritance chain for the locals here. This allows the view directive\r\n                // to quickly look up the correct definition for each view in the current state. Even\r\n                // though we create the locals object itself outside resolveState(), it is initially\r\n                // empty and gets filled asynchronously. We need to keep track of the promise for the\r\n                // (fully resolved) current locals, and pass this down the chain.\r\n                var resolved = $q.when(locals);\r\n\r\n                for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\r\n                    locals = toLocals[l] = inherit(locals);\r\n                    resolved = resolveState(state, toParams, state === to, resolved, locals, options);\r\n                }\r\n\r\n                // Once everything is resolved, we are ready to perform the actual transition\r\n                // and return a promise for the new state. We also keep track of what the\r\n                // current promise is, so that we can detect overlapping transitions and\r\n                // keep only the outcome of the last transition.\r\n                var transition = $state.transition = resolved.then(function () {\r\n                    var l, entering, exiting;\r\n\r\n                    if ($state.transition !== transition) return TransitionSuperseded;\r\n\r\n                    // Exit 'from' states not kept\r\n                    for (l = fromPath.length - 1; l >= keep; l--) {\r\n                        exiting = fromPath[l];\r\n                        if (exiting.self.onExit) {\r\n                            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\r\n                        }\r\n                        exiting.locals = null;\r\n                    }\r\n\r\n                    // Enter 'to' states not kept\r\n                    for (l = keep; l < toPath.length; l++) {\r\n                        entering = toPath[l];\r\n                        entering.locals = toLocals[l];\r\n                        if (entering.self.onEnter) {\r\n                            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\r\n                        }\r\n                    }\r\n\r\n                    // Run it again, to catch any transitions in callbacks\r\n                    if ($state.transition !== transition) return TransitionSuperseded;\r\n\r\n                    // Update globals in $state\r\n                    $state.$current = to;\r\n                    $state.current = to.self;\r\n                    $state.params = toParams;\r\n                    copy($state.params, $stateParams);\r\n                    $state.transition = null;\r\n\r\n                    if (options.location && to.navigable) {\r\n                        $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\r\n                            $$avoidResync: true, replace: options.location === 'replace'\r\n                        });\r\n                    }\r\n\r\n                    if (options.notify) {\r\n                        /**\r\n                         * @ngdoc event\r\n                         * @name ui.router.state.$state#$stateChangeSuccess\r\n                         * @eventOf ui.router.state.$state\r\n                         * @eventType broadcast on root scope\r\n                         * @description\r\n                         * Fired once the state transition is **complete**.\r\n                         *\r\n                         * @param {Object} event Event object.\r\n                         * @param {State} toState The state being transitioned to.\r\n                         * @param {Object} toParams The params supplied to the `toState`.\r\n                         * @param {State} fromState The current state, pre-transition.\r\n                         * @param {Object} fromParams The params supplied to the `fromState`.\r\n                         */\r\n                        $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\r\n                    }\r\n                    $urlRouter.update(true);\r\n\r\n                    return $state.current;\r\n                }, function (error) {\r\n                    if ($state.transition !== transition) return TransitionSuperseded;\r\n\r\n                    $state.transition = null;\r\n                    /**\r\n                     * @ngdoc event\r\n                     * @name ui.router.state.$state#$stateChangeError\r\n                     * @eventOf ui.router.state.$state\r\n                     * @eventType broadcast on root scope\r\n                     * @description\r\n                     * Fired when an **error occurs** during transition. It's important to note that if you\r\n                     * have any errors in your resolve functions (javascript errors, non-existent services, etc)\r\n                     * they will not throw traditionally. You must listen for this $stateChangeError event to\r\n                     * catch **ALL** errors.\r\n                     *\r\n                     * @param {Object} event Event object.\r\n                     * @param {State} toState The state being transitioned to.\r\n                     * @param {Object} toParams The params supplied to the `toState`.\r\n                     * @param {State} fromState The current state, pre-transition.\r\n                     * @param {Object} fromParams The params supplied to the `fromState`.\r\n                     * @param {Error} error The resolve error object.\r\n                     */\r\n                    evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\r\n\r\n                    if (!evt.defaultPrevented) {\r\n                        $urlRouter.update();\r\n                    }\r\n\r\n                    return $q.reject(error);\r\n                });\r\n\r\n                return transition;\r\n            };\r\n\r\n            /**\r\n             * @ngdoc function\r\n             * @name ui.router.state.$state#is\r\n             * @methodOf ui.router.state.$state\r\n             *\r\n             * @description\r\n             * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\r\n             * but only checks for the full state name. If params is supplied then it will be\r\n             * tested for strict equality against the current active params object, so all params\r\n             * must match with none missing and no extras.\r\n             *\r\n             * @example\r\n             * <pre>\r\n             * $state.$current.name = 'contacts.details.item';\r\n             *\r\n             * // absolute name\r\n             * $state.is('contact.details.item'); // returns true\r\n             * $state.is(contactDetailItemStateObject); // returns true\r\n             *\r\n             * // relative name (. and ^), typically from a template\r\n             * // E.g. from the 'contacts.details' template\r\n             * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\r\n             * </pre>\r\n             *\r\n             * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\r\n             * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\r\n             * to test against the current active state.\r\n             * @param {object=} options An options object.  The options are:\r\n             *\r\n             * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\r\n             * test relative to `options.relative` state (or name).\r\n             *\r\n             * @returns {boolean} Returns true if it is the state.\r\n             */\r\n            $state.is = function is(stateOrName, params, options) {\r\n                options = extend({ relative: $state.$current }, options || {});\r\n                var state = findState(stateOrName, options.relative);\r\n\r\n                if (!isDefined(state)) { return undefined; }\r\n                if ($state.$current !== state) { return false; }\r\n                return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\r\n            };\r\n\r\n            /**\r\n             * @ngdoc function\r\n             * @name ui.router.state.$state#includes\r\n             * @methodOf ui.router.state.$state\r\n             *\r\n             * @description\r\n             * A method to determine if the current active state is equal to or is the child of the\r\n             * state stateName. If any params are passed then they will be tested for a match as well.\r\n             * Not all the parameters need to be passed, just the ones you'd like to test for equality.\r\n             *\r\n             * @example\r\n             * Partial and relative names\r\n             * <pre>\r\n             * $state.$current.name = 'contacts.details.item';\r\n             *\r\n             * // Using partial names\r\n             * $state.includes(\"contacts\"); // returns true\r\n             * $state.includes(\"contacts.details\"); // returns true\r\n             * $state.includes(\"contacts.details.item\"); // returns true\r\n             * $state.includes(\"contacts.list\"); // returns false\r\n             * $state.includes(\"about\"); // returns false\r\n             *\r\n             * // Using relative names (. and ^), typically from a template\r\n             * // E.g. from the 'contacts.details' template\r\n             * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\r\n             * </pre>\r\n             *\r\n             * Basic globbing patterns\r\n             * <pre>\r\n             * $state.$current.name = 'contacts.details.item.url';\r\n             *\r\n             * $state.includes(\"*.details.*.*\"); // returns true\r\n             * $state.includes(\"*.details.**\"); // returns true\r\n             * $state.includes(\"**.item.**\"); // returns true\r\n             * $state.includes(\"*.details.item.url\"); // returns true\r\n             * $state.includes(\"*.details.*.url\"); // returns true\r\n             * $state.includes(\"*.details.*\"); // returns false\r\n             * $state.includes(\"item.**\"); // returns false\r\n             * </pre>\r\n             *\r\n             * @param {string} stateOrName A partial name, relative name, or glob pattern\r\n             * to be searched for within the current state name.\r\n             * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\r\n             * that you'd like to test against the current active state.\r\n             * @param {object=} options An options object.  The options are:\r\n             *\r\n             * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\r\n             * .includes will test relative to `options.relative` state (or name).\r\n             *\r\n             * @returns {boolean} Returns true if it does include the state\r\n             */\r\n            $state.includes = function includes(stateOrName, params, options) {\r\n                options = extend({ relative: $state.$current }, options || {});\r\n                if (isString(stateOrName) && isGlob(stateOrName)) {\r\n                    if (!doesStateMatchGlob(stateOrName)) {\r\n                        return false;\r\n                    }\r\n                    stateOrName = $state.$current.name;\r\n                }\r\n\r\n                var state = findState(stateOrName, options.relative);\r\n                if (!isDefined(state)) { return undefined; }\r\n                if (!isDefined($state.$current.includes[state.name])) { return false; }\r\n                return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\r\n            };\r\n\r\n\r\n            /**\r\n             * @ngdoc function\r\n             * @name ui.router.state.$state#href\r\n             * @methodOf ui.router.state.$state\r\n             *\r\n             * @description\r\n             * A url generation method that returns the compiled url for the given state populated with the given params.\r\n             *\r\n             * @example\r\n             * <pre>\r\n             * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\r\n             * </pre>\r\n             *\r\n             * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\r\n             * @param {object=} params An object of parameter values to fill the state's required parameters.\r\n             * @param {object=} options Options object. The options are:\r\n             *\r\n             * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\r\n             *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\r\n             *    ancestor with a valid url).\r\n             * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\r\n             * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \r\n             *    defines which state to be relative from.\r\n             * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\r\n             * \r\n             * @returns {string} compiled state url\r\n             */\r\n            $state.href = function href(stateOrName, params, options) {\r\n                options = extend({\r\n                    lossy: true,\r\n                    inherit: true,\r\n                    absolute: false,\r\n                    relative: $state.$current\r\n                }, options || {});\r\n\r\n                var state = findState(stateOrName, options.relative);\r\n\r\n                if (!isDefined(state)) return null;\r\n                if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\r\n\r\n                var nav = (state && options.lossy) ? state.navigable : state;\r\n\r\n                if (!nav || nav.url === undefined || nav.url === null) {\r\n                    return null;\r\n                }\r\n                return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\r\n                    absolute: options.absolute\r\n                });\r\n            };\r\n\r\n            /**\r\n             * @ngdoc function\r\n             * @name ui.router.state.$state#get\r\n             * @methodOf ui.router.state.$state\r\n             *\r\n             * @description\r\n             * Returns the state configuration object for any specific state or all states.\r\n             *\r\n             * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\r\n             * the requested state. If not provided, returns an array of ALL state configs.\r\n             * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\r\n             * @returns {Object|Array} State configuration object or array of all objects.\r\n             */\r\n            $state.get = function (stateOrName, context) {\r\n                if (arguments.length === 0) return map(objectKeys(states), function (name) { return states[name].self; });\r\n                var state = findState(stateOrName, context || $state.$current);\r\n                return (state && state.self) ? state.self : null;\r\n            };\r\n\r\n            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\r\n                // Make a restricted $stateParams with only the parameters that apply to this state if\r\n                // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\r\n                // we also need $stateParams to be available for any $injector calls we make during the\r\n                // dependency resolution process.\r\n                var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\r\n                var locals = { $stateParams: $stateParams };\r\n\r\n                // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\r\n                // We're also including $stateParams in this; that way the parameters are restricted\r\n                // to the set that should be visible to the state, and are independent of when we update\r\n                // the global $state and $stateParams values.\r\n                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\r\n                var promises = [dst.resolve.then(function (globals) {\r\n                    dst.globals = globals;\r\n                })];\r\n                if (inherited) promises.push(inherited);\r\n\r\n                function resolveViews() {\r\n                    var viewsPromises = [];\r\n\r\n                    // Resolve template and dependencies for all views.\r\n                    forEach(state.views, function (view, name) {\r\n                        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\r\n                        injectables.$template = [function () {\r\n                            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\r\n                        }];\r\n\r\n                        viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\r\n                            // References to the controller (only instantiated at link time)\r\n                            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\r\n                                var injectLocals = angular.extend({}, injectables, dst.globals);\r\n                                result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\r\n                            } else {\r\n                                result.$$controller = view.controller;\r\n                            }\r\n                            // Provide access to the state itself for internal use\r\n                            result.$$state = state;\r\n                            result.$$controllerAs = view.controllerAs;\r\n                            dst[name] = result;\r\n                        }));\r\n                    });\r\n\r\n                    return $q.all(viewsPromises).then(function () {\r\n                        return dst.globals;\r\n                    });\r\n                }\r\n\r\n                // Wait for all the promises and then return the activation object\r\n                return $q.all(promises).then(resolveViews).then(function (values) {\r\n                    return dst;\r\n                });\r\n            }\r\n\r\n            return $state;\r\n        }\r\n\r\n        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\r\n            // Return true if there are no differences in non-search (path/object) params, false if there are differences\r\n            function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\r\n                // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\r\n                function notSearchParam(key) {\r\n                    return fromAndToState.params[key].location != \"search\";\r\n                }\r\n                var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\r\n                var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\r\n                var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\r\n                return nonQueryParamSet.$$equals(fromParams, toParams);\r\n            }\r\n\r\n            // If reload was not explicitly requested\r\n            // and we're transitioning to the same state we're already in\r\n            // and    the locals didn't change\r\n            //     or they changed in a way that doesn't merit reloading\r\n            //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\r\n            // Then return true.\r\n            if (!options.reload && to === from &&\r\n              (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    angular.module('ui.router.state')\r\n      .factory('$stateParams', function () { return {}; })\r\n      .provider('$state', $StateProvider);\r\n\r\n\r\n    $ViewProvider.$inject = [];\r\n    function $ViewProvider() {\r\n\r\n        this.$get = $get;\r\n        /**\r\n         * @ngdoc object\r\n         * @name ui.router.state.$view\r\n         *\r\n         * @requires ui.router.util.$templateFactory\r\n         * @requires $rootScope\r\n         *\r\n         * @description\r\n         *\r\n         */\r\n        $get.$inject = ['$rootScope', '$templateFactory'];\r\n        function $get($rootScope, $templateFactory) {\r\n            return {\r\n                // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\r\n                /**\r\n                 * @ngdoc function\r\n                 * @name ui.router.state.$view#load\r\n                 * @methodOf ui.router.state.$view\r\n                 *\r\n                 * @description\r\n                 *\r\n                 * @param {string} name name\r\n                 * @param {object} options option object.\r\n                 */\r\n                load: function load(name, options) {\r\n                    var result, defaults = {\r\n                        template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\r\n                    };\r\n                    options = extend(defaults, options);\r\n\r\n                    if (options.view) {\r\n                        result = $templateFactory.fromConfig(options.view, options.params, options.locals);\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    angular.module('ui.router.state').provider('$view', $ViewProvider);\r\n\r\n    /**\r\n     * @ngdoc object\r\n     * @name ui.router.state.$uiViewScrollProvider\r\n     *\r\n     * @description\r\n     * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\r\n     */\r\n    function $ViewScrollProvider() {\r\n\r\n        var useAnchorScroll = false;\r\n\r\n        /**\r\n         * @ngdoc function\r\n         * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\r\n         * @methodOf ui.router.state.$uiViewScrollProvider\r\n         *\r\n         * @description\r\n         * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\r\n         * scrolling based on the url anchor.\r\n         */\r\n        this.useAnchorScroll = function () {\r\n            useAnchorScroll = true;\r\n        };\r\n\r\n        /**\r\n         * @ngdoc object\r\n         * @name ui.router.state.$uiViewScroll\r\n         *\r\n         * @requires $anchorScroll\r\n         * @requires $timeout\r\n         *\r\n         * @description\r\n         * When called with a jqLite element, it scrolls the element into view (after a\r\n         * `$timeout` so the DOM has time to refresh).\r\n         *\r\n         * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\r\n         * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\r\n         */\r\n        this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\r\n            if (useAnchorScroll) {\r\n                return $anchorScroll;\r\n            }\r\n\r\n            return function ($element) {\r\n                return $timeout(function () {\r\n                    $element[0].scrollIntoView();\r\n                }, 0, false);\r\n            };\r\n        }];\r\n    }\r\n\r\n    angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\r\n\r\n    var ngMajorVer = angular.version.major;\r\n    var ngMinorVer = angular.version.minor;\r\n    /**\r\n     * @ngdoc directive\r\n     * @name ui.router.state.directive:ui-view\r\n     *\r\n     * @requires ui.router.state.$state\r\n     * @requires $compile\r\n     * @requires $controller\r\n     * @requires $injector\r\n     * @requires ui.router.state.$uiViewScroll\r\n     * @requires $document\r\n     *\r\n     * @restrict ECA\r\n     *\r\n     * @description\r\n     * The ui-view directive tells $state where to place your templates.\r\n     *\r\n     * @param {string=} name A view name. The name should be unique amongst the other views in the\r\n     * same state. You can have views of the same name that live in different states.\r\n     *\r\n     * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\r\n     * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\r\n     * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\r\n     * scroll ui-view elements into view when they are populated during a state activation.\r\n     *\r\n     * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\r\n     * will be applied to the ui-view)\r\n     *\r\n     * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\r\n     * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\r\n     *\r\n     * @param {string=} onload Expression to evaluate whenever the view updates.\r\n     * \r\n     * @example\r\n     * A view can be unnamed or named. \r\n     * <pre>\r\n     * <!-- Unnamed -->\r\n     * <div ui-view></div> \r\n     * \r\n     * <!-- Named -->\r\n     * <div ui-view=\"viewName\"></div>\r\n     * </pre>\r\n     *\r\n     * You can only have one unnamed view within any template (or root html). If you are only using a \r\n     * single view and it is unnamed then you can populate it like so:\r\n     * <pre>\r\n     * <div ui-view></div> \r\n     * $stateProvider.state(\"home\", {\r\n     *   template: \"<h1>HELLO!</h1>\"\r\n     * })\r\n     * </pre>\r\n     * \r\n     * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\r\n     * config property, by name, in this case an empty name:\r\n     * <pre>\r\n     * $stateProvider.state(\"home\", {\r\n     *   views: {\r\n     *     \"\": {\r\n     *       template: \"<h1>HELLO!</h1>\"\r\n     *     }\r\n     *   }    \r\n     * })\r\n     * </pre>\r\n     * \r\n     * But typically you'll only use the views property if you name your view or have more than one view \r\n     * in the same template. There's not really a compelling reason to name a view if its the only one, \r\n     * but you could if you wanted, like so:\r\n     * <pre>\r\n     * <div ui-view=\"main\"></div>\r\n     * </pre> \r\n     * <pre>\r\n     * $stateProvider.state(\"home\", {\r\n     *   views: {\r\n     *     \"main\": {\r\n     *       template: \"<h1>HELLO!</h1>\"\r\n     *     }\r\n     *   }    \r\n     * })\r\n     * </pre>\r\n     * \r\n     * Really though, you'll use views to set up multiple views:\r\n     * <pre>\r\n     * <div ui-view></div>\r\n     * <div ui-view=\"chart\"></div> \r\n     * <div ui-view=\"data\"></div> \r\n     * </pre>\r\n     * \r\n     * <pre>\r\n     * $stateProvider.state(\"home\", {\r\n     *   views: {\r\n     *     \"\": {\r\n     *       template: \"<h1>HELLO!</h1>\"\r\n     *     },\r\n     *     \"chart\": {\r\n     *       template: \"<chart_thing/>\"\r\n     *     },\r\n     *     \"data\": {\r\n     *       template: \"<data_thing/>\"\r\n     *     }\r\n     *   }    \r\n     * })\r\n     * </pre>\r\n     *\r\n     * Examples for `autoscroll`:\r\n     *\r\n     * <pre>\r\n     * <!-- If autoscroll present with no expression,\r\n     *      then scroll ui-view into view -->\r\n     * <ui-view autoscroll/>\r\n     *\r\n     * <!-- If autoscroll present with valid expression,\r\n     *      then scroll ui-view into view if expression evaluates to true -->\r\n     * <ui-view autoscroll='true'/>\r\n     * <ui-view autoscroll='false'/>\r\n     * <ui-view autoscroll='scopeVariable'/>\r\n     * </pre>\r\n     */\r\n    $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\r\n    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {\r\n\r\n        function getService() {\r\n            return ($injector.has) ? function (service) {\r\n                return $injector.has(service) ? $injector.get(service) : null;\r\n            } : function (service) {\r\n                try {\r\n                    return $injector.get(service);\r\n                } catch (e) {\r\n                    return null;\r\n                }\r\n            };\r\n        }\r\n\r\n        var service = getService(),\r\n            $animator = service('$animator'),\r\n            $animate = service('$animate');\r\n\r\n        // Returns a set of DOM manipulation functions based on which Angular version\r\n        // it should use\r\n        function getRenderer(attrs, scope) {\r\n            var statics = {\r\n                enter: function (element, target, cb) { target.after(element); cb(); },\r\n                leave: function (element, cb) { element.remove(); cb(); }\r\n            };\r\n\r\n            if (!!attrs.noanimation) return statics;\r\n\r\n            function animEnabled(element) {\r\n                if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\r\n                if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\r\n                return (!!$animator);\r\n            }\r\n\r\n            // ng 1.2+\r\n            if ($animate) {\r\n                return {\r\n                    enter: function (element, target, cb) {\r\n                        if (!animEnabled(element)) {\r\n                            statics.enter(element, target, cb);\r\n                        } else if (angular.version.minor > 2) {\r\n                            $animate.enter(element, null, target).then(cb);\r\n                        } else {\r\n                            $animate.enter(element, null, target, cb);\r\n                        }\r\n                    },\r\n                    leave: function (element, cb) {\r\n                        if (!animEnabled(element)) {\r\n                            statics.leave(element, cb);\r\n                        } else if (angular.version.minor > 2) {\r\n                            $animate.leave(element).then(cb);\r\n                        } else {\r\n                            $animate.leave(element, cb);\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n\r\n            // ng 1.1.5\r\n            if ($animator) {\r\n                var animate = $animator && $animator(scope, attrs);\r\n\r\n                return {\r\n                    enter: function (element, target, cb) { animate.enter(element, null, target); cb(); },\r\n                    leave: function (element, cb) { animate.leave(element); cb(); }\r\n                };\r\n            }\r\n\r\n            return statics;\r\n        }\r\n\r\n        var directive = {\r\n            restrict: 'ECA',\r\n            terminal: true,\r\n            priority: 400,\r\n            transclude: 'element',\r\n            compile: function (tElement, tAttrs, $transclude) {\r\n                return function (scope, $element, attrs) {\r\n                    var previousEl, currentEl, currentScope, latestLocals,\r\n                        onloadExp = attrs.onload || '',\r\n                        autoScrollExp = attrs.autoscroll,\r\n                        renderer = getRenderer(attrs, scope);\r\n\r\n                    scope.$on('$stateChangeSuccess', function () {\r\n                        updateView(false);\r\n                    });\r\n\r\n                    updateView(true);\r\n\r\n                    function cleanupLastView() {\r\n                        var _previousEl = previousEl;\r\n                        var _currentScope = currentScope;\r\n\r\n                        if (_currentScope) {\r\n                            _currentScope._willBeDestroyed = true;\r\n                        }\r\n\r\n                        function cleanOld() {\r\n                            if (_previousEl) {\r\n                                _previousEl.remove();\r\n                            }\r\n\r\n                            if (_currentScope) {\r\n                                _currentScope.$destroy();\r\n                            }\r\n                        }\r\n\r\n                        if (currentEl) {\r\n                            renderer.leave(currentEl, function () {\r\n                                cleanOld();\r\n                                previousEl = null;\r\n                            });\r\n\r\n                            previousEl = currentEl;\r\n                        } else {\r\n                            cleanOld();\r\n                            previousEl = null;\r\n                        }\r\n\r\n                        currentEl = null;\r\n                        currentScope = null;\r\n                    }\r\n\r\n                    function updateView(firstTime) {\r\n                        var newScope,\r\n                            name = getUiViewName(scope, attrs, $element, $interpolate),\r\n                            previousLocals = name && $state.$current && $state.$current.locals[name];\r\n\r\n                        if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\r\n                        newScope = scope.$new();\r\n                        latestLocals = $state.$current.locals[name];\r\n\r\n                        /**\r\n                         * @ngdoc event\r\n                         * @name ui.router.state.directive:ui-view#$viewContentLoading\r\n                         * @eventOf ui.router.state.directive:ui-view\r\n                         * @eventType emits on ui-view directive scope\r\n                         * @description\r\n                         *\r\n                         * Fired once the view **begins loading**, *before* the DOM is rendered.\r\n                         *\r\n                         * @param {Object} event Event object.\r\n                         * @param {string} viewName Name of the view.\r\n                         */\r\n                        newScope.$emit('$viewContentLoading', name);\r\n\r\n                        var clone = $transclude(newScope, function (clone) {\r\n                            renderer.enter(clone, $element, function onUiViewEnter() {\r\n                                if (currentScope) {\r\n                                    currentScope.$emit('$viewContentAnimationEnded');\r\n                                }\r\n\r\n                                if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\r\n                                    $uiViewScroll(clone);\r\n                                }\r\n                            });\r\n                            cleanupLastView();\r\n                        });\r\n\r\n                        currentEl = clone;\r\n                        currentScope = newScope;\r\n                        /**\r\n                         * @ngdoc event\r\n                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\r\n                         * @eventOf ui.router.state.directive:ui-view\r\n                         * @eventType emits on ui-view directive scope\r\n                         * @description\r\n                         * Fired once the view is **loaded**, *after* the DOM is rendered.\r\n                         *\r\n                         * @param {Object} event Event object.\r\n                         * @param {string} viewName Name of the view.\r\n                         */\r\n                        currentScope.$emit('$viewContentLoaded', name);\r\n                        currentScope.$eval(onloadExp);\r\n                    }\r\n                };\r\n            }\r\n        };\r\n\r\n        return directive;\r\n    }\r\n\r\n    $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\r\n    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {\r\n        return {\r\n            restrict: 'ECA',\r\n            priority: -400,\r\n            compile: function (tElement) {\r\n                var initial = tElement.html();\r\n                return function (scope, $element, attrs) {\r\n                    var current = $state.$current,\r\n                        name = getUiViewName(scope, attrs, $element, $interpolate),\r\n                        locals = current && current.locals[name];\r\n\r\n                    if (!locals) {\r\n                        return;\r\n                    }\r\n\r\n                    $element.data('$uiView', { name: name, state: locals.$$state });\r\n                    $element.html(locals.$template ? locals.$template : initial);\r\n\r\n                    var link = $compile($element.contents());\r\n\r\n                    if (locals.$$controller) {\r\n                        locals.$scope = scope;\r\n                        locals.$element = $element;\r\n                        var controller = $controller(locals.$$controller, locals);\r\n                        if (locals.$$controllerAs) {\r\n                            scope[locals.$$controllerAs] = controller;\r\n                        }\r\n                        $element.data('$ngControllerController', controller);\r\n                        $element.children().data('$ngControllerController', controller);\r\n                    }\r\n\r\n                    link(scope);\r\n                };\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Shared ui-view code for both directives:\r\n     * Given scope, element, and its attributes, return the view's name\r\n     */\r\n    function getUiViewName(scope, attrs, element, $interpolate) {\r\n        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\r\n        var inherited = element.inheritedData('$uiView');\r\n        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));\r\n    }\r\n\r\n    angular.module('ui.router.state').directive('uiView', $ViewDirective);\r\n    angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\r\n\r\n    function parseStateRef(ref, current) {\r\n        var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\r\n        if (preparsed) ref = current + '(' + preparsed[1] + ')';\r\n        parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\r\n        if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\r\n        return { state: parsed[1], paramExpr: parsed[3] || null };\r\n    }\r\n\r\n    function stateContext(el) {\r\n        var stateData = el.parent().inheritedData('$uiView');\r\n\r\n        if (stateData && stateData.state && stateData.state.name) {\r\n            return stateData.state;\r\n        }\r\n    }\r\n\r\n    function getTypeInfo(el) {\r\n        // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\r\n        var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\r\n        var isForm = el[0].nodeName === \"FORM\";\r\n\r\n        return {\r\n            attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\r\n            isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\r\n            clickable: !isForm\r\n        };\r\n    }\r\n\r\n    function clickHook(el, $state, $timeout, type, current) {\r\n        return function (e) {\r\n            var button = e.which || e.button, target = current();\r\n\r\n            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\r\n                // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\r\n                var transition = $timeout(function () {\r\n                    $state.go(target.state, target.params, target.options);\r\n                });\r\n                e.preventDefault();\r\n\r\n                // if the state has no URL, ignore one preventDefault from the <a> directive.\r\n                var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\r\n\r\n                e.preventDefault = function () {\r\n                    if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\r\n                };\r\n            }\r\n        };\r\n    }\r\n\r\n    function defaultOpts(el, $state) {\r\n        return { relative: stateContext(el) || $state.$current, inherit: true };\r\n    }\r\n\r\n    /**\r\n     * @ngdoc directive\r\n     * @name ui.router.state.directive:ui-sref\r\n     *\r\n     * @requires ui.router.state.$state\r\n     * @requires $timeout\r\n     *\r\n     * @restrict A\r\n     *\r\n     * @description\r\n     * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\r\n     * URL, the directive will automatically generate & update the `href` attribute via\r\n     * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\r\n     * the link will trigger a state transition with optional parameters.\r\n     *\r\n     * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\r\n     * handled natively by the browser.\r\n     *\r\n     * You can also use relative state paths within ui-sref, just like the relative\r\n     * paths passed to `$state.go()`. You just need to be aware that the path is relative\r\n     * to the state that the link lives in, in other words the state that loaded the\r\n     * template containing the link.\r\n     *\r\n     * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\r\n     * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\r\n     * and `reload`.\r\n     *\r\n     * @example\r\n     * Here's an example of how you'd use ui-sref and how it would compile. If you have the\r\n     * following template:\r\n     * <pre>\r\n     * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\r\n     *\r\n     * <ul>\r\n     *     <li ng-repeat=\"contact in contacts\">\r\n     *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\r\n     *     </li>\r\n     * </ul>\r\n     * </pre>\r\n     *\r\n     * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\r\n     * <pre>\r\n     * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\r\n     *\r\n     * <ul>\r\n     *     <li ng-repeat=\"contact in contacts\">\r\n     *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\r\n     *     </li>\r\n     *     <li ng-repeat=\"contact in contacts\">\r\n     *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\r\n     *     </li>\r\n     *     <li ng-repeat=\"contact in contacts\">\r\n     *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\r\n     *     </li>\r\n     * </ul>\r\n     *\r\n     * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\r\n     * </pre>\r\n     *\r\n     * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\r\n     * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\r\n     */\r\n    $StateRefDirective.$inject = ['$state', '$timeout'];\r\n    function $StateRefDirective($state, $timeout) {\r\n        return {\r\n            restrict: 'A',\r\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\r\n            link: function (scope, element, attrs, uiSrefActive) {\r\n                var ref = parseStateRef(attrs.uiSref, $state.current.name);\r\n                var def = { state: ref.state, href: null, params: null };\r\n                var type = getTypeInfo(element);\r\n                var active = uiSrefActive[1] || uiSrefActive[0];\r\n\r\n                def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\r\n\r\n                var update = function (val) {\r\n                    if (val) def.params = angular.copy(val);\r\n                    def.href = $state.href(ref.state, def.params, def.options);\r\n\r\n                    if (active) active.$$addStateInfo(ref.state, def.params);\r\n                    if (def.href !== null) attrs.$set(type.attr, def.href);\r\n                };\r\n\r\n                if (ref.paramExpr) {\r\n                    scope.$watch(ref.paramExpr, function (val) { if (val !== def.params) update(val); }, true);\r\n                    def.params = angular.copy(scope.$eval(ref.paramExpr));\r\n                }\r\n                update();\r\n\r\n                if (!type.clickable) return;\r\n                element.bind(\"click\", clickHook(element, $state, $timeout, type, function () { return def; }));\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @ngdoc directive\r\n     * @name ui.router.state.directive:ui-state\r\n     *\r\n     * @requires ui.router.state.uiSref\r\n     *\r\n     * @restrict A\r\n     *\r\n     * @description\r\n     * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\r\n     * params and override options.\r\n     *\r\n     * @param {string} ui-state 'stateName' can be any valid absolute or relative state\r\n     * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\r\n     * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\r\n     */\r\n    $StateRefDynamicDirective.$inject = ['$state', '$timeout'];\r\n    function $StateRefDynamicDirective($state, $timeout) {\r\n        return {\r\n            restrict: 'A',\r\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\r\n            link: function (scope, element, attrs, uiSrefActive) {\r\n                var type = getTypeInfo(element);\r\n                var active = uiSrefActive[1] || uiSrefActive[0];\r\n                var group = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\r\n                var watch = '[' + group.map(function (val) { return val || 'null'; }).join(', ') + ']';\r\n                var def = { state: null, params: null, options: null, href: null };\r\n\r\n                function runStateRefLink(group) {\r\n                    def.state = group[0]; def.params = group[1]; def.options = group[2];\r\n                    def.href = $state.href(def.state, def.params, def.options);\r\n\r\n                    if (active) active.$$addStateInfo(def.state, def.params);\r\n                    if (def.href) attrs.$set(type.attr, def.href);\r\n                }\r\n\r\n                scope.$watch(watch, runStateRefLink, true);\r\n                runStateRefLink(scope.$eval(watch));\r\n\r\n                if (!type.clickable) return;\r\n                element.bind(\"click\", clickHook(element, $state, $timeout, type, function () { return def; }));\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * @ngdoc directive\r\n     * @name ui.router.state.directive:ui-sref-active\r\n     *\r\n     * @requires ui.router.state.$state\r\n     * @requires ui.router.state.$stateParams\r\n     * @requires $interpolate\r\n     *\r\n     * @restrict A\r\n     *\r\n     * @description\r\n     * A directive working alongside ui-sref to add classes to an element when the\r\n     * related ui-sref directive's state is active, and removing them when it is inactive.\r\n     * The primary use-case is to simplify the special appearance of navigation menus\r\n     * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\r\n     * distinguishing it from the inactive menu items.\r\n     *\r\n     * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\r\n     * ui-sref-active found at the same level or above the ui-sref will be used.\r\n     *\r\n     * Will activate when the ui-sref's target state or any child state is active. If you\r\n     * need to activate only when the ui-sref target state is active and *not* any of\r\n     * it's children, then you will use\r\n     * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\r\n     *\r\n     * @example\r\n     * Given the following template:\r\n     * <pre>\r\n     * <ul>\r\n     *   <li ui-sref-active=\"active\" class=\"item\">\r\n     *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\r\n     *   </li>\r\n     * </ul>\r\n     * </pre>\r\n     *\r\n     *\r\n     * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\r\n     * the resulting HTML will appear as (note the 'active' class):\r\n     * <pre>\r\n     * <ul>\r\n     *   <li ui-sref-active=\"active\" class=\"item active\">\r\n     *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\r\n     *   </li>\r\n     * </ul>\r\n     * </pre>\r\n     *\r\n     * The class name is interpolated **once** during the directives link time (any further changes to the\r\n     * interpolated value are ignored).\r\n     *\r\n     * Multiple classes may be specified in a space-separated format:\r\n     * <pre>\r\n     * <ul>\r\n     *   <li ui-sref-active='class1 class2 class3'>\r\n     *     <a ui-sref=\"app.user\">link</a>\r\n     *   </li>\r\n     * </ul>\r\n     * </pre>\r\n     *\r\n     * It is also possible to pass ui-sref-active an expression that evaluates\r\n     * to an object hash, whose keys represent active class names and whose\r\n     * values represent the respective state names/globs.\r\n     * ui-sref-active will match if the current active state **includes** any of\r\n     * the specified state names/globs, even the abstract ones.\r\n     *\r\n     * @Example\r\n     * Given the following template, with \"admin\" being an abstract state:\r\n     * <pre>\r\n     * <div ui-sref-active=\"{'active': 'admin.*'}\">\r\n     *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\r\n     * </div>\r\n     * </pre>\r\n     *\r\n     * When the current state is \"admin.roles\" the \"active\" class will be applied\r\n     * to both the <div> and <a> elements. It is important to note that the state\r\n     * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\r\n     */\r\n\r\n    /**\r\n     * @ngdoc directive\r\n     * @name ui.router.state.directive:ui-sref-active-eq\r\n     *\r\n     * @requires ui.router.state.$state\r\n     * @requires ui.router.state.$stateParams\r\n     * @requires $interpolate\r\n     *\r\n     * @restrict A\r\n     *\r\n     * @description\r\n     * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\r\n     * when the exact target state used in the `ui-sref` is active; no child states.\r\n     *\r\n     */\r\n    $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\r\n    function $StateRefActiveDirective($state, $stateParams, $interpolate) {\r\n        return {\r\n            restrict: \"A\",\r\n            controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\r\n                var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\r\n\r\n                // There probably isn't much point in $observing this\r\n                // uiSrefActive and uiSrefActiveEq share the same directive object with some\r\n                // slight difference in logic routing\r\n                activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\r\n\r\n                try {\r\n                    uiSrefActive = $scope.$eval($attrs.uiSrefActive);\r\n                } catch (e) {\r\n                    // Do nothing. uiSrefActive is not a valid expression.\r\n                    // Fall back to using $interpolate below\r\n                }\r\n                uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\r\n                if (isObject(uiSrefActive)) {\r\n                    forEach(uiSrefActive, function (stateOrName, activeClass) {\r\n                        if (isString(stateOrName)) {\r\n                            var ref = parseStateRef(stateOrName, $state.current.name);\r\n                            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // Allow uiSref to communicate with uiSrefActive[Equals]\r\n                this.$$addStateInfo = function (newState, newParams) {\r\n                    // we already got an explicit state provided by ui-sref-active, so we\r\n                    // shadow the one that comes from ui-sref\r\n                    if (isObject(uiSrefActive) && states.length > 0) {\r\n                        return;\r\n                    }\r\n                    addState(newState, newParams, uiSrefActive);\r\n                    update();\r\n                };\r\n\r\n                $scope.$on('$stateChangeSuccess', update);\r\n\r\n                function addState(stateName, stateParams, activeClass) {\r\n                    var state = $state.get(stateName, stateContext($element));\r\n                    var stateHash = createStateHash(stateName, stateParams);\r\n\r\n                    states.push({\r\n                        state: state || { name: stateName },\r\n                        params: stateParams,\r\n                        hash: stateHash\r\n                    });\r\n\r\n                    activeClasses[stateHash] = activeClass;\r\n                }\r\n\r\n                /**\r\n                 * @param {string} state\r\n                 * @param {Object|string} [params]\r\n                 * @return {string}\r\n                 */\r\n                function createStateHash(state, params) {\r\n                    if (!isString(state)) {\r\n                        throw new Error('state should be a string');\r\n                    }\r\n                    if (isObject(params)) {\r\n                        return state + toJson(params);\r\n                    }\r\n                    params = $scope.$eval(params);\r\n                    if (isObject(params)) {\r\n                        return state + toJson(params);\r\n                    }\r\n                    return state;\r\n                }\r\n\r\n                // Update route state\r\n                function update() {\r\n                    for (var i = 0; i < states.length; i++) {\r\n                        if (anyMatch(states[i].state, states[i].params)) {\r\n                            addClass($element, activeClasses[states[i].hash]);\r\n                        } else {\r\n                            removeClass($element, activeClasses[states[i].hash]);\r\n                        }\r\n\r\n                        if (exactMatch(states[i].state, states[i].params)) {\r\n                            addClass($element, activeEqClass);\r\n                        } else {\r\n                            removeClass($element, activeEqClass);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\r\n                function removeClass(el, className) { el.removeClass(className); }\r\n                function anyMatch(state, params) { return $state.includes(state.name, params); }\r\n                function exactMatch(state, params) { return $state.is(state.name, params); }\r\n\r\n                update();\r\n            }]\r\n        };\r\n    }\r\n\r\n    angular.module('ui.router.state')\r\n      .directive('uiSref', $StateRefDirective)\r\n      .directive('uiSrefActive', $StateRefActiveDirective)\r\n      .directive('uiSrefActiveEq', $StateRefActiveDirective)\r\n      .directive('uiState', $StateRefDynamicDirective);\r\n\r\n    /**\r\n     * @ngdoc filter\r\n     * @name ui.router.state.filter:isState\r\n     *\r\n     * @requires ui.router.state.$state\r\n     *\r\n     * @description\r\n     * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\r\n     */\r\n    $IsStateFilter.$inject = ['$state'];\r\n    function $IsStateFilter($state) {\r\n        var isFilter = function (state, params) {\r\n            return $state.is(state, params);\r\n        };\r\n        isFilter.$stateful = true;\r\n        return isFilter;\r\n    }\r\n\r\n    /**\r\n     * @ngdoc filter\r\n     * @name ui.router.state.filter:includedByState\r\n     *\r\n     * @requires ui.router.state.$state\r\n     *\r\n     * @description\r\n     * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\r\n     */\r\n    $IncludedByStateFilter.$inject = ['$state'];\r\n    function $IncludedByStateFilter($state) {\r\n        var includesFilter = function (state, params, options) {\r\n            return $state.includes(state, params, options);\r\n        };\r\n        includesFilter.$stateful = true;\r\n        return includesFilter;\r\n    }\r\n\r\n    angular.module('ui.router.state')\r\n      .filter('isState', $IsStateFilter)\r\n      .filter('includedByState', $IncludedByStateFilter);\r\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./libraries/angular/angular-ui-router.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\r\n * An Angular module that gives you access to the browsers local storage\r\n * @version v0.3.0 - 2016-07-29\r\n * @link https://github.com/grevory/angular-local-storage\r\n * @author grevory <greg@gregpike.ca>\r\n * @license MIT License, http://www.opensource.org/licenses/MIT\r\n */\r\n!function(a,b){var c=b.isDefined,d=b.isUndefined,e=b.isNumber,f=b.isObject,g=b.isArray,h=b.extend,i=b.toJson;b.module(\"LocalStorageModule\",[]).provider(\"localStorageService\",function(){this.prefix=\"ls\",this.storageType=\"localStorage\",this.cookie={expiry:30,path:\"/\"},this.defaultToCookie=!0,this.notify={setItem:!0,removeItem:!1},this.setPrefix=function(a){return this.prefix=a,this},this.setStorageType=function(a){return this.storageType=a,this},this.setDefaultToCookie=function(a){return this.defaultToCookie=!!a,this},this.setStorageCookie=function(a,b){return this.cookie.expiry=a,this.cookie.path=b,this},this.setStorageCookieDomain=function(a){return this.cookie.domain=a,this},this.setNotify=function(a,b){return this.notify={setItem:a,removeItem:b},this},this.$get=[\"$rootScope\",\"$window\",\"$document\",\"$parse\",\"$timeout\",function(a,b,j,k,l){function m(c){if(c||(c=b.event),r.setItem&&v(c.key)){var d=u(c.key);l(function(){a.$broadcast(\"LocalStorageModule.notification.changed\",{key:d,newvalue:c.newValue,storageType:o.storageType})})}}var n,o=this,p=o.prefix,q=o.cookie,r=o.notify,s=o.storageType;j?j[0]&&(j=j[0]):j=document,\".\"!==p.substr(-1)&&(p=p?p+\".\":\"\");var t=function(a){return p+a},u=function(a){return a.replace(new RegExp(\"^\"+p,\"g\"),\"\")},v=function(a){return 0===a.indexOf(p)},w=function(){try{var c=s in b&&null!==b[s],d=t(\"__\"+Math.round(1e7*Math.random()));return c&&(n=b[s],n.setItem(d,\"\"),n.removeItem(d)),c}catch(b){return o.defaultToCookie&&(s=\"cookie\"),a.$broadcast(\"LocalStorageModule.notification.error\",b.message),!1}},x=w(),y=function(b,c,e){if(J(e),c=d(c)?null:i(c),!x&&o.defaultToCookie||\"cookie\"===o.storageType)return x||a.$broadcast(\"LocalStorageModule.notification.warning\",\"LOCAL_STORAGE_NOT_SUPPORTED\"),r.setItem&&a.$broadcast(\"LocalStorageModule.notification.setitem\",{key:b,newvalue:c,storageType:\"cookie\"}),E(b,c);try{n&&n.setItem(t(b),c),r.setItem&&a.$broadcast(\"LocalStorageModule.notification.setitem\",{key:b,newvalue:c,storageType:o.storageType})}catch(d){return a.$broadcast(\"LocalStorageModule.notification.error\",d.message),E(b,c)}return!0},z=function(b,c){if(J(c),!x&&o.defaultToCookie||\"cookie\"===o.storageType)return x||a.$broadcast(\"LocalStorageModule.notification.warning\",\"LOCAL_STORAGE_NOT_SUPPORTED\"),F(b);var d=n?n.getItem(t(b)):null;if(!d||\"null\"===d)return null;try{return JSON.parse(d)}catch(a){return d}},A=function(){var b=0;arguments.length>=1&&(\"localStorage\"===arguments[arguments.length-1]||\"sessionStorage\"===arguments[arguments.length-1])&&(b=1,J(arguments[arguments.length-1]));var c,d;for(c=0;c<arguments.length-b;c++)if(d=arguments[c],!x&&o.defaultToCookie||\"cookie\"===o.storageType)x||a.$broadcast(\"LocalStorageModule.notification.warning\",\"LOCAL_STORAGE_NOT_SUPPORTED\"),r.removeItem&&a.$broadcast(\"LocalStorageModule.notification.removeitem\",{key:d,storageType:\"cookie\"}),G(d);else try{n.removeItem(t(d)),r.removeItem&&a.$broadcast(\"LocalStorageModule.notification.removeitem\",{key:d,storageType:o.storageType})}catch(b){a.$broadcast(\"LocalStorageModule.notification.error\",b.message),G(d)}},B=function(b){if(J(b),!x)return a.$broadcast(\"LocalStorageModule.notification.warning\",\"LOCAL_STORAGE_NOT_SUPPORTED\"),[];var c=p.length,d=[];for(var e in n)if(e.substr(0,c)===p)try{d.push(e.substr(c))}catch(b){return a.$broadcast(\"LocalStorageModule.notification.error\",b.Description),[]}return d},C=function(b,c){J(c);var d=p?new RegExp(\"^\"+p):new RegExp,e=b?new RegExp(b):new RegExp;if(!x&&o.defaultToCookie||\"cookie\"===o.storageType)return x||a.$broadcast(\"LocalStorageModule.notification.warning\",\"LOCAL_STORAGE_NOT_SUPPORTED\"),H();if(!x&&!o.defaultToCookie)return!1;var f=p.length;for(var g in n)if(d.test(g)&&e.test(g.substr(f)))try{A(g.substr(f))}catch(b){return a.$broadcast(\"LocalStorageModule.notification.error\",b.message),H()}return!0},D=function(){try{return b.navigator.cookieEnabled||\"cookie\"in j&&(j.cookie.length>0||(j.cookie=\"test\").indexOf.call(j.cookie,\"test\")>-1)}catch(b){return a.$broadcast(\"LocalStorageModule.notification.error\",b.message),!1}}(),E=function(b,c,h){if(d(c))return!1;if((g(c)||f(c))&&(c=i(c)),!D)return a.$broadcast(\"LocalStorageModule.notification.error\",\"COOKIES_NOT_SUPPORTED\"),!1;try{var k=\"\",l=new Date,m=\"\";if(null===c?(l.setTime(l.getTime()+-864e5),k=\"; expires=\"+l.toGMTString(),c=\"\"):e(h)&&0!==h?(l.setTime(l.getTime()+24*h*60*60*1e3),k=\"; expires=\"+l.toGMTString()):0!==q.expiry&&(l.setTime(l.getTime()+24*q.expiry*60*60*1e3),k=\"; expires=\"+l.toGMTString()),b){var n=\"; path=\"+q.path;q.domain&&(m=\"; domain=\"+q.domain),j.cookie=t(b)+\"=\"+encodeURIComponent(c)+k+n+m}}catch(b){return a.$broadcast(\"LocalStorageModule.notification.error\",b.message),!1}return!0},F=function(b){if(!D)return a.$broadcast(\"LocalStorageModule.notification.error\",\"COOKIES_NOT_SUPPORTED\"),!1;for(var c=j.cookie&&j.cookie.split(\";\")||[],d=0;d<c.length;d++){for(var e=c[d];\" \"===e.charAt(0);)e=e.substring(1,e.length);if(0===e.indexOf(t(b)+\"=\")){var f=decodeURIComponent(e.substring(p.length+b.length+1,e.length));try{return JSON.parse(f)}catch(a){return f}}}return null},G=function(a){E(a,null)},H=function(){for(var a=null,b=p.length,c=j.cookie.split(\";\"),d=0;d<c.length;d++){for(a=c[d];\" \"===a.charAt(0);)a=a.substring(1,a.length);var e=a.substring(b,a.indexOf(\"=\"));G(e)}},I=function(){return s},J=function(a){return a&&s!==a&&(s=a,x=w()),x},K=function(a,b,d,e,g){e=e||b;var i=z(e,g);return null===i&&c(d)?i=d:f(i)&&f(d)&&(i=h(i,d)),k(b).assign(a,i),a.$watch(b,function(a){y(e,a,g)},f(a[b]))};x&&(b.addEventListener?b.addEventListener(\"storage\",m,!1):b.attachEvent&&b.attachEvent(\"onstorage\",m));var L=function(a){J(a);for(var c=0,d=b[s],e=0;e<d.length;e++)0===d.key(e).indexOf(p)&&c++;return c};return{isSupported:x,getStorageType:I,setStorageType:J,set:y,add:y,get:z,keys:B,remove:A,clearAll:C,bind:K,deriveKey:t,underiveKey:u,length:L,defaultToCookie:this.defaultToCookie,cookie:{isSupported:D,set:E,add:E,get:F,remove:G,clearAll:H}}}]})}(window,window.angular);\r\n//# sourceMappingURL=angular-local-storage.min.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./libraries/angular/angular-local-storage.min.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\r\n * Created by Apexol on 06-Aug-16.\r\n */\r\nconst Configuration = {\r\n    themeName: \"AdminLTE\",\r\n    rootApiUrl: \"\"\r\n};\r\n\r\nwindow.Configuration = Configuration;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./config.js\n ** module id = 4\n ** module chunks = 0\n **/","window.mobSocial = angular.module(\"mobSocialApp\", ['ui.router', 'LocalStorageModule'])\r\n    .constant('globalApiEndPoint', 'http://mobsocial.com/api')\r\n    .factory('$global', [\r\n        'globalApiEndPoint', function (globalApiEndPoint) {\r\n            return {\r\n                getApiUrl: function (url) {\r\n                    return globalApiEndPoint + url;\r\n                }\r\n            }\r\n        }\r\n    ]);\r\n\r\nwindow.mobSocial.config([\"$stateProvider\",\r\n    \"$urlRouterProvider\",\r\n    \"$locationProvider\",\r\n    \"localStorageServiceProvider\", function ($stateProvider, $urlRouterProvider, $locationProvider, localStorageServiceProvider) {\r\n    $urlRouterProvider.otherwise(\"/\");\r\n        $stateProvider\r\n            .state(\"layoutZero\",\r\n            {\r\n                templateUrl: \"pages/layouts/_layout-none.html\"\r\n            })\r\n            .state(\"layoutZero.login\",\r\n            {\r\n                templateUrl: \"pages/login.html\",\r\n                url: \"/login\"\r\n            });\r\n        $stateProvider\r\n            .state(\"layoutDashboard\",\r\n            {\r\n                resolve: {\r\n                    auth: function(authProvider) {\r\n                        return authProvider.isLoggedIn();\r\n                    }\r\n                },\r\n                templateUrl: \"pages/layouts/_layout-dashboard.html\"\r\n            })\r\n            .state(\"layoutDashboard.dashboard\",\r\n            {\r\n                url: \"/dashboard\",\r\n                templateUrl: \"pages/dashboard.html\"\r\n            });\r\n           \r\n\r\n    // use the HTML5 History API\r\n    $locationProvider.html5Mode(true);\r\n\r\n        //local storage\r\n    localStorageServiceProvider.setPrefix('mobSocial');\r\n}]);\r\n\r\n//attach some global functions to rootScope\r\nwindow.mobSocial.run([\"$rootScope\", \"$sce\", \"authProvider\", \"$state\", \"$window\", function ($rootScope, $sce, authProvider, $state, $window) {\r\n    //whenever a route changes, check if authentication is required, if yes, better redirect to login page\r\n    $rootScope.$on('$stateChangeError', function (event, toState, toParams, fromState, fromParams, error) {\r\n        if (error === 'Not Authenticated') {\r\n            event.preventDefault();\r\n            window.location.href = \"/login?ReturnUrl=\" + encodeURIComponent(toState.url);\r\n        }\r\n    });\r\n    //execute some theme callbacks on view content loaded\r\n    $rootScope.$on('$viewContentLoaded',\r\n        function (event, viewConfig) {\r\n            if (viewConfig !== \"@\") {\r\n                if ($window['viewContentLoaded']) {\r\n                    $window['viewContentLoaded']();\r\n                }\r\n            }\r\n            \r\n    });\r\n\r\n    //set logged in user for use throughout\r\n    $rootScope.CurrentUser = authProvider.getLoggedInUser();\r\n\r\n    $rootScope.login = function (returnUrl) {\r\n        //because the returnUrl may be absolute, it's better to explicitly reference the path from url for proper functioning\r\n        var a = document.createElement(\"a\");\r\n        a.href = returnUrl;\r\n        window.location.href = \"/login?ReturnUrl=\" + encodeURIComponent(a.pathname);\r\n    };\r\n\r\n    $rootScope.displayErrors = function (contextName) {\r\n        var errors = $rootScope._errorMessages[contextName];\r\n        if (!errors)\r\n            return \"\";\r\n\r\n        var str = \"<ul>\";\r\n        for (var i = 0; i < errors.length; i++) {\r\n            str += \"<li>\" + errors[i] + \"</li>\";\r\n        }\r\n        str += \"</ul>\";\r\n        return $sce.trustAsHtml(str);\r\n    }\r\n\r\n    $rootScope.displayMessages = function (contextName) {\r\n        var msgs = $rootScope._responseMessages[contextName];\r\n        if (!msgs)\r\n            return \"\";\r\n\r\n        var str = \"<ul>\";\r\n        for (var i = 0; i < msgs.length; i++) {\r\n            str += \"<li>\" + msgs[i] + \"</li>\";\r\n        }\r\n        str += \"</ul>\";\r\n        return $sce.trustAsHtml(str);\r\n    }\r\n    $rootScope.displayNotifications = function (contextName) {\r\n        return $sce.trustAsHtml($rootScope.displayErrors(contextName) + $rootScope.displayMessages(contextName));\r\n    }\r\n    $rootScope.clearMessages = function () {\r\n        $rootScope._responseMessages = {};\r\n        $rootScope._errorMessages = {};\r\n    };\r\n    $rootScope.clearMessages();\r\n}]);\r\n\r\n//todo: move to a separate file\r\nfunction setDataModel(model) {\r\n    window.mobSocial.value(\"dataModel\", model);\r\n}\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/app.js\n ** module id = 5\n ** module chunks = 0\n **/","window.mobSocial.factory('authProvider', ['$q', 'localStorageService', function ($q, localStorageService) {\r\n    const loggedinKey = \"loggedin\";\r\n    const userInfoKey = \"userinfo\";\r\n    return {\r\n        markLoggedIn: function(user) {\r\n            localStorageService.set(loggedinKey, true);\r\n            localStorageService.set(userInfoKey, user);\r\n        },\r\n        getLoggedInUser: function() {\r\n            return localStorageService.get(userInfoKey);\r\n        },\r\n        isLoggedIn: function () {\r\n            //Authentication logic here\r\n            if (localStorageService.get(loggedinKey)) {\r\n                return true;\r\n            } else {\r\n                //Else send a rejection\r\n                return $q.reject('Not Authenticated');\r\n            }\r\n        }\r\n    };\r\n}]);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/common/authProvider.js\n ** module id = 6\n ** module chunks = 0\n **/","window.mobSocial.service(\"webClientService\", [\"$http\", function ($http) {\n\n    this._connect = function (method, url, params, success, error) {\n        var config = {\n            method: method,\n            url: url\n        };\n        if (method === \"GET\")\n            config[\"params\"] = params;\n        else {\n            config[\"data\"] = params;\n            config[\"dataType\"] = \"json\";\n        }\n\n        $http(config).then(function(response) {\n            if (success)\n                success(response.data);\n        }, function(response) {\n            if (error)\n                error(response.data);\n        });\n    }\n\n    this.get = function (url, params, success, error) {\n        this._connect(\"GET\", url, params, success, error);\n    };\n\n    this.post = function (url, params, success, error) {\r\n        this._connect(\"POST\", url, params, success, error);\n    };\n\n    this.put = function (url, params, success, error) {\r\n        this._connect(\"PUT\", url, params, success, error);\r\n    };\n\n    this.patch = function (url, params, success, error) {\r\n        this._connect(\"PATCH\", url, params, success, error);\r\n    };\n\n    this.delete = function (url, params, success, error) {\r\n        this._connect(\"DELETE\", url, params, success, error);\r\n    };\n}]);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/common/webClientService.js\n ** module id = 7\n ** module chunks = 0\n **/","window.mobSocial.service(\"loginService\", [\r\n    \"webClientService\", \"$global\", function (webClientService, $global) {\r\n       this.login = function (loginRequest, success, error) {\r\n            var loginUrl = $global.getApiUrl(\"/authentication/login\");\r\n            webClientService.post(loginUrl, loginRequest, success, error);\r\n        }\r\n    }\r\n]);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/public/authentication/loginService.js\n ** module id = 8\n ** module chunks = 0\n **/","window.mobSocial.controller(\"loginController\",[\r\n    \"$scope\", \"loginService\", \"authProvider\", \"$location\", function ($scope, loginService, authProvider, $location) {\r\n       \r\n        $scope.init = function() {\r\n            $scope.dataModel = {\r\n                Email: \"\",\r\n                Password: \"\",\r\n                Persist: false,\r\n                ReturnUrl: $location.search().ReturnUrl\r\n            };\r\n        };\r\n\r\n        $scope.login = function() {\r\n            loginService.login($scope.dataModel,\r\n                function(response) {\r\n                    if (response.Success) {\r\n                        authProvider.markLoggedIn(response.ResponseData.User); //mark as logged in\r\n                        if (response.ResponseData && response.ResponseData.ReturnUrl)\r\n                            window.location.href = response.ResponseData.ReturnUrl;\r\n                        else\r\n                            window.location.href = \"/\";\r\n                    }\r\n                },\r\n                function(response) {\r\n\r\n                });\r\n        }\r\n    }\r\n]);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/public/authentication/loginController.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}